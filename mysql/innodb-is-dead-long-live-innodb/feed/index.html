<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	
	>
<channel>
	<title>
	Comments on: InnoDB is dead. Long live InnoDB!	</title>
	<atom:link href="https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/feed" rel="self" type="application/rss+xml" />
	<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Wed, 16 Dec 2009 07:09:19 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
			<item>
				<title>
				By: Alaric Snell-Pym				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-7379</link>
		<dc:creator><![CDATA[Alaric Snell-Pym]]></dc:creator>
		<pubDate>Mon, 30 Nov 2009 18:24:29 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-7379</guid>
					<description><![CDATA[Synchronous replication isn&#039;t the only way to go... sure, it&#039;s bearable on small clusters, but when you have tens of slaves, it gets painful.

Here at GenieDB, we&#039;ve done some tricks with asynchronous replication combined with synchronously updating a chosen-per-record-with-a-hash-of-the-PK &#039;consistency buffer&#039; server that stores the record in-memory for long enough for the asynch replication to happen, thereby getting around the problem with a small latency increase (the consistency buffer is highly optimised for low latency; we use memcache!) that doesn&#039;t grow as the number of replicas does.]]></description>
		<content:encoded><![CDATA[<p>Synchronous replication isn&#8217;t the only way to go&#8230; sure, it&#8217;s bearable on small clusters, but when you have tens of slaves, it gets painful.</p>
<p>Here at GenieDB, we&#8217;ve done some tricks with asynchronous replication combined with synchronously updating a chosen-per-record-with-a-hash-of-the-PK &#8216;consistency buffer&#8217; server that stores the record in-memory for long enough for the asynch replication to happen, thereby getting around the problem with a small latency increase (the consistency buffer is highly optimised for low latency; we use memcache!) that doesn&#8217;t grow as the number of replicas does.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Vasil Dimov				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3891</link>
		<dc:creator><![CDATA[Vasil Dimov]]></dc:creator>
		<pubDate>Fri, 11 Sep 2009 16:11:01 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3891</guid>
					<description><![CDATA[Mark,

I agree with you :)]]></description>
		<content:encoded><![CDATA[<p>Mark,</p>
<p>I agree with you üôÇ</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Mark Callaghan				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3890</link>
		<dc:creator><![CDATA[Mark Callaghan]]></dc:creator>
		<pubDate>Fri, 11 Sep 2009 15:33:15 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3890</guid>
					<description><![CDATA[Vasil,
When the server is on a 3 to 4 year release cycle and the current release does not scale on commodity HW, then you should make these changes to the GA release or users will go elsewhere (PostgreSQL, XtraDB). The InnoDB plugin has made 5.1 much more attractive as an upgrade target.]]></description>
		<content:encoded><![CDATA[<p>Vasil,<br />
When the server is on a 3 to 4 year release cycle and the current release does not scale on commodity HW, then you should make these changes to the GA release or users will go elsewhere (PostgreSQL, XtraDB). The InnoDB plugin has made 5.1 much more attractive as an upgrade target.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Vasil Dimov				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3889</link>
		<dc:creator><![CDATA[Vasil Dimov]]></dc:creator>
		<pubDate>Fri, 11 Sep 2009 15:25:59 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3889</guid>
					<description><![CDATA[Hi,

You can&#039;t expect new features or significant performance improvements in a GA branch. This is what GA is by definition. Hot features and stability are adverse.]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>You can&#8217;t expect new features or significant performance improvements in a GA branch. This is what GA is by definition. Hot features and stability are adverse.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3882</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Fri, 11 Sep 2009 09:29:44 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3882</guid>
					<description><![CDATA[Hi Vasil,

Thanks. I&#039;m not referring to the fact that InnoDB in 5.1 &amp; 5.0 is now frozen to new features.
I&#039;m not referring to bug fixes, as well.

I&#039;m wondering if any further development is going to take place on builtin InnoDB. My impression is that all further development, performance improvements etc. goes to InnoDB plugin, and I suspect that the Plugin will become that main InnoDB distribution from now on.
For example: will the builtin InnoDB code get the group-commit fix? Is it planned to get this fix in future versions?

My impression is that it will not. I may be completely wrong; but it appears this way. If you know this isn&#039;t the case at all, please say so. But I believe I&#039;m not the only one who got the impression I expressed here. Therefore, Innobase/Oracle may wish to speak openly about InnoDB development plans.

Regards,
Shlomi]]></description>
		<content:encoded><![CDATA[<p>Hi Vasil,</p>
<p>Thanks. I&#8217;m not referring to the fact that InnoDB in 5.1 &#038; 5.0 is now frozen to new features.<br />
I&#8217;m not referring to bug fixes, as well.</p>
<p>I&#8217;m wondering if any further development is going to take place on builtin InnoDB. My impression is that all further development, performance improvements etc. goes to InnoDB plugin, and I suspect that the Plugin will become that main InnoDB distribution from now on.<br />
For example: will the builtin InnoDB code get the group-commit fix? Is it planned to get this fix in future versions?</p>
<p>My impression is that it will not. I may be completely wrong; but it appears this way. If you know this isn&#8217;t the case at all, please say so. But I believe I&#8217;m not the only one who got the impression I expressed here. Therefore, Innobase/Oracle may wish to speak openly about InnoDB development plans.</p>
<p>Regards,<br />
Shlomi</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Vasil Dimov				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3879</link>
		<dc:creator><![CDATA[Vasil Dimov]]></dc:creator>
		<pubDate>Fri, 11 Sep 2009 06:37:26 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3879</guid>
					<description><![CDATA[&quot;I only saw (or was exposed to, at least) progress on the plugin. The way I understand it, the plugin is the main (and only?) focus of development. And this is the significant thing to consider: if you‚Äôre keeping to ‚Äúold InnoDB‚Äù, fine ‚Äì but it won‚Äôt get you much farther; you‚Äôre unlikely to see great performance improvements&quot;

Hi, the builtin InnoDB in MySQL 5.1 and the whole MySQL 5.1 is GA and frozen for new features and big/risky changes. This is a common sense - you don&#039;t risk the stability of the stable branch with new features. Of course 5.0 and 5.1 are getting all the bugfixes, so they are nowhere near &quot;stalled&quot;.]]></description>
		<content:encoded><![CDATA[<p>&#8220;I only saw (or was exposed to, at least) progress on the plugin. The way I understand it, the plugin is the main (and only?) focus of development. And this is the significant thing to consider: if you‚Äôre keeping to ‚Äúold InnoDB‚Äù, fine ‚Äì but it won‚Äôt get you much farther; you‚Äôre unlikely to see great performance improvements&#8221;</p>
<p>Hi, the builtin InnoDB in MySQL 5.1 and the whole MySQL 5.1 is GA and frozen for new features and big/risky changes. This is a common sense &#8211; you don&#8217;t risk the stability of the stable branch with new features. Of course 5.0 and 5.1 are getting all the bugfixes, so they are nowhere near &#8220;stalled&#8221;.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Andy Grove				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3818</link>
		<dc:creator><![CDATA[Andy Grove]]></dc:creator>
		<pubDate>Thu, 10 Sep 2009 20:38:17 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3818</guid>
					<description><![CDATA[@Mark - What I can say is that we co-ordinate with the database transaction to ensure that we record the order that the commits happen and then make sure we apply the transactions in the same order on the slave. 

@Shlomi - Yes, we do have higher concurrency on the slave when using dbShards. Transactions are effectively written to the master and slave machines in parallel with the same concurrency (although it should be noted that we do not write to the slave DB at this time, just to slave memory or log). We know that the dbShards log reliable replication is much faster than the master DB, so this is how we have such a minimal effect on performance. The main evil of replication lag is what happens if the master fails before transactions have been communicated to the slave. With our approach we do not lose any transactions if this happens.]]></description>
		<content:encoded><![CDATA[<p>@Mark &#8211; What I can say is that we co-ordinate with the database transaction to ensure that we record the order that the commits happen and then make sure we apply the transactions in the same order on the slave. </p>
<p>@Shlomi &#8211; Yes, we do have higher concurrency on the slave when using dbShards. Transactions are effectively written to the master and slave machines in parallel with the same concurrency (although it should be noted that we do not write to the slave DB at this time, just to slave memory or log). We know that the dbShards log reliable replication is much faster than the master DB, so this is how we have such a minimal effect on performance. The main evil of replication lag is what happens if the master fails before transactions have been communicated to the slave. With our approach we do not lose any transactions if this happens.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Mark Callaghan				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3815</link>
		<dc:creator><![CDATA[Mark Callaghan]]></dc:creator>
		<pubDate>Thu, 10 Sep 2009 18:42:06 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3815</guid>
					<description><![CDATA[Andy,

OK, and I will add dbShards to the list of topics I won&#039;t discuss. I don&#039;t want to interfere with your business, but I also don&#039;t want to waste my time doing marketing for it.]]></description>
		<content:encoded><![CDATA[<p>Andy,</p>
<p>OK, and I will add dbShards to the list of topics I won&#8217;t discuss. I don&#8217;t want to interfere with your business, but I also don&#8217;t want to waste my time doing marketing for it.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3814</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Thu, 10 Sep 2009 18:37:24 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3814</guid>
					<description><![CDATA[@Mark - thanks

@Andy - to fight replication lag you would need more than slowing down the master. Does your solution make for higher concurrency on the slave? You say you do not serialize the commits. Does it follow that you are able to pass them on synchronously to the slave with original concurrency?]]></description>
		<content:encoded><![CDATA[<p>@Mark &#8211; thanks</p>
<p>@Andy &#8211; to fight replication lag you would need more than slowing down the master. Does your solution make for higher concurrency on the slave? You say you do not serialize the commits. Does it follow that you are able to pass them on synchronously to the slave with original concurrency?</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Andy Grove				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/innodb-is-dead-long-live-innodb/comment-page-1#comment-3813</link>
		<dc:creator><![CDATA[Andy Grove]]></dc:creator>
		<pubDate>Thu, 10 Sep 2009 18:31:19 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1271#comment-3813</guid>
					<description><![CDATA[That was the hard part in building the product. It&#039;s actually part of our patent-pending technology so unfortunately I can&#039;t go into the detail of how we implemented but we do not serialize the commits (we tried that approach early on and performance was terrible).]]></description>
		<content:encoded><![CDATA[<p>That was the hard part in building the product. It&#8217;s actually part of our patent-pending technology so unfortunately I can&#8217;t go into the detail of how we implemented but we do not serialize the commits (we tried that approach early on and performance was terrible).</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

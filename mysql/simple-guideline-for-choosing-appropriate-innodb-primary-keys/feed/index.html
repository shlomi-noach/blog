<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	
	>
<channel>
	<title>
	Comments on: Simple guideline for choosing appropriate InnoDB PRIMARY KEYs	</title>
	<atom:link href="https://shlomi-noach.github.io/blog/mysql/simple-guideline-for-choosing-appropriate-innodb-primary-keys/feed" rel="self" type="application/rss+xml" />
	<link>https://shlomi-noach.github.io/blog/mysql/simple-guideline-for-choosing-appropriate-innodb-primary-keys</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Fri, 22 Oct 2010 11:15:48 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
			<item>
				<title>
				By: Mark R				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/simple-guideline-for-choosing-appropriate-innodb-primary-keys/comment-page-1#comment-19511</link>
		<dc:creator><![CDATA[Mark R]]></dc:creator>
		<pubDate>Fri, 22 Oct 2010 11:15:48 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=2104#comment-19511</guid>
					<description><![CDATA[There are cases where selecting a non-obvious primary key massively improves performance, by having the rows you&#039;re likely to be interested in clustered.

Take the case where you have some kind of Message ID which is generated in a fairly arbitrary fashion; this on its own is a valid candidate key,

However, if we add the thing that customers are likely to search on (the customer ID) as the first part of the primary key, and make it (customerID, messageID), then the customer&#039;s messages all cluster together, in the same pages, which massively reduces the number of IOPS on these queries.

This is, of course, a special case. Typical OLTP-type apps don&#039;t need to care about it, nor does anyone else whose database fits in memory.

Mark]]></description>
		<content:encoded><![CDATA[<p>There are cases where selecting a non-obvious primary key massively improves performance, by having the rows you&#8217;re likely to be interested in clustered.</p>
<p>Take the case where you have some kind of Message ID which is generated in a fairly arbitrary fashion; this on its own is a valid candidate key,</p>
<p>However, if we add the thing that customers are likely to search on (the customer ID) as the first part of the primary key, and make it (customerID, messageID), then the customer&#8217;s messages all cluster together, in the same pages, which massively reduces the number of IOPS on these queries.</p>
<p>This is, of course, a special case. Typical OLTP-type apps don&#8217;t need to care about it, nor does anyone else whose database fits in memory.</p>
<p>Mark</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

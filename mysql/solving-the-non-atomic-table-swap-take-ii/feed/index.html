<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	
	>
<channel>
	<title>
	Comments on: Solving the non-atomic table swap, Take II	</title>
	<atom:link href="https://shlomi-noach.github.io/blog/mysql/solving-the-non-atomic-table-swap-take-ii/feed" rel="self" type="application/rss+xml" />
	<link>https://shlomi-noach.github.io/blog/mysql/solving-the-non-atomic-table-swap-take-ii</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Tue, 21 Jun 2016 08:22:00 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
			<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/solving-the-non-atomic-table-swap-take-ii/comment-page-1#comment-363978</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Tue, 21 Jun 2016 08:22:00 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7567#comment-363978</guid>
					<description><![CDATA[@Justin,

- The `select * for update` may take long minutes to potentially a couple hours to merely grab the locks; meanwhile it will pollute the master&#039;s buffer pool (though I agree an ongoing migration also pollutes it, just not all at the same time)

- I thought about relying on events, but that means I must have `event_scheduler` enabled. Seems fine, but I want our tool to go public and be used by everyone, so maybe some people turn off their scheduler, and if the tool happens to turn it on, bad things happen.

- And still some `pt-kill` might kill the event_scheduler-exeuted connection. What happens if my `rename table a to b` executes 1ms _after_ said connection was killed? Events have been applied to the original table, and we just shoved them aside...]]></description>
		<content:encoded><![CDATA[<p>@Justin,</p>
<p>&#8211; The `select * for update` may take long minutes to potentially a couple hours to merely grab the locks; meanwhile it will pollute the master&#8217;s buffer pool (though I agree an ongoing migration also pollutes it, just not all at the same time)</p>
<p>&#8211; I thought about relying on events, but that means I must have `event_scheduler` enabled. Seems fine, but I want our tool to go public and be used by everyone, so maybe some people turn off their scheduler, and if the tool happens to turn it on, bad things happen.</p>
<p>&#8211; And still some `pt-kill` might kill the event_scheduler-exeuted connection. What happens if my `rename table a to b` executes 1ms _after_ said connection was killed? Events have been applied to the original table, and we just shoved them aside&#8230;</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Justin Swanhart				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/solving-the-non-atomic-table-swap-take-ii/comment-page-1#comment-363886</link>
		<dc:creator><![CDATA[Justin Swanhart]]></dc:creator>
		<pubDate>Mon, 20 Jun 2016 20:55:49 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7567#comment-363886</guid>
					<description><![CDATA[You can of course do lock table write instead of select count(*) for update, but I am not sure if innodb always honors lock table write...  I seem to recall an option that prevents that, but I can&#039;t remember it off the top of my head.]]></description>
		<content:encoded><![CDATA[<p>You can of course do lock table write instead of select count(*) for update, but I am not sure if innodb always honors lock table write&#8230;  I seem to recall an option that prevents that, but I can&#8217;t remember it off the top of my head.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Justin Swanhart				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/solving-the-non-atomic-table-swap-take-ii/comment-page-1#comment-363883</link>
		<dc:creator><![CDATA[Justin Swanhart]]></dc:creator>
		<pubDate>Mon, 20 Jun 2016 20:46:54 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7567#comment-363883</guid>
					<description><![CDATA[How about using an EVENT that does a &#039;SELECT * FROM TABLE FOR UPDATE&#039; then sits waiting for a GET_LOCK lock to show up and releases the SELECT lock when it does?

This way you can:
event: select * from X for update
event: loop (with short sleep()) until IS_USED_LOCK(&#039;release_lock_X&#039;);
rollback;

asynch process:
finish apply
rename table a to b; --blocks on SELECT FOR UPDATE
in second connection GET_LOCK(&#039;release_lock_X&#039;)
rename completes]]></description>
		<content:encoded><![CDATA[<p>How about using an EVENT that does a &#8216;SELECT * FROM TABLE FOR UPDATE&#8217; then sits waiting for a GET_LOCK lock to show up and releases the SELECT lock when it does?</p>
<p>This way you can:<br />
event: select * from X for update<br />
event: loop (with short sleep()) until IS_USED_LOCK(&#8216;release_lock_X&#8217;);<br />
rollback;</p>
<p>asynch process:<br />
finish apply<br />
rename table a to b; &#8211;blocks on SELECT FOR UPDATE<br />
in second connection GET_LOCK(&#8216;release_lock_X&#8217;)<br />
rename completes</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/solving-the-non-atomic-table-swap-take-ii/comment-page-1#comment-363864</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Mon, 20 Jun 2016 18:44:52 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7567#comment-363864</guid>
					<description><![CDATA[It&#039;s worth noting that on replicas this is a non atomic two-step swap.
On replica, there will be no writes on the table in between the two RENAMEs, but there may potentially be other writes from other tables in between those RENAMEs.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s worth noting that on replicas this is a non atomic two-step swap.<br />
On replica, there will be no writes on the table in between the two RENAMEs, but there may potentially be other writes from other tables in between those RENAMEs.</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	
	>
<channel>
	<title>
	Comments on: Using triggers to block malicious code: an example	</title>
	<atom:link href="https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/feed" rel="self" type="application/rss+xml" />
	<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Wed, 27 May 2009 09:21:17 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
			<item>
				<title>
				By: Phil				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-2102</link>
		<dc:creator><![CDATA[Phil]]></dc:creator>
		<pubDate>Wed, 27 May 2009 09:21:17 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-2102</guid>
					<description><![CDATA[It&#039;d be really nice to see fine grained access controls in MySQL - so that you could set permissions for individual records in a table.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;d be really nice to see fine grained access controls in MySQL &#8211; so that you could set permissions for individual records in a table.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: code.openark.org &#187; Blog Archive &#187; Triggers Use Case Compilation, Part II				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-307</link>
		<dc:creator><![CDATA[code.openark.org &#187; Blog Archive &#187; Triggers Use Case Compilation, Part II]]></dc:creator>
		<pubDate>Thu, 15 Jan 2009 08:03:26 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-307</guid>
					<description><![CDATA[[...] Using triggers to block malicious code: an example, I have shown how a trigger may block changes to sensitive data. A trigger is aware of the invoker, [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Using triggers to block malicious code: an example, I have shown how a trigger may block changes to sensitive data. A trigger is aware of the invoker, [&#8230;]</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-226</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Mon, 05 Jan 2009 16:59:09 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-226</guid>
					<description><![CDATA[Matthew,

The MySQL security model aloows for table-level and even column-level restriction. That is, it is possible to &quot;hide&quot; some tables from a user, allowing her to access relevant views.
This usually means a complicated privilege system: if you have many tables and many users, it may become difficult to maintain the privileges.]]></description>
		<content:encoded><![CDATA[<p>Matthew,</p>
<p>The MySQL security model aloows for table-level and even column-level restriction. That is, it is possible to &#8220;hide&#8221; some tables from a user, allowing her to access relevant views.<br />
This usually means a complicated privilege system: if you have many tables and many users, it may become difficult to maintain the privileges.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Matthew				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-225</link>
		<dc:creator><![CDATA[Matthew]]></dc:creator>
		<pubDate>Mon, 05 Jan 2009 16:33:11 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-225</guid>
					<description><![CDATA[Surely the other issue with using a VIEW in this case would be that a potential attacker is less likely to be considerate and attempt to modify through the VIEW (even if this is shown in the application, rather than direct access to the table), since if they&#039;ve got access to be able to issue such a query, they almost certainly have sufficient access to show tables. By using a trigger, the attempt will still be caught however the attacker tries to change the table in question.

Unless, of course, you can enforce a VIEW as being the only way to access a particular table - I&#039;ve not come across the idea, but my general use of views is for reading data.]]></description>
		<content:encoded><![CDATA[<p>Surely the other issue with using a VIEW in this case would be that a potential attacker is less likely to be considerate and attempt to modify through the VIEW (even if this is shown in the application, rather than direct access to the table), since if they&#8217;ve got access to be able to issue such a query, they almost certainly have sufficient access to show tables. By using a trigger, the attempt will still be caught however the attacker tries to change the table in question.</p>
<p>Unless, of course, you can enforce a VIEW as being the only way to access a particular table &#8211; I&#8217;ve not come across the idea, but my general use of views is for reading data.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-214</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Fri, 02 Jan 2009 12:39:26 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-214</guid>
					<description><![CDATA[Hi Roland,

#2.
I agree - the VIEW is a solution which does not resolve to a hack. It would be interesting to see how well it performs in comparison with triggers.

Regards,
Shlomi]]></description>
		<content:encoded><![CDATA[<p>Hi Roland,</p>
<p>#2.<br />
I agree &#8211; the VIEW is a solution which does not resolve to a hack. It would be interesting to see how well it performs in comparison with triggers.</p>
<p>Regards,<br />
Shlomi</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Roland Boumna				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-213</link>
		<dc:creator><![CDATA[Roland Boumna]]></dc:creator>
		<pubDate>Fri, 02 Jan 2009 11:35:45 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-213</guid>
					<description><![CDATA[Hi!

#1
&quot;my first attempt was with CURRENT_USER(). Guess what? It always gave out the trigger’s *definer*! &quot;

Ok - I stand corrected - you are right, the CURRENT_USER() function inside a trigger refers to the definer... (http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html) 

I must say - I am a bit shocked that it is not really possible to access the authenticated user in this particular case. It seems to me the USER() is next to worthless,  and you must take special precautions if you want to use it to find out who is really connected. At the very least, you should check if the data returned by USER() matches a real account. in the mysql.user table.

#2:
All good points. My main point is that enforcing a constraint like this without resorting to a hack is possible. Apparently it would not have been the ideal choice in your particular case. 

Regards,

Roland]]></description>
		<content:encoded><![CDATA[<p>Hi!</p>
<p>#1<br />
&#8220;my first attempt was with CURRENT_USER(). Guess what? It always gave out the trigger’s *definer*! &#8221;</p>
<p>Ok &#8211; I stand corrected &#8211; you are right, the CURRENT_USER() function inside a trigger refers to the definer&#8230; (<a href="http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html" rel="nofollow ugc">http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html</a>) </p>
<p>I must say &#8211; I am a bit shocked that it is not really possible to access the authenticated user in this particular case. It seems to me the USER() is next to worthless,  and you must take special precautions if you want to use it to find out who is really connected. At the very least, you should check if the data returned by USER() matches a real account. in the mysql.user table.</p>
<p>#2:<br />
All good points. My main point is that enforcing a constraint like this without resorting to a hack is possible. Apparently it would not have been the ideal choice in your particular case. </p>
<p>Regards,</p>
<p>Roland</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-212</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Fri, 02 Jan 2009 04:40:30 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-212</guid>
					<description><![CDATA[Hi Roland!

1. No, I&#039;m afraid I was right. Indeed, my first attempt was with CURRENT_USER(). Guess what? It always gave out the trigger&#039;s *definer*! I was surprised as well. Changing to USER() did in fact return the trigger&#039;s invoker.
This is actually a real solution implemented on production due to a hacking problem which constantly hacked the admin account. And the logs did actually help in finding out the source of error.

2. The lack of error raising is a given fact in MySQL&#039;s stored programs. Until this is resolved, we must settle with some ugly patch. 

I&#039;m pretty much sure some character should never be allowed in table names, even though they may actually be supported: take &quot;.&quot;, for example. It&#039;s such an elementary delimiter (table_schema.table_name.column_name) that it would be a very bad practice, in my opinion, to include it in table names using back ticks.

So what I&#039;m saying is paranoia must have its limits, though mathematically speaking it may be substantiated.

With regard to using a view such as the one you&#039;ve recommended: my personal inclination is not to use updatable views (and I agree it&#039;s a matter of taste). In this particular case I find the following issues:
- There must be an index-merge for this view to work well (because of the OR). I&#039;ve yet to rely on the success of inde-merge. Insofar, I have found it to be sporadic, not much reliable.
- The particular implementation I&#039;ve encountered has used Hibernate (the popular java persistence framework). I&#039;m pretty much certain it would be very difficult, if not impossible (though I never tried), to let Hibernate talk with this view when doing some operations, but use the actual table when proper SELECT ... JOIN queries are required.
- The trigger solution avoids changing the application code. I&#039;m not generally in favor of that, I usually prefer to keep program logic in the program, but in this case the module which handled the users registration was 3rd party, and rewriting it was more troublesome.

Regards,
Shlomi]]></description>
		<content:encoded><![CDATA[<p>Hi Roland!</p>
<p>1. No, I&#8217;m afraid I was right. Indeed, my first attempt was with CURRENT_USER(). Guess what? It always gave out the trigger&#8217;s *definer*! I was surprised as well. Changing to USER() did in fact return the trigger&#8217;s invoker.<br />
This is actually a real solution implemented on production due to a hacking problem which constantly hacked the admin account. And the logs did actually help in finding out the source of error.</p>
<p>2. The lack of error raising is a given fact in MySQL&#8217;s stored programs. Until this is resolved, we must settle with some ugly patch. </p>
<p>I&#8217;m pretty much sure some character should never be allowed in table names, even though they may actually be supported: take &#8220;.&#8221;, for example. It&#8217;s such an elementary delimiter (table_schema.table_name.column_name) that it would be a very bad practice, in my opinion, to include it in table names using back ticks.</p>
<p>So what I&#8217;m saying is paranoia must have its limits, though mathematically speaking it may be substantiated.</p>
<p>With regard to using a view such as the one you&#8217;ve recommended: my personal inclination is not to use updatable views (and I agree it&#8217;s a matter of taste). In this particular case I find the following issues:<br />
&#8211; There must be an index-merge for this view to work well (because of the OR). I&#8217;ve yet to rely on the success of inde-merge. Insofar, I have found it to be sporadic, not much reliable.<br />
&#8211; The particular implementation I&#8217;ve encountered has used Hibernate (the popular java persistence framework). I&#8217;m pretty much certain it would be very difficult, if not impossible (though I never tried), to let Hibernate talk with this view when doing some operations, but use the actual table when proper SELECT &#8230; JOIN queries are required.<br />
&#8211; The trigger solution avoids changing the application code. I&#8217;m not generally in favor of that, I usually prefer to keep program logic in the program, but in this case the module which handled the users registration was 3rd party, and rewriting it was more troublesome.</p>
<p>Regards,<br />
Shlomi</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Roland Boumna				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/using-triggers-to-block-malicious-code-an-example/comment-page-1#comment-211</link>
		<dc:creator><![CDATA[Roland Boumna]]></dc:creator>
		<pubDate>Thu, 01 Jan 2009 23:58:44 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=145#comment-211</guid>
					<description><![CDATA[Hi!

Nice post. 

Two things though ...

#1
There is an error in your code. The USER() function is probably *not* what you want in this case - you need the CURRENT_USER() function.

The USER() function returns the credentials provided by the client, and this may not be identical to the credentials that were used to authenticate the user. Crazy perhaps, but that is how it is...Of course the risk of USER is not that big if you assume the attacker did not gain a direct connection to your server, but CURRENT_USER will actually also shield you better from attacks on the inside.

#2
The trigger solution is nice, but unfortunately, you (and me, and legions before is)  have to bite it and accept the absence of a proper mechanism to raise a user-defined error. It may be paranoid, but what if somebody creates the table called `Cannot modify admin data!`?

Anyway, my point is that you could have solved it with a VIEW too, and depending on taste this could be a more clean solution. For example:

CREATE OR REPLACE 
SQL SECURITY DEFINER
VIEW v_my_users AS
SELECT * FROM my_users
WHERE  username != &#039;admin&#039;
   OR  CURRENT_USER() = &#039;root@localhost&#039;
WITH CHECK OPTION

this will not result in an error when the UPDATE is executed, so you must use the ROW_COUNT() function to check if the UPDATE succeeded or failed.

kind regards,

Roland]]></description>
		<content:encoded><![CDATA[<p>Hi!</p>
<p>Nice post. </p>
<p>Two things though &#8230;</p>
<p>#1<br />
There is an error in your code. The USER() function is probably *not* what you want in this case &#8211; you need the CURRENT_USER() function.</p>
<p>The USER() function returns the credentials provided by the client, and this may not be identical to the credentials that were used to authenticate the user. Crazy perhaps, but that is how it is&#8230;Of course the risk of USER is not that big if you assume the attacker did not gain a direct connection to your server, but CURRENT_USER will actually also shield you better from attacks on the inside.</p>
<p>#2<br />
The trigger solution is nice, but unfortunately, you (and me, and legions before is)  have to bite it and accept the absence of a proper mechanism to raise a user-defined error. It may be paranoid, but what if somebody creates the table called `Cannot modify admin data!`?</p>
<p>Anyway, my point is that you could have solved it with a VIEW too, and depending on taste this could be a more clean solution. For example:</p>
<p>CREATE OR REPLACE<br />
SQL SECURITY DEFINER<br />
VIEW v_my_users AS<br />
SELECT * FROM my_users<br />
WHERE  username != &#8216;admin&#8217;<br />
   OR  CURRENT_USER() = &#8216;root@localhost&#8217;<br />
WITH CHECK OPTION</p>
<p>this will not result in an error when the UPDATE is executed, so you must use the ROW_COUNT() function to check if the UPDATE succeeded or failed.</p>
<p>kind regards,</p>
<p>Roland</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

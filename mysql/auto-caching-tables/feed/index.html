<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	
	>
<channel>
	<title>
	Comments on: Auto caching tables	</title>
	<atom:link href="https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/feed" rel="self" type="application/rss+xml" />
	<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Thu, 08 Mar 2012 18:33:08 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
			<item>
				<title>
				By: Auto caching INFORMATION_SCHEMA tables: seeking input &#124; code.openark.org				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74914</link>
		<dc:creator><![CDATA[Auto caching INFORMATION_SCHEMA tables: seeking input &#124; code.openark.org]]></dc:creator>
		<pubDate>Thu, 08 Mar 2012 18:33:08 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74914</guid>
					<description><![CDATA[[...] Auto caching tables [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Auto caching tables [&#8230;]</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74328</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Wed, 07 Mar 2012 12:10:18 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74328</guid>
					<description><![CDATA[@Jannes,
Thanks

1. Yes, indeed.
2. True, though the above is merely a demo. You may wish to only invalidate specific rows
3. Yes and no. You can use &lt;a href=&quot;http://common-schema.googlecode.com/svn/trunk/common_schema/doc/html/this_query.html&quot; rel=&quot;nofollow&quot;&gt;this_query()&lt;/a&gt; to get the invocating query. If you&#039;re up to parsing it, well, it can be done.]]></description>
		<content:encoded><![CDATA[<p>@Jannes,<br />
Thanks</p>
<p>1. Yes, indeed.<br />
2. True, though the above is merely a demo. You may wish to only invalidate specific rows<br />
3. Yes and no. You can use <a href="http://common-schema.googlecode.com/svn/trunk/common_schema/doc/html/this_query.html" rel="nofollow">this_query()</a> to get the invocating query. If you&#8217;re up to parsing it, well, it can be done.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Jannes				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74284</link>
		<dc:creator><![CDATA[Jannes]]></dc:creator>
		<pubDate>Wed, 07 Mar 2012 09:46:59 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74284</guid>
					<description><![CDATA[Wow nice! I&#039;ve been trying to attack this problem from similar sides a few times as well, but hadn&#039;t made it fit together so nicely!

1) I guess you could let your function return a 1 in case the cache was just freshly revalidated? Or a timestamp of the last revalidation and then the client running the query could SELECT that field as well if it were interested in that information?

2)  A TRUNCATE would be faster than DELETE FROM cache_sample_data; right? (IF you want to delete everything). Of course you could have logic that allows you to update only what has changed since the previous revalidation.

3) I guess it&#039;s not possible to ONLY revalidate rows that the client is interested in (i.e. the rest of the WHERE clause in the client&#039;s query) ?

Anyway, congrats for pulling this off!]]></description>
		<content:encoded><![CDATA[<p>Wow nice! I&#8217;ve been trying to attack this problem from similar sides a few times as well, but hadn&#8217;t made it fit together so nicely!</p>
<p>1) I guess you could let your function return a 1 in case the cache was just freshly revalidated? Or a timestamp of the last revalidation and then the client running the query could SELECT that field as well if it were interested in that information?</p>
<p>2)  A TRUNCATE would be faster than DELETE FROM cache_sample_data; right? (IF you want to delete everything). Of course you could have logic that allows you to update only what has changed since the previous revalidation.</p>
<p>3) I guess it&#8217;s not possible to ONLY revalidate rows that the client is interested in (i.e. the rest of the WHERE clause in the client&#8217;s query) ?</p>
<p>Anyway, congrats for pulling this off!</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74130</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Tue, 06 Mar 2012 20:49:55 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74130</guid>
					<description><![CDATA[@Rick,
I&#039;m utterly not sold on &quot;The Query cache does an even better job of optimizing that case&quot;, for many reasons.
One being that the query cache results get invalidated so frequently, and by such innocent updates, that it quickly becomes useless. At least this is my experience.

I agree that the stored routine makes for an overhead. MySQL is very slow in interpreting stored routines.

The RAND is only used because it&#039;s simplest to demonstrate with, and easiest to follow. It does not make sense to use RAND for real. Thus, the &quot;10% of the time it will be even slower&quot; is irrelevant. It should be &quot;Once every #### times the query is even slower than it would without cache&quot;.]]></description>
		<content:encoded><![CDATA[<p>@Rick,<br />
I&#8217;m utterly not sold on &#8220;The Query cache does an even better job of optimizing that case&#8221;, for many reasons.<br />
One being that the query cache results get invalidated so frequently, and by such innocent updates, that it quickly becomes useless. At least this is my experience.</p>
<p>I agree that the stored routine makes for an overhead. MySQL is very slow in interpreting stored routines.</p>
<p>The RAND is only used because it&#8217;s simplest to demonstrate with, and easiest to follow. It does not make sense to use RAND for real. Thus, the &#8220;10% of the time it will be even slower&#8221; is irrelevant. It should be &#8220;Once every #### times the query is even slower than it would without cache&#8221;.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Rick James				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74124</link>
		<dc:creator><![CDATA[Rick James]]></dc:creator>
		<pubDate>Tue, 06 Mar 2012 20:41:13 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74124</guid>
					<description><![CDATA[As I see it (and using the RAND), 10% of the time it will be even slower than the underlying query.  If this is in a UI, the user will get unpredictable response time (not good).

OTOH, in a batch job, it would (could) cut down on overall system load and, on average, speed up the process.

If the RAND is replaced by some _cheap_ test for whether to refresh the cache, _and_ refreshing is costly, then &quot;you pay the price only when you need to&quot;. — this has applicability.  But that implies that the SELECT is happening more often than changes to the underlying table.  Guess what?  The Query cache does an even better job of optimizing that case.

If there is a WHERE clause on the user&#039;s query, that is not, and can not, be pushed down to the reload subquery.  If it could, that would open up more doors for optimizations.

Maybe I will find a use for this eventually.  It is quite clever!]]></description>
		<content:encoded><![CDATA[<p>As I see it (and using the RAND), 10% of the time it will be even slower than the underlying query.  If this is in a UI, the user will get unpredictable response time (not good).</p>
<p>OTOH, in a batch job, it would (could) cut down on overall system load and, on average, speed up the process.</p>
<p>If the RAND is replaced by some _cheap_ test for whether to refresh the cache, _and_ refreshing is costly, then &#8220;you pay the price only when you need to&#8221;. — this has applicability.  But that implies that the SELECT is happening more often than changes to the underlying table.  Guess what?  The Query cache does an even better job of optimizing that case.</p>
<p>If there is a WHERE clause on the user&#8217;s query, that is not, and can not, be pushed down to the reload subquery.  If it could, that would open up more doors for optimizations.</p>
<p>Maybe I will find a use for this eventually.  It is quite clever!</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Giuseppe Maxia				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74038</link>
		<dc:creator><![CDATA[Giuseppe Maxia]]></dc:creator>
		<pubDate>Tue, 06 Mar 2012 16:13:57 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74038</guid>
					<description><![CDATA[Congratulations on yet another great hack!]]></description>
		<content:encoded><![CDATA[<p>Congratulations on yet another great hack!</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: shlomi				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74013</link>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
		<pubDate>Tue, 06 Mar 2012 15:27:20 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74013</guid>
					<description><![CDATA[@Roland,
My next post will discuss INFORMATION_SCHEMA. I have this working, but am unsatisfied with a few issues.

@Jonathan,
Take time-based invalidation, which is commonly used, such with memcached. Data is valid for the next 5 minutes. Put the readtime somewhere.
It&#039;s simple, yet surprisingly useful, in my opinion.]]></description>
		<content:encoded><![CDATA[<p>@Roland,<br />
My next post will discuss INFORMATION_SCHEMA. I have this working, but am unsatisfied with a few issues.</p>
<p>@Jonathan,<br />
Take time-based invalidation, which is commonly used, such with memcached. Data is valid for the next 5 minutes. Put the readtime somewhere.<br />
It&#8217;s simple, yet surprisingly useful, in my opinion.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Jonathan Levin				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-74002</link>
		<dc:creator><![CDATA[Jonathan Levin]]></dc:creator>
		<pubDate>Tue, 06 Mar 2012 14:59:19 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-74002</guid>
					<description><![CDATA[Hi Sholmi,

I like the idea, but I have a bad feeling about it from past experiences.
A lot depends on the cache invalidation heuristic you pointed out. If it is inefficient, you just have a lot of IO overhead where it was not needed.

Can you recommend some good cache invalidation techniques to go with this idea?]]></description>
		<content:encoded><![CDATA[<p>Hi Sholmi,</p>
<p>I like the idea, but I have a bad feeling about it from past experiences.<br />
A lot depends on the cache invalidation heuristic you pointed out. If it is inefficient, you just have a lot of IO overhead where it was not needed.</p>
<p>Can you recommend some good cache invalidation techniques to go with this idea?</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Roland Bouman				</title>
				<link>https://shlomi-noach.github.io/blog/mysql/auto-caching-tables/comment-page-1#comment-73997</link>
		<dc:creator><![CDATA[Roland Bouman]]></dc:creator>
		<pubDate>Tue, 06 Mar 2012 14:39:02 +0000</pubDate>
		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4353#comment-73997</guid>
					<description><![CDATA[Hi Shlomi! 

Brilliant solution :) 

There&#039;s a lot of moving parts but I think this is going to be worth it if we can get better information_schema performance and reliability with this.]]></description>
		<content:encoded><![CDATA[<p>Hi Shlomi! </p>
<p>Brilliant solution 🙂 </p>
<p>There&#8217;s a lot of moving parts but I think this is going to be worth it if we can get better information_schema performance and reliability with this.</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

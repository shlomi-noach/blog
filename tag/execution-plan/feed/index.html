<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	>

<channel>
	<title>Execution plan &#8211; code.openark.org</title>
	<atom:link href="https://shlomi-noach.github.io/blog/tag/execution-plan/feed" rel="self" type="application/rss+xml" />
	<link>http://shlomi-noach.github.io/blog/</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Mon, 10 Oct 2011 05:48:10 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
<site xmlns="com-wordpress:feed-additions:1">32412571</site>	<item>
		<title>Speaking on Percona Live, London: &#8220;Programmatic Queries: things you can code with SQL&#8221;</title>
		<link>https://shlomi-noach.github.io/blog/mysql/speaking-on-percona-live-london-programmatic-queries-things-you-can-code-with-sql</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/speaking-on-percona-live-london-programmatic-queries-things-you-can-code-with-sql#comments</comments>
				<pubDate>Mon, 10 Oct 2011 05:48:10 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[Speaking]]></category>
		<category><![CDATA[SQL]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=4043</guid>
				<description><![CDATA[I&#8217;ll be speaking at the Percona Live event, held in London, October 24, 25, 2011. My session is called Programmatic Queries: things you can code with SQL. It&#8217;s a short 30 minute talk, in which I present underlying knowledge of the programmatic nature of SQL queries within MySQL, and how to take advantage of such [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I&#8217;ll be speaking at the <a href="http://www.percona.com/live/london-2011/">Percona Live</a> event, held in London, October <strong>24, 25, 2011</strong>.</p>
<p>My session is called <a href="http://www.percona.com/live/london-2011/session/programmatic-queries-things-you-can-code-with-sql/">Programmatic Queries: things you can code with SQL</a>. It&#8217;s a short <strong>30</strong> minute talk, in which I present underlying knowledge of the programmatic nature of SQL queries within MySQL, and how to take advantage of such knowledge so as to build faster, shorter, and sometimes unexpected queries.</p>
<p>This is <em>not</em> about stored routine programming, a classic programmatic aspect of MySQL, but rather about expected order of execution: of row evaluation, of control flow statements, of table inference, of time issues.</p>
<p>I have far too many examples, some real-world problem solvers, and some less common in daily use, to be able to deliver them all on this session. I will pick up those which seem most interesting to me, or those best presenting the programmatic nature of the query. As time allows I may add more examples, or look into interesting future possibilities.</p>
<p>I hope to see you there.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/speaking-on-percona-live-london-programmatic-queries-things-you-can-code-with-sql/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">4043</post-id>	</item>
		<item>
		<title>Views: better performance with condition pushdown</title>
		<link>https://shlomi-noach.github.io/blog/mysql/views-better-performance-with-condition-pushdown</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/views-better-performance-with-condition-pushdown#comments</comments>
				<pubDate>Thu, 20 May 2010 05:17:05 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[Performance]]></category>
		<category><![CDATA[SQL]]></category>
		<category><![CDATA[Stored routines]]></category>
		<category><![CDATA[Syntax]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1328</guid>
				<description><![CDATA[Justin&#8217;s A workaround for the performance problems of TEMPTABLE views post on mysqlperformanceblog.com reminded me of a solution I once saw on a customer&#8217;s site. The customer was using nested views structure, up to depth of some 8-9 views. There were a lot of aggregations along the way, and even the simplest query resulted with [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Justin&#8217;s <a href="http://www.mysqlperformanceblog.com/2010/05/19/a-workaround-for-the-performance-problems-of-temptable-views/">A workaround for the performance problems of TEMPTABLE views</a> post on <a href="http://www.mysqlperformanceblog.com/">mysqlperformanceblog.com</a> reminded me of a solution I once saw on a customer&#8217;s site.</p>
<p>The customer was using nested views structure, up to depth of some 8-9 views. There were a lot of aggregations along the way, and even the simplest query resulted with a LOT of subqueries, temporary tables, and vast amounts of data, even if only to return with a couple of rows.</p>
<p>While we worked to solve this, a developer showed me his own trick. His trick is now impossible to implement, but there&#8217;s a hack around this.</p>
<p>Let&#8217;s use the world database to illustrate. Look at the following view definition:<span id="more-1328"></span></p>
<blockquote>
<pre class="brush: sql; title: ; notranslate">
CREATE
  ALGORITHM=TEMPTABLE
VIEW country_languages AS
  SELECT
    Country.CODE, Country.Name AS country,
    GROUP_CONCAT(CountryLanguage.Language) AS languages
  FROM
    world.Country
    JOIN world.CountryLanguage ON (Country.CODE = CountryLanguage.CountryCode)
  GROUP BY
    Country.CODE;
</pre>
</blockquote>
<p>The view presents with a list of spoken languages per country. The execution plan for querying this view looks like this:</p>
<blockquote>
<pre>mysql&gt; EXPLAIN SELECT * FROM country_languages;
+----+-------------+-----------------+--------+---------------+---------+---------+-----------------------------------+------+----------------------------------------------+
| id | select_type | table           | type   | possible_keys | key     | key_len | ref                               | rows | Extra                                        |
+----+-------------+-----------------+--------+---------------+---------+---------+-----------------------------------+------+----------------------------------------------+
|  1 | PRIMARY     | &lt;derived2&gt;      | ALL    | NULL          | NULL    | NULL    | NULL                              |  233 |                                              |
|  2 | DERIVED     | CountryLanguage | index  | PRIMARY       | PRIMARY | 33      | NULL                              |  984 | Using index; Using temporary; Using filesort |
|  2 | DERIVED     | Country         | eq_ref | PRIMARY       | PRIMARY | 3       | world.CountryLanguage.CountryCode |    1 |                                              |
+----+-------------+-----------------+--------+---------------+---------+---------+-----------------------------------+------+----------------------------------------------+
</pre>
</blockquote>
<p>And, even if we only want to filter out a single country, we still get the same plan:</p>
<blockquote>
<pre>mysql&gt; EXPLAIN SELECT * FROM country_languages WHERE Code='USA';
+----+-------------+-----------------+--------+---------------+---------+---------+-----------------------------------+------+----------------------------------------------+
| id | select_type | table           | type   | possible_keys | key     | key_len | ref                               | rows | Extra                                        |
+----+-------------+-----------------+--------+---------------+---------+---------+-----------------------------------+------+----------------------------------------------+
|  1 | PRIMARY     | &lt;derived2&gt;      | ALL    | NULL          | NULL    | NULL    | NULL                              |  233 | Using where                                  |
|  2 | DERIVED     | CountryLanguage | index  | PRIMARY       | PRIMARY | 33      | NULL                              |  984 | Using index; Using temporary; Using filesort |
|  2 | DERIVED     | Country         | eq_ref | PRIMARY       | PRIMARY | 3       | world.CountryLanguage.CountryCode |    1 |                                              |
+----+-------------+-----------------+--------+---------------+---------+---------+-----------------------------------+------+----------------------------------------------+
</pre>
</blockquote>
<p>So, we need to scan the entire country_language and country tables in order to return results for just one row.</p>
<h4>A non-working solution</h4>
<p>The solution offered by the developer was this:</p>
<blockquote>
<pre class="brush: sql; title: ; notranslate">
CREATE
  ALGORITHM=MERGE
  VIEW country_languages_non_working AS
  SELECT
    Country.CODE, Country.Name AS country,
    GROUP_CONCAT(CountryLanguage.Language) AS languages
  FROM
    world.Country
    JOIN world.CountryLanguage ON
      (Country.CODE = CountryLanguage.CountryCode)
  WHERE
    Country.CODE = @country_code
  GROUP BY Country.CODE;
</pre>
</blockquote>
<p>And follow by:</p>
<blockquote>
<pre>mysql&gt; SET @country_code='USA';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM country_languages_2;
+------+---------------+----------------------------------------------------------------------------------------------------+
| CODE | country       | languages                                                                                          |
+------+---------------+----------------------------------------------------------------------------------------------------+
| USA  | United States | Chinese,English,French,German,Italian,Japanese,Korean,Polish,Portuguese,Spanish,Tagalog,Vietnamese |
+------+---------------+----------------------------------------------------------------------------------------------------+
</pre>
</blockquote>
<p>So, pushdown a <strong>WHERE</strong> condition into the view&#8217;s definition. The session variable @country_code is used to filter rows. In the above simplified code the value is assumed to be set; tweak it as you see fit (using <strong>IFNULL</strong>, for example, or <strong>OR</strong> statements) to allow for full scan in case the variable is undefined.</p>
<p>This doesn&#8217;t work. It used to work a couple years back; but today you cannot create a view which uses session variables or parameters. It is a restriction imposed by views.</p>
<h4>A workaround</h4>
<p>Justin showed a workaround using an additional table. There is another workaround which does not involve tables, but rather stored routines. Now, this is a patch, and an ugly one. It may not work in future versions of MySQL for all I know. But, here it goes:</p>
<blockquote>
<pre class="brush: sql; title: ; notranslate">
DELIMITER $$
CREATE DEFINER=`root`@`localhost` FUNCTION `get_session_country`() RETURNS CHAR(3)
    NO SQL
    DETERMINISTIC
BEGIN
  RETURN @country_code;
END $$
DELIMITER ;

CREATE
  ALGORITHM=MERGE
  VIEW country_languages_2 AS
  SELECT
    Country.CODE, Country.Name AS country,
    GROUP_CONCAT(CountryLanguage.Language) AS languages
  FROM
    world.Country
    JOIN world.CountryLanguage ON
      (Country.CODE = CountryLanguage.CountryCode)
  WHERE
    Country.CODE = get_session_country()
  GROUP BY Country.CODE;
</pre>
</blockquote>
<p>And now:</p>
<blockquote>
<pre>mysql&gt; SET @country_code='USA';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM country_languages_2;
+------+---------------+----------------------------------------------------------------------------------------------------+
| CODE | country       | languages                                                                                          |
+------+---------------+----------------------------------------------------------------------------------------------------+
| USA  | United States | Chinese,English,French,German,Italian,Japanese,Korean,Polish,Portuguese,Spanish,Tagalog,Vietnamese |
+------+---------------+----------------------------------------------------------------------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; EXPLAIN SELECT * FROM country_languages_2;
+----+-------------+-----------------+--------+---------------+---------+---------+------+------+--------------------------+
| id | select_type | table           | type   | possible_keys | key     | key_len | ref  | rows | Extra                    |
+----+-------------+-----------------+--------+---------------+---------+---------+------+------+--------------------------+
|  1 | PRIMARY     | &lt;derived2&gt;      | system | NULL          | NULL    | NULL    | NULL |    1 |                          |
|  2 | DERIVED     | Country         | const  | PRIMARY       | PRIMARY | 3       |      |    1 |                          |
|  2 | DERIVED     | CountryLanguage | ref    | PRIMARY       | PRIMARY | 3       |      |    8 | Using where; Using index |
+----+-------------+-----------------+--------+---------------+---------+---------+------+------+--------------------------+
</pre>
</blockquote>
<p>Since views are allowed to call stored routines (Justing used this to call upon <strong>CONNECTION_ID()</strong>), and since stored routines can use session variables, we can take advantage and force the view into filtering out irrelevant rows before these accumulate to temporary tables and big joins.</p>
<p>Back in the customer&#8217;s office, we witnessed, what with their real data and multiple views, a reduction of query times from ~30 minutes to a few seconds.</p>
<h4>Another kind of use</h4>
<p>Eventually we worked to make better view definitions and query splitting, resulting in clearer code and fast queries, but this solution plays nicely into another kind of problem:</p>
<p>Can we force different customers to see different parts of a given table? e.g., only those rows that relate to the customers?</p>
<p>There can be many solutions: different tables; multiple views (one per customer), stored procedures, what have you. The above provides a solution, and I&#8217;ve seen it in use.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/views-better-performance-with-condition-pushdown/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">1328</post-id>	</item>
		<item>
		<title>EXPLAIN: missing db info</title>
		<link>https://shlomi-noach.github.io/blog/mysql/explain-missing-db-info</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/explain-missing-db-info#comments</comments>
				<pubDate>Tue, 11 May 2010 04:57:02 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Analysis]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[logs]]></category>
		<category><![CDATA[openark kit]]></category>
		<category><![CDATA[scripts]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=2368</guid>
				<description><![CDATA[I&#8217;m further developing a general log hook, which can stream queries from the general log. A particular direction I&#8217;m taking is to filter queries by their type of actions. For example, the tool (oak-hook-general-log) can be instructed to only stream out those queries which involve creation of a temporary table; or those which cause for [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I&#8217;m further developing a general log hook, which can stream queries from the general log.</p>
<p>A particular direction I&#8217;m taking is to filter queries by their type of actions. For example, the tool (<a href="http://code.google.com/p/openarkkit/source/browse/trunk/openarkkit/src/oak/oak-hook-general-log.py">oak-hook-general-log</a>) can be instructed to only stream out those queries which involve creation of a temporary table; or those which cause for a filesort, or full index scan, etc.</p>
<p>This is done by evaluating of query execution plans on the fly. I suspect the <a href="http://www.mysql.com/why-mysql/white-papers/mysql_wp_queryanalyzer.php">MySQL query analyzer</a> roughly does the same (as a small part of what it does).</p>
<p>It&#8217;s almost nothing one cannot do with sed/awk. However, I bumped into a couple of problems:</p>
<ol>
<li>The general log (and the <strong>mysql.general_log table</strong>, in  particular) does not indicate the particular database one is using for the query. Since slow log does indicate this data, I <a href="http://bugs.mysql.com/bug.php?id=52554">filed a bug</a> on this. I currently solve this by crossing connection id with the process list, where the current database is listed. It&#8217;s shaky, but mostly works.</li>
<li>Just realized: there&#8217;s no DB info in the <strong>EXPLAIN</strong> output! It&#8217;s weird, since I&#8217;ve been EXPLAINing queries for years now. But I&#8217;ve always had the advantage of <em>knowing</em> the schema used: either because I was manually executing the query on a known schema, or <a href="http://www.maatkit.org/doc/mk-query-digest.html">mk-query-digest</a> was kind enough to let me know.</li>
</ol>
<p><span id="more-2368"></span>For example, look at the following imaginary query, involving both the <strong>world</strong> and <strong>sakila</strong> databases:</p>
<blockquote>
<pre>mysql&gt; use test;
Database changed
mysql&gt; EXPLAIN SELECT * FROM world.Country JOIN sakila.city WHERE Country.Capital = city.city_id;
+----+-------------+---------+--------+---------------+---------+---------+-----------------------+------+-------------+
| id | select_type | table   | type   | possible_keys | key     | key_len | ref                   | rows | Extra       |
+----+-------------+---------+--------+---------------+---------+---------+-----------------------+------+-------------+
|  1 | SIMPLE      | Country | ALL    | NULL          | NULL    | NULL    | NULL                  |  239 |             |
|  1 | SIMPLE      | city    | eq_ref | PRIMARY       | PRIMARY | 2       | world.Country.Capital |    1 | Using where |
+----+-------------+---------+--------+---------------+---------+---------+-----------------------+------+-------------+
2 rows in set (0.00 sec)
</pre>
</blockquote>
<p>The query is imaginary, since the tables don&#8217;t actually have anything in common. But look at the <strong>EXPLAIN</strong> result: can you tell where <strong>city</strong> came from? <strong>Country</strong> can somehow be parsed from the <strong>ref</strong> column, but no help on <strong>city</strong>.</p>
<p>Moreover, table aliases show on the <strong>EXPLAIN</strong> plan (which is good), but with no reference to the original table.</p>
<p>So, is it back to parsing of the SQL query? I&#8217;m <span style="text-decoration: line-through;">lazy</span> reluctant to do that. It&#8217;s error prone, and one needs to implement, or use, a good parser, which also accepts MySQL dialect. Haven&#8217;t looked into this yet.</p>
<p>I&#8217;m currently at a standstill with regard to automated query execution plan evaluation where database cannot be determined.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/explain-missing-db-info/feed</wfw:commentRss>
		<slash:comments>13</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">2368</post-id>	</item>
		<item>
		<title>Things to monitor on MySQL, the user&#8217;s perspective</title>
		<link>https://shlomi-noach.github.io/blog/mysql/things-to-monitor-on-mysql-the-users-perspective</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/things-to-monitor-on-mysql-the-users-perspective#comments</comments>
				<pubDate>Wed, 10 Mar 2010 09:12:24 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[Monitoring]]></category>
		<category><![CDATA[mycheckpoint]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=2008</guid>
				<description><![CDATA[Working on mycheckpoint, I have the intention of adding custom monitoring. That is, letting the user define things to monitor. I have my own thoughts, I would be grateful to get more input! What would the user want to monitor? Monitoring for the number of SELECT statements per second, InnoDB locks, slave replication lag etc. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Working on <em>mycheckpoint</em>, I have the intention of adding custom monitoring. That is, letting the user define things to monitor. I have my own thoughts, I would be grateful to get more input!</p>
<h4>What would the user want to monitor?</h4>
<p>Monitoring for the number of SELECT statements per second, InnoDB locks, slave replication lag etc. is very important, and monitoring utilities provide with this information. But what does that tell the end user? Not much.</p>
<p>The experienced DBA may gain a lot. The user would be more interested in completely other kind of information. In between, some information is relevant to both.</p>
<p>Say we were managing an on-line store. We want to monitor the health of the database. But the health of the database is inseparable from the health of the application. I mean, having little to no disk usage is fine, unless&#8230; something is wrong with the application, which leads to no new purchases.</p>
<p>And so a user would be interested in monitoring the number of purchases per hour, or the time passed since last successful purchase. This kind of data can only be generated by a user&#8217;s specific query. Looking at the charts, the user would then feel safer and confident in the wellness of his store app.</p>
<p><span id="more-2008"></span>But let&#8217;s dig further. We want the store&#8217;s website to provide with good response. In particular, the query which returns the items in a customer&#8217;s cart must react quickly. Our user would not only want to see that purchases get along, but also that page load times (as in our example) are quick for those critical parts. And so a user should be able to monitor the <em>time</em> it took to execute a given query.</p>
<p>It can be of further interest to know how many times per second a given query is executed. This part is not easily done on the server side, and requires the user&#8217;s cooperation (or else we must analyze the general log, sniff, or set up a proxy). If the user is willing, she can log to some table each time she executes a certain query. Then we&#8217;re back to monitoring a regular table, as with the first example.</p>
<p>It is also possible to monitor for a query&#8217;s execution plan. Is it full scan? How many rows are expected? But given that we can monitor the time it took to execute a query, I&#8217;m not sure this is useful. If everything runs fast enough &#8212; who cares about <em>how</em> it executes?</p>
<p>Some of the above can be monitored on an altogether higher level: if  we&#8217;re talking about some web application, then we can use our Apache logs to determine load time for pages, or number of requests to our &#8220;cart items&#8221; page. But not always do we work with web servers, and we may be interested in checking the specific queries behind the scenes.</p>
<h4>Summary</h4>
<p>Custom monitoring can include:</p>
<ul>
<li>User defined queries (number of concurrent visitors; count of successful operations per second; number of rows per given table or condition; &#8230;)</li>
<li>Execution time for user defined queries (time it takes to return cart items; find rows matching condition; sort a table; &#8230;)</li>
<li>Number of executions for a given query, per second.</li>
</ul>
<p>I intend to incorporate the above into <em>mycheckpoint</em> as part of its standard monitoring scheme.</p>
<p>Please share your thought below.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/things-to-monitor-on-mysql-the-users-perspective/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">2008</post-id>	</item>
		<item>
		<title>SQL: Ranking without self join</title>
		<link>https://shlomi-noach.github.io/blog/mysql/sql-ranking-without-self-join</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/sql-ranking-without-self-join#comments</comments>
				<pubDate>Mon, 14 Sep 2009 16:16:11 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[SQL]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=1293</guid>
				<description><![CDATA[The common way of solving the classic SQL problem of ranking, involves a  self join. I wish to present a different solution, which only iterates the table once, and provides the same output. The ranking problem Given a table with names and scores (e.g. students exams scores), add rank for each row, such that the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>The common way of solving the classic SQL problem of ranking, involves a  self join. I wish to present a different solution, which only iterates the table once, and provides the same output.</p>
<h4>The ranking problem</h4>
<p>Given a table with names and scores (e.g. students exams scores), add rank for each row, such that the rank identifies her position among other rows. Rows with identical scores should receive the same rank (e.g. both contenders got the silver medal).</p>
<p>Consider the following table (download <a href="https://shlomi-noach.github.io/blog/wp-content/uploads/2009/09/score.sql">score.sql</a>):</p>
<blockquote>
<pre>mysql&gt; select * from score;
+----------+--------------+-------+
| score_id | student_name | score |
+----------+--------------+-------+
|        1 | Wallace      |    95 |
|        2 | Gromit       |    97 |
|        3 | Shaun        |    85 |
|        4 | McGraw       |    92 |
|        5 | Preston      |    92 |
+----------+--------------+-------+
5 rows in set (0.00 sec)</pre>
</blockquote>
<p>We wish to present ranks in some way similar to:</p>
<blockquote>
<pre>+----------+--------------+-------+------+
| score_id | student_name | score | rank |
+----------+--------------+-------+------+
|        2 | Gromit       |    97 |    1 |
|        1 | Wallace      |    95 |    2 |
|        4 | McGraw       |    92 |    3 |
|        5 | Preston      |    92 |    3 |
|        3 | Shaun        |    85 |    4 |
+----------+--------------+-------+------+</pre>
</blockquote>
<p><span id="more-1293"></span>Note that McGraw and Preston got same scores, therefore both share 3rd rank, whereas Shaun gets ranked #4.</p>
<h4>The common solution</h4>
<p>Following is the SQL for the common solution:</p>
<blockquote>
<pre>SELECT
  s1.score_id, s1.student_name, s1.score, COUNT(DISTINCT s2.score) AS rank
FROM
  score s1 JOIN score s2 ON (s1.score &lt;= s2.score)
GROUP BY s1.score_id
;
+----------+--------------+-------+------+
| score_id | student_name | score | rank |
+----------+--------------+-------+------+
|        1 | Wallace      |    95 |    2 |
|        2 | Gromit       |    97 |    1 |
|        3 | Shaun        |    85 |    4 |
|        4 | McGraw       |    92 |    3 |
|        5 | Preston      |    92 |    3 |
+----------+--------------+-------+------+</pre>
</blockquote>
<p>(The above can by ORDERed at will, more on this later)</p>
<p>What I&#8217;m suggesting is that this self join is an overkill. It recalculates over and over what we knew a second before: to get the Preston&#8217;s rank, we need to count how many students got score &gt;=92. But when we need to find Shaun&#8217;s rank, we re-iterate these, and in addition count those with grades 85..91. We&#8217;re reading, re-reading, then re-re-reading (you get the point) the same data all over again. It&#8217;s a waste of energy.</p>
<h4>Offering a new solution</h4>
<p>I propose a simpler solution: do a one-time sorting of rows according to score (descending). The first row in the sorted set should obviously get the score &#8220;1&#8221;. Now we iterate the rows one by one, and keep a <em>rank</em> variable. Whenever the score remains the same, we just keep on iterating. Whenever the score changes (it can only change in the direction of &#8220;downwards&#8221;, since we sorted by score. descending), we increment the rank.</p>
<p>Actually, the above explanation makes it sound as if we do this with multiple steps. This is not so. We do this all in one step:</p>
<blockquote>
<pre>SELECT
  score_id, student_name, score,
  @prev := @curr,
  @curr := score,
  @rank := IF(@prev = @curr, @rank, @rank+1) AS rank
FROM
  score,
  (SELECT @curr := null, @prev := null, @rank := 0) sel1
ORDER BY score DESC
;
+----------+--------------+-------+----------------+----------------+------+
| score_id | student_name | score | @prev := @curr | @curr := score | rank |
+----------+--------------+-------+----------------+----------------+------+
|        2 | Gromit       |    97 |           NULL |             97 |    1 |
|        1 | Wallace      |    95 |             97 |             95 |    2 |
|        4 | McGraw       |    92 |             95 |             92 |    3 |
|        5 | Preston      |    92 |             92 |             92 |    3 |
|        3 | Shaun        |    85 |             92 |             85 |    4 |
+----------+--------------+-------+----------------+----------------+------+</pre>
</blockquote>
<h4>Execution plan comparison</h4>
<p>Do we have an index on the <strong>score</strong> column?</p>
<p>If not, I clearly win. The self join (when there&#8217;s more than mere 5 rows, of course) will make for repeated full table scans, thereby making for O(n²).</p>
<blockquote>
<pre>+----+-------------+-------+------+---------------+------+---------+------+------+---------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                           |
+----+-------------+-------+------+---------------+------+---------+------+------+---------------------------------+
|  1 | SIMPLE      | s1    | ALL  | NULL          | NULL | NULL    | NULL |    5 | Using temporary; Using filesort |
|  1 | SIMPLE      | s2    | ALL  | NULL          | NULL | NULL    | NULL |    5 | Using where                     |
+----+-------------+-------+------+---------------+------+---------+------+------+---------------------------------+</pre>
</blockquote>
<p>Whereas the suggested solution requires one filesort. This still means table data can be re-read, but significantly less so: it only takes O(n*log(n)), where the log(n) part is usually very small (and it all depend on <em>sort_buffer_size</em>).</p>
<blockquote>
<pre>+----+-------------+------------+--------+---------------+------+---------+------+------+----------------+
| id | select_type | table      | type   | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+------------+--------+---------------+------+---------+------+------+----------------+
|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL | NULL    | NULL |    1 | Using filesort |
|  1 | PRIMARY     | score      | ALL    | NULL          | NULL | NULL    | NULL |    5 |                |
|  2 | DERIVED     | NULL       | NULL   | NULL          | NULL | NULL    | NULL | NULL | No tables used |
+----+-------------+------------+--------+---------------+------+---------+------+------+----------------+</pre>
</blockquote>
<p>Testing on the somewhat larger <em><a href="http://dev.mysql.com/doc/sakila/en/sakila.html">sakila</a>.film</em> table (1000 rows is all) on my laptop, it takes 47 seconds for the common query to complete, 0.01 seconds to presented solution (repeatedly, no cache issues).</p>
<p>What happens when we do have an index? Again, I win. Testing on <em>sakila.film</em> now, having added an index on <strong>location</strong> column:</p>
<blockquote>
<pre>+----+-------------+-------+-------+---------------+--------+---------+------+------+----------------------------------------------+
| id | select_type | table | type  | possible_keys | key    | key_len | ref  | rows | Extra                                        |
+----+-------------+-------+-------+---------------+--------+---------+------+------+----------------------------------------------+
|  1 | SIMPLE      | s2    | index | length        | length | 3       | NULL | 1140 | Using index; Using temporary; Using filesort |
|  1 | SIMPLE      | s1    | ALL   | length        | NULL   | NULL    | NULL | 1140 | Using where                                  |
+----+-------------+-------+-------+---------------+--------+---------+------+------+----------------------------------------------+</pre>
</blockquote>
<p>The above still needs to do index scan. The <strong>GROUP BY</strong> requires either sorting or utilizing the <strong>PRIMARY KEY</strong>, and the execution plan with reversed tables ordering does not improve.</p>
<p>Presented solution utilized index for a single pass, with O(n) complexity:</p>
<blockquote>
<pre>+----+-------------+------------+--------+---------------+--------+---------+------+------+----------------+
| id | select_type | table      | type   | possible_keys | key    | key_len | ref  | rows | Extra          |
+----+-------------+------------+--------+---------------+--------+---------+------+------+----------------+
|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL   | NULL    | NULL |    1 |                |
|  1 | PRIMARY     | film       | index  | NULL          | length | 3       | NULL | 1140 |                |
|  2 | DERIVED     | NULL       | NULL   | NULL          | NULL   | NULL    | NULL | NULL | No tables used |
+----+-------------+------------+--------+---------------+--------+---------+------+------+----------------+</pre>
</blockquote>
<p>This is done with a single index pass. Again, on my laptop, I get ~41 seconds for 1st query, 0.01 seconds for the proposed solution.</p>
<p>I also argue that in addition, the results would often be required by order of rank, in which case the common solution must eventually sort anyhow.</p>
<h4>Conclusion</h4>
<p>To be honest, I&#8217;ve seen the self-join solution in so many places: textbooks, training material, online tutorials&#8230; Maybe it&#8217;s just a silly exercise, perhaps not your daily real-world task; but it&#8217;s one of those classic SQL problems. The so-often-repeated common solution is ANSI SQL, for sure, but at what cost?</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/sql-ranking-without-self-join/feed</wfw:commentRss>
		<slash:comments>35</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">1293</post-id>	</item>
		<item>
		<title>7 ways to convince MySQL to use the right index</title>
		<link>https://shlomi-noach.github.io/blog/mysql/7-ways-to-convince-mysql-to-use-the-right-index</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/7-ways-to-convince-mysql-to-use-the-right-index#comments</comments>
				<pubDate>Thu, 02 Apr 2009 16:06:32 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Books]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[Indexing]]></category>
		<category><![CDATA[SQL]]></category>
		<category><![CDATA[Syntax]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=695</guid>
				<description><![CDATA[Sometimes MySQL gets it wrong. It doesn&#8217;t use the right index. It happens that MySQL generates a query plan which is really bad (EXPLAIN says it&#8217;s going to explore some 10,000,000 rows), when another plan (soon to show how was generated) says: &#8220;Sure, I can do that with 100 rows using a key&#8221;. A true [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Sometimes MySQL gets it wrong. It doesn&#8217;t use the right index.</p>
<p>It happens that MySQL generates a query plan which is really bad (EXPLAIN says it&#8217;s going to explore some 10,000,000 rows), when another plan (soon to show how was generated) says: &#8220;Sure, I can do that with 100 rows using a key&#8221;.</p>
<h4>A true story</h4>
<p>A customer had issues with his database. Queries were taking 15 minutes to complete, and the db in general was not responsive. Looking at the slow query log, I found the criminal query. Allow me to bring you up to speed:</p>
<p>A table is defined like this:</p>
<blockquote>
<pre>CREATE TABLE t (
  id INT UNSIGNED AUTO_INCREMENT,
  type INT UNSIGNED,
  level TINYINT unsigned,
  ...
  PRIMARY KEY(id),
  KEY `type` (type)
) ENGINE=InnoDB;</pre>
</blockquote>
<p>The offending query was this:</p>
<blockquote>
<pre>SELECT id FROM data
WHERE type=12345 AND level &gt; 3
ORDER BY id</pre>
</blockquote>
<p>The facts were:</p>
<ul>
<li>`t` has about 10,000,000 rows.</li>
<li>The index on `type` is selective: about 100 rows per value on average.</li>
<li>The query took a long time to complete.</li>
<li>EXPLAIN has shown that MySQL uses the PRIMARY KEY, hence searches 10,000,000 rows, filtered &#8220;using where&#8221;.</li>
<li>The <em>other</em> EXPLAIN has shown that by using the `type` key, only 110 rows are expected, to be filtered &#8220;using where&#8221;, then sorted &#8220;using filesort&#8221;</li>
</ul>
<p>So MySQL acknowledged it was generating the wrong plan. The <em>other</em> plan was better by its own standards.</p>
<h4>Solving the problem</h4>
<p>Let&#8217;s walk through 7 ways to solve the problem, starting with the more aggressive solutions, refining to achieve desired behavior through subtle changes.<span id="more-695"></span></p>
<h4>Solution #1: OPTIMIZE</h4>
<p>If MySQL got it wrong, it may be because the table was frequently changed. This affects the statistics. If we can spare the time (table is locked during that time), we could help out by rebuilding the table.</p>
<h4>Solution #2: ANALYZE</h4>
<p>ANALYZE TABLE is less time consuming, in particular on InnoDB, where it is barely noticed. An ANALYZE will update the index statistics and help out in generating better query plans.</p>
<p>But hold on, the above two solutions are fine, but in the given case, MySQL <em>already</em> acknowledges better plans are at hand. The fact was I tried to run ANALYZE a few times, to no avail.</p>
<h4>Solution #3: USE INDEX</h4>
<p>Since the issue was urgent, my first thought went for the ultimate weapon:</p>
<blockquote>
<pre>SELECT id FROM data USE INDEX(type)
WHERE type=12345 AND level &gt; 3
ORDER BY id</pre>
</blockquote>
<p>This instructs MySQL to only consider the indexes listed; in our example, I only want MySQL to consider using the `type` index. It is using this method that generated the <em>other</em> (good) EXPLAIN result. I could have gone even more ruthless and ask for FORCE INDEX.</p>
<h4>Solution #4: IGNORE INDEX</h4>
<p>A similar approach would be to explicitly negate the use of the PRIMARY KEY, like this:</p>
<blockquote>
<pre>SELECT id FROM data IGNORE INDEX(PRIMARY)
WHERE type=12345 AND level &gt; 3
ORDER BY id</pre>
</blockquote>
<h4>A moment of thinking</h4>
<p>The above solutions are &#8220;ugly&#8221;, in the sense that this is not standard SQL. It&#8217;s too MySQL specific.</p>
<p>I&#8217;ve asked the programmers to do a quick rewrite, and had a few moments to consider: why did MySQL insist on using the PRIMARY KEY. Was it because I&#8217;ve asked it for the `id` column only? I rewrote as follows:</p>
<blockquote>
<pre>SELECT id, type, level FROM data
WHERE type=12345 AND level &gt; 3
ORDER BY id</pre>
</blockquote>
<p>Nope. EXPLAIN got me the same bad plan. Then it must be the ORDER BY clause:</p>
<blockquote>
<pre>SELECT id FROM data
WHERE type=12345 AND level &gt; 3</pre>
</blockquote>
<p>Sure enough, EXPLAIN now  indicates using the `type` index, only reading 110 rows. So MySQL preferred to scan 10,000,000 rows, just so that the rows are generated in the right ORDER, and so no sorting is required, when it could have read 110 rows (where each row is a mere INT) and sort them in no time.</p>
<p>Armed with this knowledge, a few more options come at hand.</p>
<h4>Solution #5:Move some logic to the application</h4>
<p>At about that point I got a message that the programmers were unable to add the USE INDEX part. Why? They were using the EJB framework, which limits your SQL-like queries to something very generic. Well, you can always drop the ORDER BY part and sort on the application side. That isn&#8217;t fun, but it&#8217;s been done.</p>
<h4>Solution #6: Negate use of PRIMARY KEY</h4>
<p>Can we force MySQL to use the `type` index, retain the ORDER BY, and do it all with standard SQL? Sure. The following query does this:</p>
<blockquote>
<pre>SELECT id, type, level FROM data
WHERE type=12345 AND level &gt; 3
ORDER BY id+0</pre>
</blockquote>
<p>id+0 is a function on the `id` column. This makes MySQL unable to utilize the PRIMARY KEY (or any other index on `id`, had there been one).</p>
<p>In his book &#8220;<a title="SQL Tuning by Dan Tow" href="http://www.amazon.com/SQL-Tuning-Dan-Tow/dp/0596005733">SQL Tuning</a>&#8220;, Dan Tow dedicates a chapter on hints and tips like the above. He shows how to control the use or non-use of indexes, the order by which subqueries are calculated, and more.</p>
<p>Unfortunately, the EJB specification said this was not allowed. You could not ORDER BY a fucntion. Only on normal column.</p>
<h4>Solution #7: Make MySQL think the problem is harder than it really is</h4>
<p>Almost out of options. Just a moment before settling for sorting on the application side, another issue can be considered: since MySQL was fooled once, can it be fooled again to make things right? Can we fool it to believe that the PRIMARY KEY would not be worthwhile to use? The following query does this:</p>
<blockquote>
<pre>SELECT id, type, level FROM data
WHERE type=12345 AND level &gt; 3
ORDER BY id, type, level</pre>
</blockquote>
<p>Let&#8217;s reflect on this one. What is the order by which the rows are returned now? Answer: exactly as before. Since `id` is PRIMARY KEY, it is also UNIQUE, so no two `id` values are the same. Therefore, the secondary sorting column is redudant, and so is the following one. We get exactly the same result as &#8220;ORDER BY id&#8221;.</p>
<p>But MySQL didn&#8217;t catch this. This query caused MySQL to say: <em>&#8220;Mmmmm. &#8216;ORDER BY id, type, level&#8217; is not doable with the PRIMARY KEY only. Well, in this case, I had better used the `type` index&#8221;</em>. Is this a weakness of MySQL? I guess so. Maybe it will be fixed in the future. But this was the fix that made the day.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/7-ways-to-convince-mysql-to-use-the-right-index/feed</wfw:commentRss>
		<slash:comments>39</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">695</post-id>	</item>
		<item>
		<title>Two storage engines; different plans, Part II</title>
		<link>https://shlomi-noach.github.io/blog/mysql/two-storage-engines-different-plans-part-ii</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/two-storage-engines-different-plans-part-ii#comments</comments>
				<pubDate>Fri, 07 Nov 2008 17:55:08 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[Indexing]]></category>
		<category><![CDATA[InnoDB]]></category>
		<category><![CDATA[MyISAM]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=35</guid>
				<description><![CDATA[In Part I of this article, we have seen how the internal structure of the storage engine&#8217;s index can affect an execution plan. We&#8217;ve seen that some plans are inherent to the way engines are implemented. We wish to present a second scenario in which execution plans vary for different storage engines. Again, we will [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>In <a title=" Two storage engines; different plans, Part I" href="https://shlomi-noach.github.io/blog/?p=9">Part I</a> of this article, we have seen how the internal structure of the storage engine&#8217;s index can affect an execution plan. We&#8217;ve seen that some plans are inherent to the way engines are implemented.</p>
<p>We wish to present a second scenario in which execution plans vary for different storage engines. Again, we will consider MyISAM and InnoDB. Again, we will use the world database for testing. This time, we will see how confident the storage engines are in their index search capabilities.</p>
<p>Many newcomers to databases often believe that an index search is always preferable to full table scan. This is not the case. If I were to look for 10 rows in a 1,000,000 rows table, using an indexed column &#8211; I could benefit from an index search. However, if I’m looking for 200,000 rows on that table (that’s 20% of the rows) &#8211; an index search can actually be much more expensive than a full table scan.<span id="more-35"></span></p>
<p>There are several points to consider here: a full table scan is often close to sequential, whereas an index traversal is not. Not only are the index nodes stored non sequentially, but the links from the index to table data may look like a macaroni plate. Also, the index structure itself is a tree-structure, and it can be shown that the number of pages in the index can be larger than the number of pages in the table. Even for partial index scans, it may be worthwhile to simply scan the table.</p>
<p>The threshold above which table scan is preferred is somewhere between 10% and 30% in common DBMS.</p>
<p>We will consider here a scenario where we index a two-valued column, a simple ‘T’ and ‘F’ enum. “That’s a very poor column to index”, you may say. But what if the ratio between the two values is high? Say, 1000:1? Should there be different search plans for the ‘F’ valued rows and for the ‘T’ valued rows?</p>
<p>Let us duplicate the CountryLanguage table, and make it much larger. We will create a table named “cl”, with some 125K rows.</p>
<p><strong><code>mysql&gt; SHOW CREATE TABLE CountryLanguage \G<br />
*************************** 1. row ***************************<br />
Table: CountryLanguage<br />
Create Table: CREATE TABLE `CountryLanguage` (<br />
`CountryCode` char(3) NOT NULL default '',<br />
`Language` char(30) NOT NULL default '',<br />
`IsOfficial` enum('T','F') NOT NULL default 'F',<br />
`Percentage` float(4,1) NOT NULL default '0.0',<br />
PRIMARY KEY  (`CountryCode`,`Language`)<br />
) ENGINE=MyISAM DEFAULT CHARSET=latin1<br />
1 row in set (0.00 sec)</code></strong></p>
<p><strong><code>mysql&gt; CREATE TABLE cl SELECT * FROM CountryLanguage;<br />
Query OK, 984 rows affected (0.02 sec)<br />
Records: 984  Duplicates: 0  Warnings: 0</code></strong></p>
<p>And now make it very large:</p>
<p><strong><code>mysql&gt; INSERT INTO cl SELECT * FROM cl;<br />
Query OK, 984 rows affected (0.02 sec)<br />
Records: 984  Duplicates: 0  Warnings: 0</code></strong></p>
<p>…</p>
<p><strong><code>mysql&gt; INSERT INTO cl SELECT * FROM cl;<br />
Query OK, 62976 rows affected (0.08 sec)<br />
Records: 62976  Duplicates: 0  Warnings: 0</code></strong></p>
<p><strong><code>mysql&gt; UPDATE cl SET IsOfficial='F';<br />
Query OK, 1265 rows affected (0.23 sec)<br />
Rows matched: 125952  Changed: 1265  Warnings: 0</code></strong></p>
<p><strong><code>mysql&gt; UPDATE cl SET IsOfficial='T' WHERE RAND()&lt;0.001;<br />
Query OK, 148 rows affected (0.20 sec)<br />
Rows matched: 148  Changed: 148  Warnings: 0</code></strong></p>
<p>We have now a large table, where the majority of rows have ‘F’ values for ‘IsOfficial’, and the minority have ‘T’. We shall now add an index on this column, and will then make sure the table is in MyISAM (it may be created with another storage engine, depending on our default engine parameter).</p>
<p><strong><code>mysql&gt; ALTER TABLE cl ADD INDEX (IsOfficial);<br />
Query OK, 125952 rows affected (0.31 sec)<br />
Records: 125952  Duplicates: 0  Warnings: 0</code></strong></p>
<p><strong><code>mysql&gt; ALTER TABLE cl ENGINE=MyISAM;<br />
Query OK, 125952 rows affected (1.21 sec)<br />
Records: 125952  Duplicates: 0  Warnings: 0</code></strong></p>
<p>Now let us compare the search plans for ‘F’ and for ‘T’.</p>
<p><strong><code>mysql&gt; EXPLAIN SELECT * FROM cl WHERE IsOfficial='F' \G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: cl<br />
type: ALL<br />
possible_keys: IsOfficial<br />
key: NULL<br />
key_len: NULL<br />
ref: NULL<br />
rows: 94464<br />
Extra: Using where<br />
1 row in set (0.02 sec)</code></strong></p>
<p><strong><code>mysql&gt; EXPLAIN SELECT * FROM cl WHERE IsOfficial='T' \G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: cl<br />
type: ref<br />
possible_keys: IsOfficial<br />
key: IsOfficial<br />
key_len: 1<br />
ref: const<br />
rows: 138<br />
Extra: Using where<br />
1 row in set (0.00 sec)</code></strong></p>
<p>What MyISAM decided was that an index search on the ‘F’ rows is useless. A table scan was deemed to be preferable. However, for ‘T’ values rows, the index we created was just fine, and would indeed be used.</p>
<p>InnoDB will state differently.</p>
<p><strong><code>mysql&gt; ALTER TABLE cl ENGINE=InnoDB;<br />
Query OK, 125952 rows affected (1.07 sec)<br />
Records: 125952  Duplicates: 0  Warnings: 0</code></strong></p>
<p><strong><code>mysql&gt; EXPLAIN SELECT * FROM cl WHERE IsOfficial='F' \G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: cl<br />
type: ref<br />
possible_keys: IsOfficial<br />
key: IsOfficial<br />
key_len: 1<br />
ref: const<br />
rows: 61667<br />
Extra: Using where<br />
1 row in set (0.00 sec)</code></strong></p>
<p><strong><code>mysql&gt; EXPLAIN SELECT * FROM cl WHERE IsOfficial='T' \G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: cl<br />
type: ref<br />
possible_keys: IsOfficial<br />
key: IsOfficial<br />
key_len: 1<br />
ref: const<br />
rows: 148<br />
Extra: Using where<br />
1 row in set (0.00 sec)<br />
</code><br />
</strong>On the ‘T’ search, MyISAM and InnoDB agree. But look at the plan for the ‘F’ rows: InnoDB still prefers an index search to table scan, even though it estimates a lookup on 50% of the rows.</p>
<p>The behavior just exposed is not entirely consistent. InnoDB and MyISAM differ in the way they update the index statistics. While ANALYZE TABLE on MyISAM performs an exaustive search on index values, InnoDB will only do 10 random test dives and return with a rough calculation. In fact, InnDB’s estimations can greatly vary from the real values distribution, and successive calls to ANALYZE table can produce varying results.</p>
<p>What has been presented in this part is not a rule to live by. You shouldn’t base your queries or expected behavior on the index distribution or search plan calculated by the storage engine. These may change in time. What’s instructive here is the freedom MySQL gives the storage engines in decision making, and the different actions taken when dealing with different engines.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/two-storage-engines-different-plans-part-ii/feed</wfw:commentRss>
		<slash:comments>3</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">35</post-id>	</item>
		<item>
		<title>Two storage engines; different plans, Part I</title>
		<link>https://shlomi-noach.github.io/blog/mysql/two-storage-engines-different-plans-part-i</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/two-storage-engines-different-plans-part-i#comments</comments>
				<pubDate>Sat, 01 Nov 2008 16:36:29 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[Execution plan]]></category>
		<category><![CDATA[Indexing]]></category>
		<category><![CDATA[InnoDB]]></category>
		<category><![CDATA[MyISAM]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=9</guid>
				<description><![CDATA[A popping question is: &#8220;Can an execution plan change for different storage engines?&#8221; The answer is &#8220;Yes&#8221;. I will present two such cases, where the MySQL optimizer will choose different execution plans, based on our choice of storage engine. We will consider MyISAM and InnoDB, the two most popular engines. The two differ in many [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>A popping question is: &#8220;Can an execution plan change for different storage engines?&#8221;</p>
<p>The answer is &#8220;Yes&#8221;. I will present two such cases, where the MySQL optimizer will choose different execution plans, based on our choice of storage engine.</p>
<p>We will consider MyISAM and InnoDB, the two most popular engines. The two differ in many respects, and in particular, the way they implement indexes and statistics: two major players in the optimizer&#8217;s point of view.<span id="more-9"></span></p>
<p>Let&#8217;s start with the famous <em>world </em>database, available from <a title="http://dev.mysql.com/doc/world-setup/en/world-setup.html" href="http://dev.mysql.com/doc/world-setup/en/world-setup.html">dev.mysql.com</a>. All tables in this schema are defined as MyISAM. We will alter them between MyISAM and InnoDB as we go along.</p>
<p>A peek at the Country table reveals:</p>
<p><strong><code>mysql&gt; SHOW CREATE TABLE Country \G<br />
*************************** 1. row ***************************<br />
Table: Country<br />
Create Table: CREATE TABLE `Country` (<br />
`Code` char(3) NOT NULL default '',<br />
`Name` char(52) NOT NULL default '',<br />
`Continent` enum('Asia','Europe','North America','Africa','Oceania','Antarctica','South America') NOT NULL default 'Asia',<br />
...<br />
PRIMARY KEY  (`Code`)<br />
) ENGINE=MyISAM DEFAULT CHARSET=latin1<br />
1 row in set (0.00 sec)</code></strong></p>
<p>To see the first example of execution plan difference, we will add an index on the Country table:</p>
<p><strong><code>ALTER TABLE Country ADD INDEX (Continent);</code></strong></p>
<p>And run the following query to find European country codes:</p>
<p><strong><code>mysql&gt; SELECT Code FROM Country WHERE Continent = 'Europe';<br />
+------+<br />
| Code |<br />
+------+<br />
| NLD  |<br />
| ALB  |<br />
| AND  |<br />
| BEL  |<br />
| BIH  |<br />
| GBR  |<br />
...</code></strong></p>
<p>But how is this query executed?</p>
<p><strong><code>mysql&gt; EXPLAIN SELECT Code FROM Country WHERE Continent = 'Europe'\G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: Country<br />
type: ref<br />
possible_keys: Continent<br />
key: Continent<br />
key_len: 1<br />
ref: const<br />
rows: 37<br />
Extra: Using where<br />
1 row in set (0.00 sec)</code></strong></p>
<p>Simple enough: we asked for European countries only. MySQL has found the index on Continent to be appropriate. However, to get the actual Code, a table row read was necessary.</p>
<p>InnoDB will provide a different plan, though:</p>
<p><strong><code>mysql&gt; ALTER TABLE Country ENGINE=InnoDB;<br />
Query OK, 239 rows affected (0.18 sec)<br />
Records: 239  Duplicates: 0  Warnings: 0</code></strong></p>
<p><strong><code>mysql&gt; EXPLAIN SELECT Code FROM Country WHERE Continent = 'Europe'\G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: Country<br />
type: ref<br />
possible_keys: Continent<br />
key: Continent<br />
key_len: 1<br />
ref: const<br />
rows: 46<br />
Extra: Using where; Using index<br />
1 row in set (0.00 sec)</code></strong></p>
<p>Can you spot the difference? The &#8220;Extra&#8221; column now indicates &#8220;Using index&#8221; (The numbers of expected rows also differ, but that&#8217;s another issue).</p>
<p>The reason for this change lies with the way MyISAM and InnoDB implement indexes. MyISAM takes the approach where the table data resides in its own space (and in fact, its own file), and all indexes refer to rows in that space. MyISAM is using nonclustered indexes.</p>
<p>InnoDB, however, uses a clustered index on the PRIMARY KEY. That is, for every table there is always a PRIMARY KEY index (even if we never defined one), and table data is aggregated withing the index&#8217; structure. And so, to access table rows, one must first traverse the PRIMARY KEY index. This type of index is called a &#8220;clustered index&#8221;. The Code column is the primary key, and therefore the data is clustered on the Code column.</p>
<p>InnoDB&#8217;s secondary indexes behave altogether differently. A secondary index does not refer to the table rows directly, but instead refer to the PRIMARY KEY value, which relates to those rows. A table look up using a secondary key involves a search on that key, only to get a PRIMARY KEY value, and search on that clustered index as well. A side effect is that a secondary index includes the values of the PRIMARY KEY. Each secondary index, like the one we created on Continent, is somewhat a compound index, like on (Continent, Code). This is the reason that for our query, a search on the index was enough. There was no need to access table data, since all relevant data could be found within the index.</p>
<p>I say &#8220;somewhat&#8221;, because in contrast with an index on (Continent, Code), the index does not necessarily store the PRIMARY KEY values in any particular order. To prove this, let&#8217;s ask the following:</p>
<p><strong><code>mysql&gt; EXPLAIN SELECT Code FROM Country WHERE Continent = 'Europe' ORDER BY Code\G<br />
*************************** 1. row ***************************<br />
id: 1<br />
select_type: SIMPLE<br />
table: Country<br />
type: ref<br />
possible_keys: Continent<br />
key: Continent<br />
key_len: 1<br />
ref: const<br />
rows: 46<br />
Extra: Using where; Using index; Using filesort<br />
1 row in set (0.00 sec)</code></strong></p>
<p>There&#8217;s a &#8220;Using filesort&#8221; comment in the &#8220;Extra&#8221; column, which would not be there had we used a compound index on (Continent, Code).</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/two-storage-engines-different-plans-part-i/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">9</post-id>	</item>
	</channel>
</rss>

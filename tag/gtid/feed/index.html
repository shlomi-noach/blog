<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	>

<channel>
	<title>GTID &#8211; code.openark.org</title>
	<atom:link href="https://shlomi-noach.github.io/blog/tag/gtid/feed" rel="self" type="application/rss+xml" />
	<link>http://shlomi-noach.github.io/blog/</link>
	<description>Blog by Shlomi Noach</description>
	<lastBuildDate>Wed, 11 Dec 2019 08:00:00 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
<site xmlns="com-wordpress:feed-additions:1">32412571</site>	<item>
		<title>Quick hack for GTID_OWN lack</title>
		<link>https://shlomi-noach.github.io/blog/mysql/quick-hack-for-gtid_own-lack</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/quick-hack-for-gtid_own-lack#respond</comments>
				<pubDate>Wed, 11 Dec 2019 08:00:00 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[GTID]]></category>
		<category><![CDATA[Replication]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7974</guid>
				<description><![CDATA[One of the benefits of MySQL GTIDs is that each server remembers all GTID entries ever executed. Normally these would be ranges, e.g. 0041e600-f1be-11e9-9759-a0369f9435dc:1-3772242 or multi-ranges, e.g. 24a83cd3-e30c-11e9-b43d-121b89fcdde6:1-103775793, 2efbcca6-7ee1-11e8-b2d2-0270c2ed2e5a:1-356487160, 46346470-6561-11e9-9ab7-12aaa4484802:1-26301153, 757fdf0d-740e-11e8-b3f2-0a474bcf1734:1-192371670, d2f5e585-62f5-11e9-82a5-a0369f0ed504:1-10047. One of the common problems in asynchronous replication is the issue of consistent reads. I&#8217;ve just written to the master. Is the data [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>One of the benefits of MySQL GTIDs is that each server remembers <em>all</em> GTID entries ever executed. Normally these would be ranges, e.g. <code>0041e600-f1be-11e9-9759-a0369f9435dc:1-3772242</code> or multi-ranges, e.g. <code>24a83cd3-e30c-11e9-b43d-121b89fcdde6:1-103775793, 2efbcca6-7ee1-11e8-b2d2-0270c2ed2e5a:1-356487160, 46346470-6561-11e9-9ab7-12aaa4484802:1-26301153, 757fdf0d-740e-11e8-b3f2-0a474bcf1734:1-192371670, d2f5e585-62f5-11e9-82a5-a0369f0ed504:1-10047</code>.</p>
<p>One of the common problems in asynchronous replication is the issue of consistent reads. I&#8217;ve just written to the <code>master</code>. Is the data available on a replica yet? We have iterated on this, from reading on <code>master</code>, to heuristically finding up-to-date replicas based on heartbeats (see <a href="https://www.youtube.com/watch?v=ZVBmTgIMOCA">presentation</a> and <a href="https://speakerdeck.com/shlominoach/monitoring-time-in-a-distributed-database-a-play-in-three-acts">slides</a>) via <a href="https://github.com/github/freno">freno</a>, and now settled, on some parts of our apps, to using GTID.</p>
<p>GTIDs are reliable as any replica can give you a definitive answer to the question: <em>have you applied a given transaction or not?</em>. Given a GTID entry, say <code>f7b781a9-cbbd-11e9-affb-008cfa542442:12345</code>, one may query for the following on a replica:</p>
<pre><code>mysql&gt; select gtid_subset('f7b781a9-cbbd-11e9-affb-008cfa542442:12345', @@global.gtid_executed) as transaction_found;
+-------------------+
| transaction_found |
+-------------------+
|                 1 |
+-------------------+

mysql&gt; select gtid_subset('f7b781a9-cbbd-11e9-affb-008cfa542442:123450000', @@global.gtid_executed) as transaction_found;
+-------------------+
| transaction_found |
+-------------------+
|                 0 |
+-------------------+
</code></pre>
<h3>Getting OWN_GTID</h3>
<p>This is all well, but, given some <code>INSERT</code> or <code>UPDATE</code> on the <code>master</code>, how can I tell what&#8217;s the GTID associated with that transaction? There\s good news and bad news.</p>
<ul>
<li>Good news is, you may <code>SET SESSION session_track_gtids = OWN_GTID</code>. This makes the MySQL protocol return the GTID generated by your transaction.</li>
<li>Bad news is, this isn&#8217;t a standard SQL response, and the common MySQL drivers offer you no way to get that information!</li>
</ul>
<p>At GitHub we author our own Ruby driver, and have implemented the functionality to extract <code>OWN_GTID</code>, much like you&#8217;d extract <code>LAST_INSERT_ID</code>. But, how does one solve that without modifying the drivers? Here&#8217;s a poor person&#8217;s solution which gives you an inexact, but good enough, info. Following a write (<code>insert</code>, <code>delete</code>, <code>create</code>, &#8230;), run:</p>
<pre><code>select gtid_subtract(concat(@@server_uuid, ':1-1000000000000000'), gtid_subtract(concat(@@server_uuid, ':1-1000000000000000'), @@global.gtid_executed)) as master_generated_gtid;
</code></pre>
<p>The idea is to &#8220;clean&#8221; the executed GTID set from irrelevant entries, by filtering out all ranges that do not belong to the server you&#8217;ve just written to (the <code>master</code>). The number <code>1000000000000000</code> stands for &#8220;high enough value that will never be reached in practice&#8221; &#8211; set to your own preferred value, but this value should take you beyond <code>300</code> years assuming <code>100,000</code> transactions per second.</p>
<p><span id="more-7974"></span></p>
<p>The value you get is the range on the master itself. e.g.:</p>
<pre><code>mysql&gt; select gtid_subtract(concat(@@server_uuid, ':1-1000000000000000'), gtid_subtract(concat(@@server_uuid, ':1-1000000000000000'), @@global.gtid_executed)) as master_generated_gtid;
+-------------------------------------------------+
| master_generated_gtid                           |
+-------------------------------------------------+
| dc103953-1598-11ea-82a7-008cfa5440e4:1-35807176 |
+-------------------------------------------------+
</code></pre>
<p>You may further parse the above to extract <code>dc103953-1598-11ea-82a7-008cfa5440e4:35807176</code> if you want to hold on to the latest GTID entry. Now, this entry isn&#8217;t necessarily <em>your own</em>. Between the time of your write and the time of your GTID query, other writes will have taken place. But the entry you get is either your own or a later one. If you can find that entry on a replica, that means your write is included on the replica.</p>
<p>One may wonder, why do we need to extract the value at all? Why not just <code>select @@global.gtid_executed</code>? Why filter only the <code>master</code>&#8216;s UUID? Logically, the answer is the same if you do that. But in practice, your query may be unfortunate enough to return some:</p>
<pre><code>select @@global.gtid_executed \G

e71f0cdb-b8ef-11e9-9361-008cfa542442:1-83331,
e742d87f-dea7-11e9-be6d-008cfa542c9e:1-18485,
e7880c0e-ac54-11e9-865a-008cfa544064:1-7331973,
e82043c6-c7d9-11e9-9413-008cfa5440e4:1-61692,
e902678b-b046-11e9-a281-008cfa542c9e:1-83108,
e90d7ff9-e35e-11e9-a9a0-008cfa544064:1-18468,
e929a635-bb40-11e9-9c0d-008cfa5440e4:1-139348,
e9351610-ef1b-11e9-9db4-008cfa5440e4:1-33460918,
e938578d-dc41-11e9-9696-008cfa542442:1-18232,
e947f165-cd53-11e9-b7a1-008cfa5440e4:1-18480,
e9733f37-d537-11e9-8604-008cfa5440e4:1-18396,
e97a0659-e423-11e9-8433-008cfa542442:1-18237,
e98dc1f7-e0f8-11e9-9bbd-008cfa542c9e:1-18482,
ea16027a-d20e-11e9-9845-008cfa542442:1-18098,
ea1e1aa6-e74a-11e9-a7f2-008cfa544064:1-18450,
ea8bc1bd-dd06-11e9-a10c-008cfa542442:1-18203,
eae8c750-aaca-11e9-b17c-008cfa544064:1-85990,
eb1e41e9-af81-11e9-9ceb-008cfa544064:1-86220,
eb3c9b3b-b698-11e9-b67a-008cfa544064:1-18687,
ec6daf7e-b297-11e9-a8a0-008cfa542c9e:1-80652,
eca4af92-c965-11e9-a1f3-008cfa542c9e:1-18333,
ecd110b9-9647-11e9-a48f-008cfa544064:1-24213,
ed26890e-b10b-11e9-a79d-008cfa542c9e:1-83450,
ed92b3bf-c8a0-11e9-8612-008cfa542442:1-18223,
eeb60c82-9a3d-11e9-9ea5-008cfa544064:1-1943152,
eee43e06-c25d-11e9-ba23-008cfa542442:1-105102,
eef4a7fb-b438-11e9-8d4b-008cfa5440e4:1-74717,
eefdbd3b-95b3-11e9-833d-008cfa544064:1-39415,
ef087062-ba7b-11e9-92de-008cfa5440e4:1-9726172,
ef507ff0-98b3-11e9-8b15-008cfa5440e4:1-928030,
ef662471-9a3b-11e9-bd2e-008cfa542c9e:1-954800,
f002e9f7-97ee-11e9-bed0-008cfa542c9e:1-5180743,
f0233228-e9a1-11e9-a142-008cfa542c9e:1-18583,
f04780c4-a864-11e9-9f28-008cfa542c9e:1-83609,
f048acd9-b1d2-11e9-a0b6-008cfa544064:1-70663,
f0573d8c-9978-11e9-9f73-008cfa542c9e:1-85642135,
f0b0a37c-c89c-11e9-804c-008cfa5440e4:1-18488,
f0cfe1ac-e5af-11e9-bc09-008cfa542c9e:1-18552,
f0e4997c-cbc9-11e9-9179-008cfa542442:1-1655552,
f24e481c-b5c4-11e9-aff0-008cfa5440e4:1-83015,
f4578c4b-be6d-11e9-982e-008cfa5440e4:1-132701,
f48bce80-e99f-11e9-94f4-a0369f9432f4:1-18460,
f491adf1-9b04-11e9-bc71-008cfa542c9e:1-962823,
f5d3db74-a929-11e9-90e8-008cfa5440e4:1-75379,
f6696ba7-b750-11e9-b458-008cfa542c9e:1-83096,
f714cb4c-dab7-11e9-adb9-008cfa544064:1-18413,
f7b781a9-cbbd-11e9-affb-008cfa542442:1-18169,
f81f7729-b10d-11e9-b29b-008cfa542442:1-86820,
f88a3298-e903-11e9-88d0-a0369f9432f4:1-18548,
f9467b29-d78c-11e9-b1a2-008cfa5440e4:1-18492,
f9c08f5c-e4ea-11e9-a76c-008cfa544064:1-1667611,
fa633abf-cee3-11e9-9346-008cfa542442:1-18361,
fa8b0e64-bb42-11e9-9913-008cfa542442:1-140089,
fa92234c-cc90-11e9-b337-008cfa544064:1-18324,
fa9755eb-e425-11e9-907d-008cfa542c9e:1-1668270,
fb7843d5-eb38-11e9-a1ff-a0369f9432f4:1-1668957,
fb8ceae5-dd08-11e9-9ed3-008cfa5440e4:1-18526,
fbf9970e-bc07-11e9-9e4f-008cfa5440e4:1-136157,
fc0ffaee-98b1-11e9-8574-008cfa542c9e:1-940999,
fc9bf1e4-ee54-11e9-9ce9-008cfa542c9e:1-18189,
fca4672f-ac56-11e9-8a83-008cfa542442:1-82014,
fcebaa05-dab5-11e9-8356-008cfa542c9e:1-18490,
fd0c88b1-ad1b-11e9-bf3a-008cfa5440e4:1-75167,
fd394feb-e4e4-11e9-bd09-008cfa5440e4:1-18574,
fd687577-b048-11e9-b429-008cfa542442:1-83479,
fdb18995-a79f-11e9-a28d-008cfa542442:1-82351,
fdc72b7f-b696-11e9-ade9-008cfa544064:1-57674,
ff1f3b6b-c967-11e9-ae04-008cfa544064:1-18503,
ff6fe7dc-c186-11e9-9bb4-008cfa5440e4:1-103192,
fff9dd94-ed95-11e9-90b7-008cfa544064:1-911039
</code></pre>
<p>This can happen when you fail over to a new master, multiple times; it happens when you don&#8217;t recycle UUIDs, when you provision new hosts and let MySQL pick their UUID. Returning this amount of data <em>per query</em> is an excessive overhead, hence why we extract the <code>master</code>&#8216;s UUID only, which is guaranteed to be limited in size.</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/quick-hack-for-gtid_own-lack/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">7974</post-id>	</item>
		<item>
		<title>Three wishes for a new year</title>
		<link>https://shlomi-noach.github.io/blog/mysql/three-wishes-for-a-new-year-4</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/three-wishes-for-a-new-year-4#comments</comments>
				<pubDate>Wed, 28 Sep 2016 14:20:54 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[gh-ost]]></category>
		<category><![CDATA[GTID]]></category>
		<category><![CDATA[operations]]></category>
		<category><![CDATA[Opinions]]></category>
		<category><![CDATA[Replication]]></category>
		<category><![CDATA[SQL]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7643</guid>
				<description><![CDATA[(Almost) another new year by Jewish calendar. What do I wish for the following year? World peace Good health to all Relaxed GTID constraints I&#8217;m still not using GTID, and still see operational issues with working with GTID. As a latest example, our new schema migration solution, gh-ost, allows us to test migrations in production, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>(Almost) another new year by Jewish calendar. What do I wish for the following year?</p>
<ol>
<li>World peace</li>
<li>Good health to all</li>
<li>Relaxed GTID constraints</li>
</ol>
<p>I&#8217;m still not using GTID, and still see operational issues with working with GTID. As a latest example, our new schema migration solution, gh-ost, allows us to test migrations in production, on replicas. The GTID catch? <code>gh-ost</code> has to write something to the binary log. Thus, it &#8220;corrupts&#8221; the replica with a bogus GTID entry that will never be met in another server, thus making said replica unsafe to promote. We can work around this, but&#8230;</p>
<p>I understand the idea and need for the <code>Executed GTID Set</code>. It will certainly come in handy with multi-writer InnoDB Cluster. However for most use cases GTID poses a burden. The reason is that our topologies are imperfect, and we as humans are imperfect, and operations are most certainly imperfect. We may wish to operate on a replica: test something, by intention or mistake. We may wish to use a subchain as the seed for a new cluster split. We may wish to be able to write to downstream replicas. We may use a 3rd party tool that issues a <code>flush tables with read lock</code> without disabling <code>sql_log_bin</code>. Things just happen.</p>
<p>For that, I would like to suggest GTID control levels, such as:</p>
<ol>
<li><em>Strict</em>: same as Oracle&#8217;s existing implementation. Executed sets, purged sets, whatnot.</li>
<li><em>Last executed</em>: a mode where the only thing that counts is the last executed GTID value. If I repoint replica, all it needs to check is &#8220;hey this is my last executed GTID entry, give me the coordinates of yours. And, no, I don&#8217;t care about comparing executed and purged sets, I will trust you and keep running from that point on&#8221;</li>
<li><em>Declarative</em>: GTIDs are generated, are visible in each and every binary log entry, but are completely ignored.</li>
</ol>
<p>I realize Oracle MySQL GTID is out for some over 3 years now, but I&#8217;m sorry &#8211; I still have reservations and see use cases where I fear it will not serve me right.</p>
<p>How about my previous years wishes? World peace and good health never came through, however:</p>
<ul>
<li>My <a href="https://shlomi-noach.github.io/blog/mysql/three-wishes-for-a-new-year-2015">2015 wish</a> for &#8220;decent, operations friendly built in online table refactoring&#8221; was unmet, however <code>gh-ost</code> is a thing now and exceeds my expectations. No, really. Please come see <a href="https://www.percona.com/live/plam16/sessions/introducing-gh-ost-triggerless-painless-trusted-online-schema-migrations">Tom &amp; myself present gh-ost</a> and how it changed our migration paradigm.</li>
<li>My <a href="https://shlomi-noach.github.io/blog/mysql/three-wishes-for-a-new-year-201">2012 wish</a> for &#8220;decent, long waited for, implementation of <a href="http://en.wikipedia.org/wiki/Window_function_%28SQL%29#Window_function">Window Functions</a> (aka Analytic Functions) for MySQL&#8221; was met by MariaDB&#8217;s <a href="https://mariadb.com/kb/en/mariadb/window-functions/">window functions</a>.<br />
Not strictly Window Functions, but Oracle MySQL 8.0 will <a href="http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/">support CTE</a> (hierarchial/recursive), worth a mention.</li>
</ul>
<p>See you in Amsterdam!</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/three-wishes-for-a-new-year-4/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">7643</post-id>	</item>
		<item>
		<title>Refactoring replication topology with Pseudo GTID</title>
		<link>https://shlomi-noach.github.io/blog/mysql/refactoring-replication-topology-with-pseudo-gtid</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/refactoring-replication-topology-with-pseudo-gtid#comments</comments>
				<pubDate>Thu, 23 Oct 2014 10:37:17 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[GTID]]></category>
		<category><![CDATA[orchestrator]]></category>
		<category><![CDATA[Pseudo GTID]]></category>
		<category><![CDATA[Replication]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7046</guid>
				<description><![CDATA[This post describes in detail the method of using Pseudo GTID to achieve unplanned replication topology changes, i.e. connecting two arbitrary slaves, or recovering from a master failure even as all its slaves are hanging in different positions. Please read Pseudo GTID and Pseudo GTID, RBR as introduction. Consider the following case: the master dies unexpectedly, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>This post describes in detail the method of using Pseudo GTID to achieve unplanned replication topology changes, i.e. connecting two arbitrary slaves, or recovering from a master failure even as all its slaves are hanging in different positions.</p>
<p>Please read <a href="https://shlomi-noach.github.io/blog/mysql/pseudo-gtid">Pseudo GTID</a> and <a href="https://shlomi-noach.github.io/blog/mysql/pseudo-gtid-row-based-replication">Pseudo GTID, RBR</a> as introduction.</p>
<p>Consider the following case: the master dies unexpectedly, and its three slaves are all hanging, not necessarily at same binary log file/position (network broke down while some slaves managed to salvage more entries into their relay logs than others)</p>
<blockquote><p><a href="https://shlomi-noach.github.io/blog/wp-content/uploads/2014/10/orchestrator-failed-master.jpeg"><img class="alignnone size-full wp-image-7059" src="https://shlomi-noach.github.io/blog/wp-content/uploads/2014/10/orchestrator-failed-master.jpeg" alt="orchestrator-failed-master" width="801" height="365" srcset="https://shlomi-noach.github.io/blog/wp-content/uploads/2014/10/orchestrator-failed-master.jpeg 801w, https://shlomi-noach.github.io/blog/wp-content/uploads/2014/10/orchestrator-failed-master-300x136.jpeg 300w" sizes="(max-width: 801px) 100vw, 801px" /></a></p></blockquote>
<p>(Did you notice the <strong>&#8220;Candidate for master&#8221;</strong> message? To be discussed shortly)</p>
<h4>GTID</h4>
<p>With GTID each transaction (and entry in the binary log) is associated with a unique mark &#8212; the Global Transaction ID. Just pick the slave with the most advanced GTID to be the next master, and just <strong>CHANGE MASTER TO MASTER_HOST=&#8217;chosen_slave&#8217;</strong> on the other slaves, and everything magically works. A slave knows which GTID it has already processed, and can look that entry on its master&#8217;s binary logs, resuming replication on the one that follows.</p>
<p>How does that work? The master&#8217;s binary logs are searched for that GTID entry. I&#8217;m not sure how brute-force this is, since I&#8217;m aware of a subtlety which requires brute-force scan of all binary logs; I don&#8217;t actually know if it&#8217;s always like that.</p>
<h4>Pseudo GTID</h4>
<p>We can mimick that above, but our solution can&#8217;t be as fine grained. With the injection of Pseudo GTID we mark the binary log for unique entries. But instead of having a unique identifier for every entry, we have a unique identifier for every second, 10 seconds, or what have you, with otherwise normal, non-unique entries in between our Pseudo GTID entries.</p>
<h4>Recognizing which slave is more up to date</h4>
<p>Given two slaves, which is more up to date?</p>
<ul>
<li>If both replicate(d) from same master, a <strong>SHOW SLAVE STATUS</strong> comparison answers (safe method: wait till SQL thread catches up with broken IO thread, compare <strong>relay_master_log_file</strong>, <strong>exec_master_log_pos</strong> on both machines). This is the method by which the above &#8220;Candidate for master&#8221; message is produced.</li>
<li>If one is/was descendent of the other, then obviously it is less advanced or equals its ancestor.</li>
<li>Otherwise we&#8217;re unsure &#8211; still solvable via bi-directional trial &amp; error, as explained later on.</li>
</ul>
<p>For now, let&#8217;s assume we know which slave is more up to date (has received and executed more relay logs). Let&#8217;s call it <strong>S1</strong>, whereas the less up-to-date will be <strong>S2</strong>. This will make our discussion simpler.<span id="more-7046"></span></p>
<h4>Prerequisites</h4>
<ul>
<li>We require a Pseudo GTID in place: a periodic injection of a known-to-be-unique query, and which we know how to intercept</li>
<li>We require <strong>log_slave_updates</strong> on all slaves. We will need to parse the binary logs on slaves. I have little trust in the availability of relay logs: these are flushed, rotated and auto-erased all too quickly. The proposed solution does not require any daemon running on the MySQL servers themselves. There will be nothing to back up the relay logs, so I can&#8217;t trust these to exist. Binary logs, on the other hand, have expiry period in days, and so I can trust them to exist for a duration of a few minutes.</li>
<li>Normal replication. Not multi threaded. Not multi-source.</li>
</ul>
<h4>The process of rematching slaves</h4>
<p><strong>S1</strong> is more up to date, hence we want to make <strong>S2</strong> a slave of <strong>S1</strong>. We expect the statements/entries found in <strong>S2</strong>&#8216;s binary logs to exist in <strong>S1</strong>, in the same order, but somewhere back in the past, padded by additional entries (zero or more) that are not found in <strong>S2</strong>. Steps are:</p>
<ul>
<li>Find latest Pseudo-GTID entry in <strong>S2</strong>&#8216;s logs. This can be done by iterating <strong>S2</strong>&#8216;s binary logs newest to oldest. The first (time DESC) binary log where such entry is found is to be searched for the last entry (latest). Keep record of the binlog <strong>file2:pos2</strong> coordinates.</li>
<li>Take note of the exact entry made in the above. This is the unique value.</li>
<li>Search said unique value in <strong>S1</strong>&#8216;s binary logs. Since it is unique, your method of search is arbirtary, you just need to find it. Brute-force wise you start looking at newest binary log moving back in time. Not found? Unlikely, since this means the lag diff between <strong>S1</strong> and <strong>S2</strong> is as long as the binlog expiry. We will be handling with failures and with immediate actions; we can expect slave lags in the seconds or in the minutes &#8211; we don&#8217;t even consider the possibility where the entry is not found.</li>
<li>Take note of the coordinates <strong>file1:pos1</strong> in <strong>S1</strong> where we found the unique value.</li>
<li>We now iterate <strong>S2</strong>&#8216;s binary logs starting with the Pseudo GTID <strong>file2:pos2</strong>. We expect to find each entry in <strong>S1</strong>&#8216;s binary logs, successively, starting <strong>file1:pos1</strong>. We verify the entries in both servers are identical. Exceptions above could be:
<ul>
<li>Meta-entries (start-of-log, end-of-log, shutdown), in which case we skip to the next entry (this is done in both <strong>S1</strong> and <strong>S2</strong>)</li>
<li>Local statements executed directly on either <strong>S1</strong> or <strong>S2</strong>, such as <strong>ANALYZE TABLE</strong> or whatever, which make no impact on data &#8212; we may skip these</li>
<li>Local, evil statements executed directly on the slaves,which make for data impact (<strong>INSERT</strong>, <strong>DELETE</strong>, &#8230;). We choose to fail the operation in such case</li>
</ul>
</li>
<li>After all entries in <strong>S2</strong> (matched by entries in <strong>S1</strong>) are iterated, our <strong>S1</strong> &#8220;cursor&#8221; now looks at the first statement that never made it to <strong>S2</strong>. This is <strong>file_win:pos_win</strong>, into which we will point <strong>S2</strong>.</li>
<li>Or, we might find that upon iterating all entries in <strong>S2</strong> we have exactly reached the end of binlog entries for S1: this means both S1 and S2 are actually in identical state. We point <strong>S2</strong> into <strong>S1</strong>&#8216;s next-binlog-position.
<ul>
<li>This is in fact no different than the previous case, but of particular interest.</li>
</ul>
</li>
<li>Or, we might run out of entries in <strong>S1</strong>. No, we can&#8217;t, because our assumption was that <strong>S1</strong> is more advanced than (or equally advanced as) <strong>S2</strong>. But this answers the question: &#8220;<strong>what if didn&#8217;t know in advance who&#8217;s more advanced?</strong>&#8221; (no pun intended). In such case we conclude <strong>S2</strong> is actually more advanced than <strong>S1</strong> and we can try the other way around.</li>
</ul>
<p>That last bullet is of importance: if you have two slaves whose &#8220;family connection&#8221; is complex, you can still match one below the other; you may try one way and fail, then try the other way around and succeed.</p>
<p>Comparison of the events following the Pseudo-GTID is a good way of sanity checking (some meta-stuff should be ignored, like transaction IDs, table IDs, these can vary across servers), and builds up confidence in the correctness of the operation.</p>
<p>The codebase is actually complete and pushed; I&#8217;ll release a BETA version or <a href="https://github.com/outbrain/orchestrator">orchestrator</a> next week, that supports Pseudo GTID. Let me tell you, doing this kind of crazy stuff with visual feedback (of course command line is available) is very very cool.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/refactoring-replication-topology-with-pseudo-gtid/feed</wfw:commentRss>
		<slash:comments>5</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">7046</post-id>	</item>
		<item>
		<title>Pseudo GTID, Row Based Replication</title>
		<link>https://shlomi-noach.github.io/blog/mysql/pseudo-gtid-row-based-replication</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/pseudo-gtid-row-based-replication#comments</comments>
				<pubDate>Thu, 23 Oct 2014 04:18:52 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[GTID]]></category>
		<category><![CDATA[orchestrator]]></category>
		<category><![CDATA[Replication]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7043</guid>
				<description><![CDATA[This post continues Pseudo GTID, in a series of posts describing an alternative to using MySQL GTIDs. The solution offered in the last post does not work too well for row based replication. The binary log entries for the INSERT statement look like this: # at 1020 # at 1074 #141020 12:36:21 server id 1  [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>This post continues <a href="https://shlomi-noach.github.io/blog/mysql/pseudo-gtid">Pseudo GTID</a>, in a series of posts describing an alternative to using MySQL GTIDs.</p>
<p>The solution offered in the last post does not work too well for row based replication. The binary log entries for the INSERT statement look like this:</p>
<blockquote>
<pre># at 1020
# at 1074
#141020 12:36:21 server id 1  end_log_pos 1074  Table_map: `test`.`pseudo_gtid` mapped to number 33
#141020 12:36:21 server id 1  end_log_pos 1196  Update_rows: table id 33 flags: STMT_END_F

BINLOG '
lddEVBMBAAAANgAAADIEAAAAACEAAAAAAAEABHRlc3QAC3BzZXVkb19ndGlkAAMDBw8CQAAE
lddEVBgBAAAAegAAAKwEAAAAACEAAAAAAAEAA///+AEAAACL10RUJDg2ZmRhMDk1LTU4M2MtMTFl
NC05NzYyLTNjOTcwZWEzMWVhOPgBAAAAlddEVCQ4Y2YzOWMyYy01ODNjLTExZTQtOTc2Mi0zYzk3
MGVhMzFlYTg=
'/*!*/;
</pre>
</blockquote>
<p>Where&#8217;s our unique value? Encoded within something that cannot be trusted to be unique. Issuing <strong>mysqlbinlog &#8211;verbose</strong> helps out:</p>
<blockquote>
<pre>BEGIN
/*!*/;
# at 183
# at 237
#141020 12:35:51 server id 1  end_log_pos 237   Table_map: `test`.`pseudo_gtid` mapped to number 33
#141020 12:35:51 server id 1  end_log_pos 359   Update_rows: table id 33 flags: STMT_END_F

BINLOG '
d9dEVBMBAAAANgAAAO0AAAAAACEAAAAAAAEABHRlc3QAC3BzZXVkb19ndGlkAAMDBw8CQAAE
d9dEVBgBAAAAegAAAGcBAAAAACEAAAAAAAEAA///+AEAAABt10RUJDc1MWJkYzEwLTU4M2MtMTFl
NC05NzYyLTNjOTcwZWEzMWVhOPgBAAAAd9dEVCQ3YjExZDQzYy01ODNjLTExZTQtOTc2Mi0zYzk3
MGVhMzFlYTg=
'/*!*/;
### UPDATE `test`.`pseudo_gtid`
### WHERE
###   @1=1
###   @2=1413797741
###   <strong>@3='751bdc10-583c-11e4-9762-3c970ea31ea8'</strong>
### SET
###   @1=1
###   @2=1413797751
###   @3='7b11d43c-583c-11e4-9762-3c970ea31ea8'</pre>
</blockquote>
<p>and that&#8217;s something we can work with. However, I like to do stuff from within MySQL, and rely as little as possible on external tools. How do the binary log entries look via <strong>SHOW BINLOG EVENTS</strong>? Not good.</p>
<blockquote>
<pre>master [localhost] {msandbox} (test) &gt; show binlog events in 'mysql-bin.000058' limit 20;
+------------------+------+-------------+-----------+-------------+---------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                  |
+------------------+------+-------------+-----------+-------------+---------------------------------------+
| mysql-bin.000058 |    4 | Format_desc |         1 |         107 | Server ver: 5.5.32-log, Binlog ver: 4 |
| mysql-bin.000058 |  107 | Query       |         1 |         183 | BEGIN                                 |
| mysql-bin.000058 |  183 | Table_map   |         1 |         237 | table_id: 33 (test.pseudo_gtid)       |
| mysql-bin.000058 |  237 | Update_rows |         1 |         359 | table_id: 33 flags: STMT_END_F        |
| mysql-bin.000058 |  359 | Xid         |         1 |         386 | COMMIT /* xid=5460 */                 |
| mysql-bin.000058 |  386 | Query       |         1 |         462 | BEGIN                                 |
| mysql-bin.000058 |  462 | Table_map   |         1 |         516 | table_id: 33 (test.pseudo_gtid)       |
| mysql-bin.000058 |  516 | Update_rows |         1 |         638 | table_id: 33 flags: STMT_END_F        |
| mysql-bin.000058 |  638 | Xid         |         1 |         665 | COMMIT /* xid=5471 */                 |
| mysql-bin.000058 |  665 | Query       |         1 |         741 | BEGIN                                 |
| mysql-bin.000058 |  741 | Table_map   |         1 |         795 | table_id: 33 (test.pseudo_gtid)       |
| mysql-bin.000058 |  795 | Update_rows |         1 |         917 | table_id: 33 flags: STMT_END_F        |
| mysql-bin.000058 |  917 | Xid         |         1 |         944 | COMMIT /* xid=5474 */                 |
| mysql-bin.000058 |  944 | Query       |         1 |        1020 | BEGIN                                 |
| mysql-bin.000058 | 1020 | Table_map   |         1 |        1074 | table_id: 33 (test.pseudo_gtid)       |
| mysql-bin.000058 | 1074 | Update_rows |         1 |        1196 | table_id: 33 flags: STMT_END_F        |
| mysql-bin.000058 | 1196 | Xid         |         1 |        1223 | COMMIT /* xid=5476 */                 |
| mysql-bin.000058 | 1223 | Query       |         1 |        1299 | BEGIN                                 |
| mysql-bin.000058 | 1299 | Table_map   |         1 |        1353 | table_id: 33 (test.pseudo_gtid)       |
| mysql-bin.000058 | 1353 | Update_rows |         1 |        1475 | table_id: 33 flags: STMT_END_F        |
+------------------+------+-------------+-----------+-------------+---------------------------------------+</pre>
</blockquote>
<p>The representation of row-format entries in the <strong>SHOW BINLOG EVENTS</strong> output is really poor. Why, there&#8217;s nothing to tell me at all about what&#8217;s been done, except that this is some operation on <strong>test.pseudo_gtid</strong>. Obviously I cannot find anything unique over here.</p>
<p>Not all is lost. How about DDL statements? Those are still written in SBR format (there&#8217;s no <em>rows</em> to log upon creating a table). A solution could be somehow manipulating a unique value in a DDL statement. There could be various such solutions, and I chose to use a <strong>CREATE VIEW</strong> statement, dynamically composed of a <strong>UUID()</strong>:<span id="more-7043"></span></p>
<blockquote>
<pre>drop event if exists test.update_pseudo_gtid_rbr_event;

delimiter ;;
create event if not exists
  test.update_pseudo_gtid_rbr_event
  on schedule every 10 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @pseudo_gtid := uuid();
      set @_create_statement := concat('create or replace view test.pseudo_gtid_v as select \'', @pseudo_gtid, '\' from dual');
      PREPARE st FROM @_create_statement;
      EXECUTE st;
      DEALLOCATE PREPARE st;    
    end
;;

delimiter ;</pre>
</blockquote>
<p>And this is how it looks on runtime (running this new event along with the old one):</p>
<blockquote>
<pre>master [localhost] {msandbox} (test) &gt; show binlog events in 'mysql-bin.000060' limit 20;
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                                                                  |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000060 |    4 | Format_desc |         1 |         107 | Server ver: 5.5.32-log, Binlog ver: 4                                                                                                                                                 |
| mysql-bin.000060 |  107 | Query       |         1 |         183 | BEGIN                                                                                                                                                                                 |
| mysql-bin.000060 |  183 | Table_map   |         1 |         237 | table_id: 33 (test.pseudo_gtid)                                                                                                                                                       |
| mysql-bin.000060 |  237 | Update_rows |         1 |         359 | table_id: 33 flags: STMT_END_F                                                                                                                                                        |
| mysql-bin.000060 |  359 | Xid         |         1 |         386 | COMMIT /* xid=5802 */                                                                                                                                                                 |
| mysql-bin.000060 |  386 | Query       |         1 |         638 | <strong>use `test`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_v` AS select '7d2d44ca-583e-11e4-9762-3c970ea31ea8' from dual</strong> |
| mysql-bin.000060 |  638 | Query       |         1 |         714 | BEGIN                                                                                                                                                                                 |
| mysql-bin.000060 |  714 | Table_map   |         1 |         768 | table_id: 33 (test.pseudo_gtid)                                                                                                                                                       |
| mysql-bin.000060 |  768 | Update_rows |         1 |         890 | table_id: 33 flags: STMT_END_F                                                                                                                                                        |
| mysql-bin.000060 |  890 | Xid         |         1 |         917 | COMMIT /* xid=5811 */                                                                                                                                                                 |
| mysql-bin.000060 |  917 | Query       |         1 |        1169 | <strong>use `test`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_v` AS select '83234b13-583e-11e4-9762-3c970ea31ea8' from dual</strong> |
| mysql-bin.000060 | 1169 | Query       |         1 |        1245 | BEGIN                                                                                                                                                                                 |
| mysql-bin.000060 | 1245 | Table_map   |         1 |        1299 | table_id: 33 (test.pseudo_gtid)                                                                                                                                                       |
| mysql-bin.000060 | 1299 | Update_rows |         1 |        1421 | table_id: 33 flags: STMT_END_F                                                                                                                                                        |
| mysql-bin.000060 | 1421 | Xid         |         1 |        1448 | COMMIT /* xid=5819 */                                                                                                                                                                 |
| mysql-bin.000060 | 1448 | Query       |         1 |        1700 | <strong>use `test`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_v` AS select '89193a09-583e-11e4-9762-3c970ea31ea8' from dual</strong> |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</pre>
</blockquote>
<p>Scroll to the right to find the unique value injected into the view&#8217;s creation statement.</p>
<p>Does it replicate well? Looking at a slave&#8217;s binary logs:</p>
<blockquote>
<pre>slave3 [localhost] {msandbox} ((none)) &gt; show binlog events in 'mysql-bin.000064';
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                                                                  |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000064 |    4 | Format_desc |       103 |         107 | Server ver: 5.5.32-log, Binlog ver: 4                                                                                                                                                 |
| mysql-bin.000064 |  107 | Query       |         1 |         166 | BEGIN                                                                                                                                                                                 |
| mysql-bin.000064 |  166 | Table_map   |         1 |         220 | table_id: 33 (test.pseudo_gtid)                                                                                                                                                       |
| mysql-bin.000064 |  220 | Update_rows |         1 |         342 | table_id: 33 flags: STMT_END_F                                                                                                                                                        |
| mysql-bin.000064 |  342 | Xid         |         1 |         369 | COMMIT /* xid=3184 */                                                                                                                                                                 |
| mysql-bin.000064 |  369 | Query       |         1 |         601 | <strong>use `test`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_v` AS select '7d2d44ca-583e-11e4-9762-3c970ea31ea8' from dual</strong> |
| mysql-bin.000064 |  601 | Query       |         1 |         660 | BEGIN                                                                                                                                                                                 |
| mysql-bin.000064 |  660 | Table_map   |         1 |         714 | table_id: 33 (test.pseudo_gtid)                                                                                                                                                       |
| mysql-bin.000064 |  714 | Update_rows |         1 |         836 | table_id: 33 flags: STMT_END_F                                                                                                                                                        |
| mysql-bin.000064 |  836 | Xid         |         1 |         863 | COMMIT /* xid=3194 */                                                                                                                                                                 |
| mysql-bin.000064 |  863 | Query       |         1 |        1095 | <strong>use `test`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_v` AS select '83234b13-583e-11e4-9762-3c970ea31ea8' from dual</strong> |
| mysql-bin.000064 | 1095 | Query       |         1 |        1154 | BEGIN                                                                                                                                                                                 |
| mysql-bin.000064 | 1154 | Table_map   |         1 |        1208 | table_id: 33 (test.pseudo_gtid)                                                                                                                                                       |
| mysql-bin.000064 | 1208 | Update_rows |         1 |        1330 | table_id: 33 flags: STMT_END_F                                                                                                                                                        |
| mysql-bin.000064 | 1330 | Xid         |         1 |        1357 | COMMIT /* xid=3198 */                                                                                                                                                                 |
| mysql-bin.000064 | 1357 | Query       |         1 |        1589 | <strong>use `test`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_v` AS select '89193a09-583e-11e4-9762-3c970ea31ea8' from dual</strong> |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</pre>
</blockquote>
<p>Not as pretty; I hate DDL operations that are not strictly required; but this solves the problem, plus rewriting the view means we&#8217;re not littering the tablespace.</p>
<p>Next post will describe the steps towards achieving GTID-like behaviour based on the above.</p>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/pseudo-gtid-row-based-replication/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">7043</post-id>	</item>
		<item>
		<title>Pseudo GTID</title>
		<link>https://shlomi-noach.github.io/blog/mysql/pseudo-gtid</link>
				<comments>https://shlomi-noach.github.io/blog/mysql/pseudo-gtid#comments</comments>
				<pubDate>Wed, 22 Oct 2014 05:22:26 +0000</pubDate>
		<dc:creator><![CDATA[shlomi]]></dc:creator>
				<category><![CDATA[MySQL]]></category>
		<category><![CDATA[GTID]]></category>
		<category><![CDATA[orchestrator]]></category>
		<category><![CDATA[Pseudo GTID]]></category>
		<category><![CDATA[replic]]></category>

		<guid isPermaLink="false">https://shlomi-noach.github.io/blog/?p=7036</guid>
				<description><![CDATA[Pseudo GTID is a method to implement a GTID-like solution where slaves are easily connected to one another. This blog post and the following ones will describe work in progress (some 80% completed), where simulation of GTID makes for a good enough basis for refactoring replication topologies. I&#8217;m coding this in orchestrator, which already provides [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Pseudo GTID is a method to implement a GTID-like solution where slaves are easily connected to one another. This blog post and the following ones will describe work in progress (some 80% completed), where simulation of GTID makes for a <em>good enough</em> basis for refactoring replication topologies. I&#8217;m coding this in <a href="https://github.com/outbrain/orchestrator">orchestrator</a>, which already provides a substantial infrastructure support for this.</p>
<p>The final goal: <em>orchestrator</em> will allow you to move a slave below another, using only the data available by those two slaves. The usage is obvious:</p>
<ul>
<li>Easy master failover (master dead? <em>Orchestrator</em> will choose the most advanced slave to promote <em>and</em> make it master of its siblings)</li>
<li>Slave promotion in complex topologies (with <a href="https://shlomi-noach.github.io/blog/mysql/using-deep-nested-replication-topologies">deep nested topologies</a>, be able to move a slave up the hierarchy even if its local master is corrupted).</li>
</ul>
<p>This can all happen with your normal, <em>non GTID</em>, MySQL replication, using your normal binary log files &amp; positions.</p>
<p>This work in progress is inspired by <strong><a href="https://github.com/samlambert">Sam Lambert</a></strong> at GitHub, who has worked on a similar solution with different implementation. I also recall discussions with other DBAs having similar solution.</p>
<h4>Pseudo GTID</h4>
<p>First thing&#8217;s first, the basis for proposed solution is a <em>pseudo-GTID</em>. A unique entry in the binary logs (not necessarily sequential; not necessarily in ascending order). While in GTID implementations we have a unique identifier <em>for each entry</em> in the binary log, with pseudo-GTID we accept an <em>occasional</em> (or <em>frequent</em>) unique entry in the binary log.</p>
<p>There are many ways to do so. Certainly a client can generate a unique Id and invoke some statement on MySQL involving that ID. That would serve as valid grounds for the proposed solution. But I like things to be contained within MySQL. Consider, for example, the following event, which would be my preferred choice in Statement Based Replication (for RBR solution, see next post):</p>
<blockquote>
<pre>drop table if exists test.pseudo_gtid;
create table if not exists test.pseudo_gtid (
  id int unsigned not null primary key,
  ts timestamp,
  gtid varchar(64) charset ascii
);


drop event if exists test.update_pseudo_gtid_event;

delimiter ;;
create event if not exists
  test.update_pseudo_gtid_event
  on schedule every 10 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @pseudo_gtid := uuid();
      insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid);
    end
;;

delimiter ;</pre>
</blockquote>
<p>The above is based on <a title="Link to Making UUID() and RAND() replication safe" href="https://shlomi-noach.github.io/blog/mysql/making-uuid-and-rand-replication-safe" rel="bookmark">Making UUID() and RAND() replication safe</a>. What do we get? Once in 10 seconds (or what have you), a unique entry is written to the binary log.</p>
<p><span id="more-7036"></span>Consider that the event is already running by now, and the next conventional statements executed by the application:</p>
<blockquote>
<pre>master [localhost] {msandbox} (test) &gt; create table test.vals(id int);
master [localhost] {msandbox} (test) &gt; insert into test.vals (id) values (17);
master [localhost] {msandbox} (test) &gt; insert into test.vals (id) values (18);
master [localhost] {msandbox} (test) &gt; insert into test.vals (id) values (19);
master [localhost] {msandbox} (test) &gt; insert into test.vals (id) values (23);

master [localhost] {msandbox} (test) &gt; show master logs;
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000036 |       531 |
| mysql-bin.000037 |      1269 |
| mysql-bin.000038 |      6627 |
| mysql-bin.000039 |      3313 |
+------------------+-----------+
</pre>
</blockquote>
<p>Let&#8217;s look at the binary logs content:</p>
<blockquote>
<pre>master [localhost] {msandbox} (test) &gt; show binlog events in 'mysql-bin.000039';
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                        |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000039 |    4 | Format_desc |         1 |         107 | Server ver: 5.5.32-log, Binlog ver: 4                                                                                                       |
| mysql-bin.000039 |  107 | Query       |         1 |         183 | BEGIN                                                                                                                                       |
| mysql-bin.000039 |  183 | User var    |         1 |         263 | <strong>@`pseudo_gtid`=_utf8 0x37383435623633382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000039 |  263 | Query       |         1 |         461 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 |  461 | Xid         |         1 |         488 | COMMIT /* xid=74 */                                                                                                                         |
| mysql-bin.000039 |  488 | Query       |         1 |         581 | use `test`; create table test.vals(id int)                                                                                                  |
| mysql-bin.000039 |  581 | Query       |         1 |         657 | BEGIN                                                                                                                                       |
| mysql-bin.000039 |  657 | User var    |         1 |         737 | <strong>@`pseudo_gtid`=_utf8 0x37653362616434382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000039 |  737 | Query       |         1 |         935 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 |  935 | Xid         |         1 |         962 | COMMIT /* xid=82 */                                                                                                                         |
| mysql-bin.000039 |  962 | Query       |         1 |        1038 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1038 | User var    |         1 |        1118 | <strong>@`pseudo_gtid`=_utf8 0x38343331396662332D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000039 | 1118 | Query       |         1 |        1316 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 1316 | Xid         |         1 |        1343 | COMMIT /* xid=84 */                                                                                                                         |
| mysql-bin.000039 | 1343 | Query       |         1 |        1411 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1411 | Query       |         1 |        1512 | use `test`; insert into test.vals (id) values (17)                                                                                          |
| mysql-bin.000039 | 1512 | Xid         |         1 |        1539 | COMMIT /* xid=84 */                                                                                                                         |
| mysql-bin.000039 | 1539 | Query       |         1 |        1607 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1607 | Query       |         1 |        1708 | use `test`; insert into test.vals (id) values (18)                                                                                          |
| mysql-bin.000039 | 1708 | Xid         |         1 |        1735 | COMMIT /* xid=85 */                                                                                                                         |
| mysql-bin.000039 | 1735 | Query       |         1 |        1803 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1803 | Query       |         1 |        1904 | use `test`; insert into test.vals (id) values (19)                                                                                          |
| mysql-bin.000039 | 1904 | Xid         |         1 |        1931 | COMMIT /* xid=86 */                                                                                                                         |
| mysql-bin.000039 | 1931 | Query       |         1 |        2007 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2007 | User var    |         1 |        2087 | <strong>@`pseudo_gtid`=_utf8 0x38613237376232352D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000039 | 2087 | Query       |         1 |        2285 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 2285 | Xid         |         1 |        2312 | COMMIT /* xid=89 */                                                                                                                         |
| mysql-bin.000039 | 2312 | Query       |         1 |        2380 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2380 | Query       |         1 |        2481 | use `test`; insert into test.vals (id) values (23)                                                                                          |
| mysql-bin.000039 | 2481 | Xid         |         1 |        2508 | COMMIT /* xid=89 */                                                                                                                         |
| mysql-bin.000039 | 2508 | Query       |         1 |        2584 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2584 | User var    |         1 |        2664 | <strong>@`pseudo_gtid`=_utf8 0x39303164373731612D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000039 | 2664 | Query       |         1 |        2862 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 2862 | Xid         |         1 |        2889 | COMMIT /* xid=92 */                                                                                                                         |
| mysql-bin.000039 | 2889 | Query       |         1 |        2965 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2965 | User var    |         1 |        3045 | <strong>@`pseudo_gtid`=_utf8 0x39363133363965382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000039 | 3045 | Query       |         1 |        3243 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 3243 | Xid         |         1 |        3270 | COMMIT /* xid=94 */                                                                                                                         |
| mysql-bin.000039 | 3270 | Rotate      |         1 |        3313 | mysql-bin.000040;pos=4                                                                                                                      |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+</pre>
</blockquote>
<p>Marked in bold are the pseudo-GTID statements, aptly read <strong>&#8220;@`pseudo_gtid`=_utf8 0x&#8230;&#8221;</strong>, and which are the resulting entry of the <strong>set @pseudo_gtid := uuid();</strong> statement. These are interleaved with our normal statements. In busier servers there could be hundreds or thousands of statements between any two pseudo-GTID entries.</p>
<p>We have a replicating slave to the above, which uses <strong>log_slave_updates</strong>. For reasons to be explained later, I prefer and require <strong>log_slave_updates</strong>, and will examine the slave&#8217;s binary logs (instead of directly looking at the slave&#8217;s relay logs):</p>
<blockquote>
<pre>slave3 [localhost] {msandbox} ((none)) &gt; show master logs;

+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000046 |      1077 |
| mysql-bin.000047 |       126 |
| mysql-bin.000048 |       150 |
| mysql-bin.000049 |       150 |
| mysql-bin.000050 |     13860 |
| mysql-bin.000051 |       107 |
+------------------+-----------+

slave3 [localhost] {msandbox} ((none)) &gt; show binlog events in 'mysql-bin.000051';
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                        |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000051 |    4 | Format_desc |       103 |         107 | Server ver: 5.5.32-log, Binlog ver: 4                                                                                                       |
| mysql-bin.000051 |  107 | Query       |         1 |         174 | BEGIN                                                                                                                                       |
| mysql-bin.000051 |  174 | User var    |         1 |         254 | <strong>@`pseudo_gtid`=_utf8 0x37383435623633382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000051 |  254 | Query       |         1 |         452 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 |  452 | Xid         |         1 |         479 | COMMIT /* xid=2141 */                                                                                                                       |
| mysql-bin.000051 |  479 | Query       |         1 |         572 | use `test`; create table test.vals(id int)                                                                                                  |
| mysql-bin.000051 |  572 | Query       |         1 |         639 | BEGIN                                                                                                                                       |
| mysql-bin.000051 |  639 | User var    |         1 |         719 | <strong>@`pseudo_gtid`=_utf8 0x37653362616434382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000051 |  719 | Query       |         1 |         917 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 |  917 | Xid         |         1 |         944 | COMMIT /* xid=2150 */                                                                                                                       |
| mysql-bin.000051 |  944 | Query       |         1 |        1011 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1011 | User var    |         1 |        1091 | <strong>@`pseudo_gtid`=_utf8 0x38343331396662332D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000051 | 1091 | Query       |         1 |        1289 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 | 1289 | Xid         |         1 |        1316 | COMMIT /* xid=2152 */                                                                                                                       |
| mysql-bin.000051 | 1316 | Query       |         1 |        1375 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1375 | Query       |         1 |        1476 | use `test`; insert into test.vals (id) values (17)                                                                                          |
| mysql-bin.000051 | 1476 | Xid         |         1 |        1503 | COMMIT /* xid=2154 */                                                                                                                       |
| mysql-bin.000051 | 1503 | Query       |         1 |        1562 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1562 | Query       |         1 |        1663 | use `test`; insert into test.vals (id) values (18)                                                                                          |
| mysql-bin.000051 | 1663 | Xid         |         1 |        1690 | COMMIT /* xid=2156 */                                                                                                                       |
| mysql-bin.000051 | 1690 | Query       |         1 |        1749 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1749 | Query       |         1 |        1850 | use `test`; insert into test.vals (id) values (19)                                                                                          |
| mysql-bin.000051 | 1850 | Xid         |         1 |        1877 | COMMIT /* xid=2158 */                                                                                                                       |
| mysql-bin.000051 | 1877 | Query       |         1 |        1944 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1944 | User var    |         1 |        2024 | <strong>@`pseudo_gtid`=_utf8 0x38613237376232352D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000051 | 2024 | Query       |         1 |        2222 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 | 2222 | Xid         |         1 |        2249 | COMMIT /* xid=2160 */                                                                                                                       |
| mysql-bin.000051 | 2249 | Query       |         1 |        2308 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 2308 | Query       |         1 |        2409 | use `test`; insert into test.vals (id) values (23)                                                                                          |
| mysql-bin.000051 | 2409 | Xid         |         1 |        2436 | COMMIT /* xid=2162 */                                                                                                                       |
| mysql-bin.000051 | 2436 | Query       |         1 |        2503 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 2503 | User var    |         1 |        2583 | <strong>@`pseudo_gtid`=_utf8 0x39303164373731612D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci</strong>                     |
| mysql-bin.000051 | 2583 | Query       |         1 |        2781 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 | 2781 | Xid         |         1 |        2808 | COMMIT /* xid=2164 */                                                                                                                       |
| mysql-bin.000051 | 2808 | Rotate      |       103 |        2851 | mysql-bin.000052;pos=4                                                                                                                      |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
</pre>
</blockquote>
<p>We can see the <strong>&#8220;@`pseudo_gtid`=_utf8 0x&#8221;</strong> entries are replicated well, and are identical throughout the topology (this continue to work well on second-level slaves etc.).</p>
<p>To be continued.</p>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>https://shlomi-noach.github.io/blog/mysql/pseudo-gtid/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">7036</post-id>	</item>
	</channel>
</rss>

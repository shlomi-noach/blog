<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Open Source on code.openark.org</title>
    <link>/blog/tag/open-source/</link>
    <description>Recent content in Open Source on code.openark.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Tue, 06 Sep 2016 11:44:14 +0000</lastBuildDate>
    <atom:link href="/blog/tag/open-source/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>gh-ost 1.0.17: Hooks, Sub-second lag control, Amazon RDS and more</title>
      <link>/blog/mysql/gh-ost-1-0-17-hooks-sub-second-lag-control-amazon-rds-and-more</link>
      <pubDate>Tue, 06 Sep 2016 11:44:14 +0000</pubDate>
      
      <guid>/blog/mysql/gh-ost-1-0-17-hooks-sub-second-lag-control-amazon-rds-and-more</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/github/gh-ost&#34;&gt;gh-ost&lt;/a&gt; version &lt;a href=&#34;https://github.com/github/gh-ost/releases/tag/v1.0.17&#34;&gt;1.0.17&lt;/a&gt; is now released, with various additions and fixes. Here are some notes of interest:&lt;/p&gt;
&lt;h3&gt;Hooks&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gh-ost&lt;/code&gt; now supports &lt;a href=&#34;https://github.com/github/gh-ost/blob/master/doc/hooks.md&#34;&gt;hooks&lt;/a&gt;. These are your own executables that &lt;code&gt;gh-ost&lt;/code&gt; will invoke at particular points of interest (validation pass, about to cut-over, success, failure, status, etc.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gh-ost&lt;/code&gt; will set various environment variables for your executables to pick up, passing along such information as migrated/&lt;em&gt;ghost&lt;/em&gt; table name, elapsed time, processed rows, migrated host etc.&lt;/p&gt;
&lt;h3&gt;Sub-second lag control&lt;/h3&gt;
&lt;p&gt;At GitHub we&#39;re very strict about replication lag. We keep it well under &lt;code&gt;1&lt;/code&gt; second at most times. &lt;code&gt;gh-ost&lt;/code&gt; can now identify &lt;a href=&#34;https://github.com/github/gh-ost/blob/master/doc/subsecond-lag.md&#34;&gt;sub-second lag on replicas&lt;/a&gt; (well, you need to supply with the right query). Our current production migrations are set by default with &lt;code&gt;--max-lag-millis=500&lt;/code&gt; or less, and our most intensive migrations keep replication lag well below &lt;code&gt;1sec&lt;/code&gt; or even below &lt;code&gt;500ms&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;No SUPER&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;SUPER&lt;/code&gt; privilege is required to &lt;code&gt;set global binlog_format=&#39;ROW&#39;&lt;/code&gt; and for &lt;code&gt;STOP SLAVE; START SLAVE;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If you &lt;em&gt;know&lt;/em&gt; your replica has RBR, you can pass &lt;code&gt;--assume-rbr&lt;/code&gt; and skips those steps.&lt;/p&gt;
&lt;h3&gt;RDS&lt;/h3&gt;
&lt;p&gt;Hooks + No Super = RDS, as seems to be the case. For &lt;code&gt;--test-on-replica&lt;/code&gt; you will need to supply your own &lt;code&gt;gh-ost-on-stop-replication&lt;/code&gt; hook, to stop your RDS replica at cut-over phase. See &lt;a href=&#34;https://github.com/github/gh-ost/issues/163#issuecomment-244694616&#34;&gt;this tracking issue&lt;/a&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;master-master&lt;/h3&gt;
&lt;p&gt;While active-active are still not supported, you now have greater control over master-master topologies by being able to explicitly pick your master (as &lt;code&gt;gh-ost&lt;/code&gt; arbitrarily picks one of the co-masters). Do so by passing &lt;code&gt;--assume-master-host&lt;/code&gt;. See &lt;a href=&#34;https://github.com/github/gh-ost/blob/master/doc/cheatsheet.md&#34;&gt;cheatsheet&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;tungsten replicator&lt;/h3&gt;
&lt;p&gt;Similarly, &lt;code&gt;gh-ost&lt;/code&gt; cannot crawl your &lt;code&gt;tungsten&lt;/code&gt; topology, and you are able to specify &lt;code&gt;--tungsten --assume-master-host=the.master.com&lt;/code&gt;. See &lt;a href=&#34;https://github.com/github/gh-ost/blob/master/doc/cheatsheet.md&#34;&gt;cheatsheet&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Concurrent-rowcount&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--exact-rowcount&lt;/code&gt; is awesomeness, keeping quite accurate estimate of progress. With &lt;code&gt;--concurrent-rowcount&lt;/code&gt; we begin migration with a rough estimate, and execute &lt;code&gt;select count(*) from your_table&lt;/code&gt; in parallel, updating our estimate later on throughout the migration&lt;/p&gt;
&lt;h3&gt;Stricter, safer&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gh-ost&lt;/code&gt; works in &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt; mode, meaning it would fail rather than set the wrong value to a column.&lt;/p&gt;
&lt;p&gt;In addition to unit-testing and production continuous test, a set of &lt;a href=&#34;https://github.com/github/gh-ost/blob/master/doc/local-tests.md&#34;&gt;local tests&lt;/a&gt; is growing, hopefully to run as CI tests later on.&lt;/p&gt;
&lt;h3&gt;Fixed problems&lt;/h3&gt;
&lt;p&gt;Fixed &lt;code&gt;time_zone&lt;/code&gt; related bug, high &lt;code&gt;unsigned&lt;/code&gt; values bug; added strict check for triggers, relaxed config file parsing, and more. Thank you to community contributors for PRs, from &lt;code&gt;ipv6&lt;/code&gt; to typos!&lt;/p&gt;
&lt;h3&gt;Known issues&lt;/h3&gt;
&lt;p&gt;Issues coming and going at all times -- thank you for reporting Issues!&lt;/p&gt;
&lt;p&gt;We have a confirmed &lt;a href=&#34;https://github.com/github/gh-ost/issues/226&#34;&gt;bug with non-UTF charsets&lt;/a&gt; at this time. Some other minor issues and feature requests are open -- we&#39;ll take them as we go along.&lt;/p&gt;
&lt;h3&gt;Feedback requests&lt;/h3&gt;
&lt;p&gt;We are not testing &lt;code&gt;gh-ost&lt;/code&gt; on RDS ourselves. We appreciate community feedback on &lt;a href=&#34;https://github.com/github/gh-ost/issues/163&#34;&gt;this tracking issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We are not testing &lt;code&gt;gh-ost&lt;/code&gt; on Galera/XtraDB cluster ourselves. We appreciate community feedback on &lt;a href=&#34;https://github.com/github/gh-ost/issues/224&#34;&gt;this tracking issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We value submitted Issues and questions.&lt;/p&gt;
&lt;h3&gt;Speaking&lt;/h3&gt;
&lt;p&gt;We will be presenting &lt;code&gt;gh-ost&lt;/code&gt; in the next month:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I will be &lt;a href=&#34;http://githubuniverse.com/program/sessions/#gh-ost&#34;&gt;presenting gh-ost at GitHub Universe&lt;/a&gt;, Sep. 14th&lt;/li&gt;
&lt;li&gt;Tom Krouper will be &lt;a href=&#34;https://datalayer.com/&#34;&gt;presenting gh-ost at DataLayer&lt;/a&gt;, Seattle, Sep 28th&lt;/li&gt;
&lt;li&gt;Tom Krouper and myself will be &lt;a href=&#34;https://www.percona.com/live/plam16/sessions/introducing-gh-ost-triggerless-painless-trusted-online-schema-migrations&#34;&gt;presenting gh-ost at PerconaLive&lt;/a&gt;, Amsterdam, Oct 5th&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hope to see you there, and thank you again to all contributors!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing gh-ost: triggerless online schema migrations</title>
      <link>/blog/mysql/introducing-gh-ost-triggerless-online-schema-migrations/</link>
      <pubDate>Mon, 01 Aug 2016 19:19:00 +0000</pubDate>
      
      <guid>/blog/mysql/introducing-gh-ost-triggerless-online-schema-migrations/</guid>
      <description>&lt;p&gt;I&#39;m thoroughly happy to introduce &lt;a href=&#34;https://github.com/github/gh-ost&#34;&gt;&lt;strong&gt;gh-ost&lt;/strong&gt;&lt;/a&gt;: triggerless, controllable, auditable, testable, trusted online schema change tool &lt;a href=&#34;http://githubengineering.com/gh-ost-github-s-online-migration-tool-for-mysql/&#34;&gt;released today by GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;gh-ost&lt;/em&gt; now powers our production schema migrations. We hit some serious limitations using &lt;a href=&#34;https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html&#34;&gt;pt-online-schema-change&lt;/a&gt; on our large volume, high traffic tables, to the effect of driving our database to a near grinding halt or even to the extent of causing outages. With &lt;em&gt;gh-ost&lt;/em&gt;, we are now able to migrate our busiest tables at any time, peak hours and heavy workloads included, without causing impact to our service.&lt;/p&gt;
&lt;p&gt;gh-ost supports testing in production. It goes a long way to build trust, both in integrity and in control. Are your databases just too busy and you cannot run existing online-schema-change tools? Have you suffered outages due to migrations? Are you tired of babysitting migrations that run up to 3:00am? Tired of being the only one tailing logs? Please, take a look at &lt;em&gt;gh-ost&lt;/em&gt;. I believe it changes online migration paradigm.&lt;/p&gt;
&lt;p&gt;For a more thorough overview, please read the &lt;a href=&#34;http://githubengineering.com/gh-ost-github-s-online-migration-tool-for-mysql/&#34;&gt;announcement&lt;/a&gt; on the GitHub Engineering Blog, and proceed to the &lt;a href=&#34;https://github.com/github/gh-ost/blob/master/README.md&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;gh-ost&lt;/em&gt; is open sourced under the MIT license.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Solving the non-atomic table swap, Take III: making it atomic</title>
      <link>/blog/mysql/solving-the-non-atomic-table-swap-take-iii-making-it-atomic/</link>
      <pubDate>Thu, 07 Jul 2016 14:54:25 +0000</pubDate>
      
      <guid>/blog/mysql/solving-the-non-atomic-table-swap-take-iii-making-it-atomic/</guid>
      <description>&lt;p&gt;With the unintended impression of becoming live blogging, we now follow up on &lt;a title=&#34;Link to Solving the non-atomic table swap, Take II&#34; href=&#34;http://code.openark.org/blog/mysql/solving-the-non-atomic-table-swap-take-ii&#34; rel=&#34;bookmark&#34;&gt;Solving the non-atomic table swap, Take II&lt;/a&gt; and &lt;a title=&#34;Link to Solving the Facebook-OSC non-atomic table swap problem&#34; href=&#34;http://code.openark.org/blog/mysql/solving-the-facebook-osc-non-atomic-table-swap-problem&#34; rel=&#34;bookmark&#34;&gt;Solving the Facebook-OSC non-atomic table swap problem&lt;/a&gt; with a safe, blocking, &lt;em&gt;atomic&lt;/em&gt; solution&lt;/p&gt;
&lt;h3&gt;Why yet another iteration?&lt;/h3&gt;
&lt;p&gt;The solution presented in &lt;a title=&#34;Link to Solving the non-atomic table swap, Take II&#34; href=&#34;http://code.openark.org/blog/mysql/solving-the-non-atomic-table-swap-take-ii&#34; rel=&#34;bookmark&#34;&gt;Solving the non-atomic table swap, Take II&lt;/a&gt; was good, in that it was safe. No data corruption. Optimistic: if no connection is killed throughout the process, then completely blocking.&lt;/p&gt;
&lt;p&gt;Two outstanding issues remained:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If something did go wrong, the solution reverted to a table-outage&lt;/li&gt;
&lt;li&gt;On replicas, the table swap is non atomic, non blocking. There&#39;s table-outage scenario on replica.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As it turns out, there&#39;s a simpler solution which overcomes both the above. As with math and physics, the simpler solution is often the preferred one. But it took those previous iterations to gather a few ideas together. So, anyway:&lt;/p&gt;
&lt;h3&gt;Safe, locking, atomic, asynchronous table swap&lt;/h3&gt;
&lt;p&gt;Do read the aforementioned previous posts; the quick-quick recap is: we want to be able to &lt;strong&gt;LOCK&lt;/strong&gt; a table &lt;strong&gt;tbl&lt;/strong&gt;, then do some stuff, then swap it out and put some &lt;strong&gt;ghost&lt;/strong&gt; table in its place. MySQL does not allow us to &lt;strong&gt;rename tbl to tbl_old, ghost to tbl&lt;/strong&gt; if we have locks on &lt;strong&gt;tbl&lt;/strong&gt; in that session.&lt;/p&gt;
&lt;p&gt;The solution we offer is now based on two connections only (as opposed to three, in the &lt;em&gt;optimistic&lt;/em&gt; approach). &#34;Our&#34; connections will be C10, C20. The &#34;normal&#34; app connections are C1..C9, C11..C19, C21..C29.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connections C1..C9 operate on &lt;strong&gt;tbl&lt;/strong&gt; with normal DML: &lt;strong&gt;INSERT, UPDATE, DELETE&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Connection C10: &lt;strong&gt;CREATE TABLE tbl_old (id int primary key) COMMENT=&#39;magic-be-here&#39;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Connection C10: &lt;strong&gt;LOCK TABLES tbl WRITE, tbl_old WRITE&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Connections C11..C19, newly incoming, issue queries on &lt;strong&gt;tbl&lt;/strong&gt; but are blocked due to the &lt;strong&gt;LOCK&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Connection C20: &lt;strong&gt;RENAME TABLE tbl TO tbl_old, ghost TO tbl&lt;/strong&gt;&lt;br /&gt;
This is blocked due to the &lt;strong&gt;LOCK&lt;/strong&gt;, &lt;em&gt;but&lt;/em&gt; gets prioritized on top connections C11..C19 and on top C1..C9 or any other connection that attempts DML on &lt;strong&gt;tbl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Connections C21..C29, newly incoming, issue queries on &lt;strong&gt;tbl&lt;/strong&gt; but are blocked due to the &lt;strong&gt;LOCK&lt;/strong&gt; and due to the &lt;strong&gt;RENAME&lt;/strong&gt;, waiting in queue&lt;/li&gt;
&lt;li&gt;Connection C10: checks that C20&#39;s &lt;strong&gt;RENAME&lt;/strong&gt; is applied (looks for the blocked &lt;strong&gt;RENAME&lt;/strong&gt; in processlist)&lt;/li&gt;
&lt;li&gt;Connection 10: &lt;strong&gt;DROP TABLE tbl_old&lt;/strong&gt;&lt;br /&gt;
Nothing happens yet; &lt;strong&gt;tbl&lt;/strong&gt; is still locked. All other connections still blocked.&lt;/li&gt;
&lt;li&gt;Connection 10: &lt;strong&gt;UNLOCK TABLES&lt;br /&gt;
BAM!&lt;/strong&gt; The &lt;strong&gt;RENAME&lt;/strong&gt; is first to execute, &lt;strong&gt;ghost&lt;/strong&gt; table is swapped in place of &lt;strong&gt;tbl&lt;/strong&gt;, then C1..C9, C11..C19, C21..C29 all get to operate on the new and shiny &lt;strong&gt;tbl&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some notes&lt;!--more--&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We create &lt;strong&gt;tbl_old&lt;/strong&gt; as a blocker for a premature swap&lt;/li&gt;
&lt;li&gt;It is allowed for a connection to &lt;strong&gt;DROP&lt;/strong&gt; a table it has under a &lt;strong&gt;WRITE LOCK&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A blocked &lt;strong&gt;RENAME&lt;/strong&gt; is always prioritized over a blocked &lt;strong&gt;INSERT/UPDATE/DELETE&lt;/strong&gt;, no matter who came first&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What happens on failures?&lt;/h3&gt;
&lt;p&gt;Much fun. Just works; no rollback required.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If C10 errors on the &lt;strong&gt;CREATE&lt;/strong&gt; we do not proceed.&lt;/li&gt;
&lt;li&gt;If C10 errors on the &lt;strong&gt;LOCK&lt;/strong&gt; statement, we do not proceed. The table is not locked. App continues to operate as normal.&lt;/li&gt;
&lt;li&gt;If C10 dies just as C20 is about to issue the &lt;strong&gt;RENAME&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;The lock is released, the queries C1..C9, C11..C19 immediately operate on &lt;strong&gt;tbl&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;C20&#39;s &lt;strong&gt;RENAME&lt;/strong&gt; immediately fails because &lt;strong&gt;tbl_old&lt;/strong&gt; exists.&lt;br /&gt;
The entire operation is failed, but nothing terrible happens; some queries were blocked for some time is all. We will need to retry everything&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If C10 dies while C20 is blocked on &lt;strong&gt;RENAME&lt;/strong&gt;: Mostly similar to the above. Lock released, then C20 fails the &lt;strong&gt;RENAME&lt;/strong&gt; (because &lt;strong&gt;tbl_old&lt;/strong&gt; exists), then all queries resume normal operation&lt;/li&gt;
&lt;li&gt;If C20 dies before C10 drops the table, we catch the error and let C10 proceed as planned: &lt;strong&gt;DROP, UNLOCK&lt;/strong&gt;. Nothing terrible happens, some queries were blocked for some time. We will need to retry&lt;/li&gt;
&lt;li&gt;If C20 dies just after C10 &lt;strong&gt;DROP&lt;/strong&gt;s the table but before the unlock, same as above.&lt;/li&gt;
&lt;li&gt;If both C10 and C20 die, no problem: &lt;strong&gt;LOCK&lt;/strong&gt; is cleared; &lt;strong&gt;RENAME&lt;/strong&gt; lock is cleared. C1..C9, C11..C19, C21..C29 are free to operate on &lt;strong&gt;tbl&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No matter what happens, at the end of operation we look for the &lt;strong&gt;ghost&lt;/strong&gt; table. Is it still there? Then we know the operation failed, &#34;atomically&#34;. Is it not there? Then it has been renamed to &lt;strong&gt;tbl&lt;/strong&gt;, and the operation worked atomically.&lt;/p&gt;
&lt;p&gt;A side note on failure is the matter of cleaning up the magic &lt;strong&gt;tbl_old&lt;/strong&gt;. Here this is a matter of taste. Maybe just let it live and avoid recreating it, or you can drop it if you like.&lt;/p&gt;
&lt;h3&gt;Impact on app&lt;/h3&gt;
&lt;p&gt;App connections are guaranteed to be blocked, either until &lt;strong&gt;ghost&lt;/strong&gt; is swapped in, or until operation fails. In the former, they proceed to operate on the new table. In the latter, they proceed to operate on the original table.&lt;/p&gt;
&lt;h3&gt;Impact on replication&lt;/h3&gt;
&lt;p&gt;Replication only sees the &lt;strong&gt;RENAME&lt;/strong&gt;. There is no &lt;strong&gt;LOCK&lt;/strong&gt; in the binary logs. Thus, replication sees an atomic two-table swap. There is no table-outage.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This solution satisfies all we wanted to achieve. We&#39;re unlikely to give this another iteration. Well, if some yet-more-elegant solution comes along I&#39;ll be tempted, for the beauty of it, but the solution offered in this post is simple-enough, safe, atomic, replication friendly, and should make everyone happy.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Solving the non-atomic table swap, Take II</title>
      <link>/blog/mysql/solving-the-non-atomic-table-swap-take-ii/</link>
      <pubDate>Mon, 20 Jun 2016 11:26:47 +0000</pubDate>
      
      <guid>/blog/mysql/solving-the-non-atomic-table-swap-take-ii/</guid>
      <description>&lt;p&gt;Following up and improving on &lt;a title=&#34;Link to Solving the Facebook-OSC non-atomic table swap problem&#34; href=&#34;http://code.openark.org/blog/mysql/solving-the-facebook-osc-non-atomic-table-swap-problem&#34; rel=&#34;bookmark&#34;&gt;Solving the Facebook-OSC non-atomic table swap problem&lt;/a&gt;, we present a better, safe solution.&lt;/p&gt;
&lt;h3&gt;Quick, quickest recap:&lt;/h3&gt;
&lt;p&gt;We are working on a triggerless online schema migration solution. It is based on an asynchronous approach, similarly to the &lt;a href=&#34;https://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932/&#34;&gt;FB osc&lt;/a&gt; and as opposed to the synchronous solution as used by &lt;a href=&#34;https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html&#34;&gt;pt-online-schema-change&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We asynchronously synchronize (is that even a valid statement?) between some table &lt;strong&gt;tbl&lt;/strong&gt; and a ghost table &lt;strong&gt;ghost&lt;/strong&gt;, and at some time we want to cut-over: swap the two; kick out &lt;strong&gt;tbl&lt;/strong&gt; and put &lt;strong&gt;ghost&lt;/strong&gt; in its place and under its name.&lt;/p&gt;
&lt;p&gt;However, we cannot use the single statement &lt;strong&gt;rename tbl to tbl_old, ghost to tbl&lt;/strong&gt;, because we use the asynchronous approach, where at the time we lock &lt;strong&gt;tbl&lt;/strong&gt; for writes, we still have some events we need to process and apply onto &lt;strong&gt;ghost&lt;/strong&gt; before swapping the two.&lt;/p&gt;
&lt;p&gt;And MySQL does not allow a &lt;strong&gt;lock tables tbl write; ... ; &lt;/strong&gt;&lt;strong&gt;rename tbl to tbl_old, ghost to tbl&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;a title=&#34;Link to Solving the Facebook-OSC non-atomic table swap problem&#34; href=&#34;http://code.openark.org/blog/mysql/solving-the-facebook-osc-non-atomic-table-swap-problem&#34; rel=&#34;bookmark&#34;&gt;Solving the Facebook-OSC non-atomic table swap problem&lt;/a&gt; we suggested a way that works, unless when it doesn&#39;t work. Read the caveat at the end of the post. Premature death of a connection that participates in the algorithm causes a chain reaction that leads to the premature execution of the &lt;strong&gt;rename&lt;/strong&gt; statement, potentially before we&#39;ve applied those remaining events. This leads to data inconsistency between the old table and the new table, and is unacceptable.&lt;/p&gt;
&lt;p&gt;To that effect, we were more inclined to go with the Facebook solution, which makes a two-step: &lt;strong&gt;lock tables tbl write; alter table tbl rename to tbl_old; ... ; alter table ghost rename to tbl;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This two-step solution is guaranteed not to have data inconsistency. Alas, it also implies an outage. There&#39;s a brief moment, in between the two &lt;strong&gt;rename&lt;/strong&gt;s, and during that time where we apply those last changes, where the table &lt;strong&gt;tbl&lt;/strong&gt; is simply not there.&lt;/p&gt;
&lt;p&gt;Not all applications will fail gracefully on such a scenario.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;UDF&lt;/h3&gt;
&lt;p&gt;We looked at a solution based on UDFs, where we would create global wait conditions, that are not connection based.&lt;/p&gt;
&lt;p&gt;We don&#39;t like UDFs. You need to compile them for every new version. Puppetizing their setup is not fun. We wouldn&#39;t like maintaining this. We wouldn&#39;t like doing the operations for this. Neither would the community.&lt;/p&gt;
&lt;p&gt;We want to make this a community solution. Can we do without UDF?&lt;/p&gt;
&lt;h3&gt;Rewriting MySQL&lt;/h3&gt;
&lt;p&gt;We wish to avoid forking our own version of MySQL. It&#39;s not what we do and it&#39;s a pain.&lt;/p&gt;
&lt;h3&gt;A pure MySQL solution?&lt;/h3&gt;
&lt;p&gt;We found a solution to embrace; it is &lt;em&gt;optimistic&lt;/em&gt;, and &lt;em&gt;safe&lt;/em&gt;. hat &lt;em&gt;optimistic&lt;/em&gt; means is explained further on, but let&#39;s discuss &lt;em&gt;safe&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;The previous solution we came up with as &lt;em&gt;unsafe&lt;/em&gt; because breakage of a single component in the algorithm would lead to inconsistent data. The algorithm itself was fine, as long as no one would break it from the outside. This is the concern: what if some crazy cronjob that cleans up connections (kills idle connections, kills long running transactions) or some unfortunate user command kills one of the connections involved in the cut-over phase? This is not something that would happen every day, but can we protect against it? Our priority is to keep our data intact.&lt;/p&gt;
&lt;p&gt;The solution allows breakage. Even in the face of death of connections, data is not lost/corrupted, and at worst -- causes a FB-like, recoverable outage scenario.&lt;/p&gt;
&lt;h3&gt;A step towards the solution, a flawed one&lt;/h3&gt;
&lt;p&gt;I wish to illustrate something that looks like it would work, but in fact has a hidden flaw. We will later improve on that solution.&lt;/p&gt;
&lt;p&gt;Let&#39;s assume we have &lt;strong&gt;tbl&lt;/strong&gt;, &lt;strong&gt;ghost&lt;/strong&gt; tables. We execute the following by multiple connections; we call them C1, C2, C3, ...:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C1: &lt;strong&gt;lock tables tbl write;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C2, C3, ..., C17: normal app connections, issuing &lt;strong&gt;insert, delete, update&lt;/strong&gt; on &lt;strong&gt;tbl&lt;/strong&gt;. Because of the lock, they are naturally blocked.&lt;/li&gt;
&lt;li&gt;We apply those last event we need to apply onto &lt;strong&gt;ghost&lt;/strong&gt;. No new events are coming our way because &lt;strong&gt;tbl&lt;/strong&gt; is blocked.&lt;/li&gt;
&lt;li&gt;C18: &lt;strong&gt;rename table tbl to tbl_old, ghost to tbl; &lt;/strong&gt;(blocked as well)&lt;/li&gt;
&lt;li&gt;C1: &lt;strong&gt;unlock tables&lt;/strong&gt;&lt;strong&gt;; &lt;/strong&gt;(everything gets released)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&#39;s consider the above, and see why it is flawed. But first, why it would typically work in the first place.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connections C2, ..., C17 came first, and C18 came later. Nevertheless MySQL prioritizes C18 and moves it up the queue of waiting queries on &lt;strong&gt;tbl&lt;/strong&gt;. When we &lt;strong&gt;unlock&lt;/strong&gt;, C18 is the first to execute.&lt;/li&gt;
&lt;li&gt;We only issue the &lt;strong&gt;rename&lt;/strong&gt; once we&#39;re satisfied we&#39;ve applied those changes. We only &lt;strong&gt;unlock&lt;/strong&gt; once we&#39;re satisfied that the &lt;strong&gt;rename&lt;/strong&gt; has been executed.&lt;/li&gt;
&lt;li&gt;If for some reason C1 disconnects before we issue the &lt;strong&gt;rename&lt;/strong&gt; - no problem, we just retry from scratch.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;What&#39;s the flaw?&lt;/h4&gt;
&lt;p&gt;We &lt;strong&gt;rename&lt;/strong&gt; when C1 holds the &lt;strong&gt;lock&lt;/strong&gt;. We check with C1 that it is alive and kicking. Yep, it&#39;s connected and holding the lock. Are you sure? Yep, I&#39;m good! Really really sure? Yep! OK then, let&#39;s &lt;strong&gt;rename!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&#34;Oh darn&#34;, says C1, &#34;now that you went ahead to &lt;strong&gt;rename&lt;/strong&gt;, but just before you actually sent the request, I decided to take time off and terminate&#34;. Or, more realistically, some job would kill C1.&lt;/p&gt;
&lt;p&gt;What happens now? The &lt;strong&gt;rename&lt;/strong&gt; is not there yet. All those queries get released, and are immediately applied onto &lt;strong&gt;tbl&lt;/strong&gt;, and &lt;em&gt;then&lt;/em&gt; the &lt;strong&gt;rename&lt;/strong&gt; applies, kicks all those changes into oblivion, and puts &lt;strong&gt;ghost&lt;/strong&gt; in place, where it immediately receives further writes.&lt;/p&gt;
&lt;p&gt;Those blocking queries were committed but never to be seen again.&lt;/p&gt;
&lt;p&gt;So here&#39;s another way to look at the problem: the &lt;strong&gt;rename&lt;/strong&gt; made it through even though the connection C1 died just prior to that, whereas we would have loved the &lt;strong&gt;rename&lt;/strong&gt; to abort upon such case.&lt;/p&gt;
&lt;p&gt;Is there a way in MySQL to cause an operation to &lt;strong&gt;fail or block&lt;/strong&gt; when another connection dies? It&#39;s the other way around! Connections hold locks, and those get released when they die!&lt;/p&gt;
&lt;p&gt;But there&#39;s a way...&lt;/p&gt;
&lt;h3&gt;Three step, safe, optimistic solution&lt;/h3&gt;
&lt;p&gt;Here are the steps to a safe solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C1: &lt;strong&gt;lock tables tbl write;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C2, C3, ..., C17: normal app connections, issuing &lt;strong&gt;insert, delete, update&lt;/strong&gt; on &lt;strong&gt;tbl&lt;/strong&gt;. Because of the lock, they are naturally blocked.&lt;/li&gt;
&lt;li&gt;We apply those last event we need to apply onto &lt;strong&gt;ghost&lt;/strong&gt;. No new events are coming our way because &lt;strong&gt;tbl&lt;/strong&gt; is blocked.&lt;/li&gt;
&lt;li&gt;C18: checking that C1 is still alive, then &lt;strong&gt;rename table tbl to tbl_old&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C19: checking to see that C18&#39;s &lt;strong&gt;rename&lt;/strong&gt; is in place (via &lt;strong&gt;show processlist&lt;/strong&gt;), &lt;strong&gt;and&lt;/strong&gt; that C1 is still alive; then issues: &lt;strong&gt;rename table ghost to tbl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(meanwhile more queries approach &lt;strong&gt;tbl&lt;/strong&gt;, it doesn&#39;t matter, they all get deprioritized, same as C2...C17)&lt;/li&gt;
&lt;li&gt;C1: &lt;strong&gt;unlock tables&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What just happened? Let&#39;s first explain some stuff:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C18&#39;s &lt;strong&gt;rename&lt;/strong&gt; gets prioritized over the DMLs, even though it came later. That is how MySQL prioritizes queries on metadata-locked tables.&lt;/li&gt;
&lt;li&gt;C18 checks C1 is still alive, but as before, there&#39;s always the chance C1 will die just at the wrong time -- we&#39;re going to address that.&lt;/li&gt;
&lt;li&gt;C19 is interested to see that C18 began execution, but potentially C18 will crash by the time C19 actually issues its own &lt;strong&gt;rename&lt;/strong&gt; -- we&#39;re going to address that&lt;/li&gt;
&lt;li&gt;C19&#39;s query sounds weird. At that time &lt;strong&gt;tbl&lt;/strong&gt; still exists. You&#39;d expect it to fail immediately -- but it does not. It&#39;s valid. This is because &lt;strong&gt;tbl&lt;/strong&gt;&#39;s metadata lock is in use.&lt;/li&gt;
&lt;li&gt;C19 gets prioritized over all the DMLs, but is known to be behind C18. The two stay in same order of arrival. So, C18 is known to execute before C19.&lt;/li&gt;
&lt;li&gt;When C1 unlocks, C18 executes first.&lt;/li&gt;
&lt;li&gt;Metadata lock is still in place on &lt;strong&gt;tbl&lt;/strong&gt; even though it doesn&#39;t actually exist, because of C19.&lt;/li&gt;
&lt;li&gt;C19 operates next.&lt;/li&gt;
&lt;li&gt;Finally all the DMLs execute.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What happens on failures?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If C1 dies just as C18 is about to issue the &lt;strong&gt;rename&lt;/strong&gt;, we get an outage: &lt;strong&gt;tbl&lt;/strong&gt; is renamed to &lt;strong&gt;tbl_old&lt;/strong&gt;, and the queries get released and complain the table is just not there.
&lt;ul&gt;
&lt;li&gt;C19 will not initiate because it is executed &lt;strong&gt;after&lt;/strong&gt; C18 and checks that C1 is alive -- which turns to be untrue.&lt;/li&gt;
&lt;li&gt;So we &lt;strong&gt;know&lt;/strong&gt; we have outage, and we quickly &lt;strong&gt;rename tbl_old to tbl;&lt;/strong&gt; and go drink coffee, then begin it all again.&lt;/li&gt;
&lt;li&gt;The outage is unfortunate, but does not put our data in danger.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If C1 happens to die just as C19 is about to issue its &lt;strong&gt;rename&lt;/strong&gt;, there&#39;s no data integrity: at this point we&#39;ve already asserted the tables are in sync. As C1 dies, C18 will immediately rename &lt;strong&gt;tbl&lt;/strong&gt; to &lt;strong&gt;tbl_old&lt;/strong&gt;. An outage will occur, but not for long, because C19 will next issue &lt;strong&gt;rename ghost to tbl&lt;/strong&gt;, and close the gap. We suffered a minor outage, but no rollback. We roll forward.&lt;/li&gt;
&lt;li&gt;If C18 happens to die just as C19 is about to issue its &lt;strong&gt;rename&lt;/strong&gt;, nothing bad happens: C19 is still blocking for as long as C1 is running. We find out C18 died, and release C1. C19 attempts to rename &lt;strong&gt;ghost&lt;/strong&gt; onto &lt;strong&gt;tbl&lt;/strong&gt;, but &lt;strong&gt;tbl&lt;/strong&gt; exists and the query fails. The metadata lock is released and all the queries resume operation on the original &lt;strong&gt;tbl&lt;/strong&gt;. The operation failed but without error. We will need to try the entire cycle again.&lt;/li&gt;
&lt;li&gt;If both C1 and C18 fail at the time C19 is about to begin its &lt;strong&gt;rename&lt;/strong&gt;, same as above.&lt;/li&gt;
&lt;li&gt;If C18 fails as C19 is already in place, same as above.&lt;/li&gt;
&lt;li&gt;If C1 fails as C19 is already in place, it&#39;s as good as having it issue the &lt;strong&gt;unlock tables&lt;/strong&gt;. We&#39;re happy.&lt;/li&gt;
&lt;li&gt;If C19 fails at any given point, we suffer outage. We revert by &lt;code&gt;rename tbl_old to tbl&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This solution relies on the notion that if a previous connection failed, we would not be able to &lt;strong&gt;rename ghost to tbl&lt;/strong&gt; because the table would still be there. That&#39;s what we were looking for; but instead of looking at locks, which get released when a connection terminates, we used a persistent entity: a table.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The algorithm above is &lt;strong&gt;optimistic&lt;/strong&gt;: if no connections get weirdly killed, it&#39;s a valid locking solution, and queries &amp;amp; app are unaware that anything happened (granted, app will notice write latency). If connections do get weirdly killed, we get table-outage at worst case -- an outage that is already considered to be a valid solution anyhow. The algorithm will not allow data corruption.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Solving the Facebook-OSC non-atomic table swap problem</title>
      <link>/blog/mysql/solving-the-facebook-osc-non-atomic-table-swap-problem/</link>
      <pubDate>Tue, 03 May 2016 08:42:07 +0000</pubDate>
      
      <guid>/blog/mysql/solving-the-facebook-osc-non-atomic-table-swap-problem/</guid>
      <description>&lt;p&gt;We present a way to use an atomic, blocking table swap in the Facebook Online-Schema-Change solution, as well as in a rumored, other Online-Schema-rumored-Change solution. &lt;strong&gt;Update&lt;/strong&gt;: also a caveat.&lt;/p&gt;
&lt;h3&gt;Quick recap (really quick)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html&#34;&gt;pt-online-schema-change&lt;/a&gt; and &lt;a href=&#34;https://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932/&#34;&gt;facebook-osc&lt;/a&gt; are two popular online-schema-change solutions for MySQL. They both use triggers, but in different ways. While the Percona tool uses synchronous table updates, such that any &lt;strong&gt;INSERT|UPDATE|DELETE&lt;/strong&gt; on the modified table causes an &lt;strong&gt;INSERT|UPDATE|DELETE&lt;/strong&gt; on a ghost table, in the Facebook tool all cause an &lt;strong&gt;INSERT&lt;/strong&gt; on a changelog table, which is then iterated, read, having entries applied on the ghost table.&lt;/p&gt;
&lt;p&gt;The TL;DR is that DMLs on the table propagate synchronously, within same transaction in the Percona tool, and asynchronously, with lag, in the Facebook tool.&lt;/p&gt;
&lt;h3&gt;What&#39;s the problem with the table swap?&lt;/h3&gt;
&lt;p&gt;In the Percona tool, once the logic is satisfied the copy is complete, we issue this query:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;RENAME TABLE tbl TO tbl_old, tbl_new TO tbl;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is an atomic, two table &lt;strong&gt;RENAME&lt;/strong&gt; operation.&lt;/p&gt;
&lt;p&gt;However with the asynchronous nature of the Facebook tool, such a &lt;strong&gt;RENAME&lt;/strong&gt; would be a mistake. We must first block writes to the modified table, then make sure we have iterated the changelog table to the point of lock, apply those changes onto the ghost table, and only then do the swap.&lt;/p&gt;
&lt;p&gt;The problem is: you cannot &lt;strong&gt;RENAME TABLES&lt;/strong&gt; while one of them is &lt;strong&gt;LOCK&lt;/strong&gt;ed.&lt;/p&gt;
&lt;p&gt;This is silly, and inconsistent, because:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&amp;gt; LOCK TABLES tbl WRITE;
Query OK, 0 rows affected (0.00 sec)

&amp;gt; RENAME TABLE tbl TO tbl_old, tbl_new TO tbl;
ERROR 1192 (HY000): Can&#39;t execute the given command because you have active locked tables or an active transaction

&amp;gt; ALTER TABLE tbl RENAME TO tbl_old;
Query OK, 0 rows affected (0.00 sec)&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Why would the &lt;strong&gt;RENAME&lt;/strong&gt; fail where the &lt;strong&gt;ALTER&lt;/strong&gt; works?&lt;/p&gt;
&lt;p&gt;Small thing, but critical to the operation of the online-schema-change. From the &lt;a href=&#34;https://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932/&#34;&gt;Facebook OSC documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;Since alter table causes an implicit commit in innodb, innodb locks get released after the first alter table. So any transaction that sneaks in after the first alter table and before the second alter table gets a &#39;table not found&#39; error. The second alter table is expected to be very fast though because copytable is not visible to other transactions and so there is no need to wait.&lt;/blockquote&gt;
&lt;h3&gt;What the FB solution means&lt;/h3&gt;
&lt;p&gt;It means for a very brief duration, the table is &lt;em&gt;not there&lt;/em&gt;. Your app will get errors.&lt;/p&gt;
&lt;p&gt;Of course, we &lt;em&gt;should&lt;/em&gt; be able to handle errors anytime, aywhere. But the honest truth is: we (as in &lt;em&gt;the world&lt;/em&gt;) do not. Many apps will fail ungracefully should they get a &lt;em&gt;table not found&lt;/em&gt; error.&lt;/p&gt;
&lt;p&gt;An atomic swap, as compared, would make for briefly blocking operations, making the app ignorant of the swap.&lt;/p&gt;
&lt;h3&gt;Rumor&lt;/h3&gt;
&lt;p&gt;Rumor has it that we at GitHub are developing a new, triggerless, Online Schema Change tool. It is rumored to be based off binary logs and is rumored to have lots of interesting rumored implications.&lt;/p&gt;
&lt;p&gt;Such rumored implementation would have to be asynchronous by nature, or so rumors say. And as such, it would fall for the same non-atomic table swap problem.&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;Once we heard it was rumored we were working on a triggerless online schema change tool, we realized we would have to solve the non-atomic swap problem. What we did was to gossip about it in between ourselves, which led to three different rumors of a solution, eventually manifested as three different working solutions. All three solutions make for blocking queries on the app&#39;s side. I will present one of these solution here, based on voluntary locks.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;The idea is to make a table locked without actually issuing a &lt;strong&gt;LOCK TABLE&lt;/strong&gt; statement, such that we would be able to run a &lt;strong&gt;RENAME TABLE&lt;/strong&gt; operation, that would &lt;em&gt;wait until we say it&#39;s good to complete&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let&#39;s assume:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Our table is &lt;strong&gt;tbl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ghost table (table onto which we&#39;ve actually made the changes) is &lt;strong&gt;tbl_new&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Our app continuously writes to &lt;strong&gt;tbl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;We have &lt;strong&gt;3&lt;/strong&gt; connections on our tables, aptly named &lt;strong&gt;#1&lt;/strong&gt;, &lt;strong&gt;#2&lt;/strong&gt;, &lt;strong&gt;#3&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We issue the following, in this order:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;#1&lt;/strong&gt;:&lt;br /&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT GET_LOCK(&#39;ding&#39;, 0);&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Lock acquired, no problems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;#2&lt;/strong&gt;:&lt;br /&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT RELEASE_LOCK(&#39;ding&#39;) FROM tbl WHERE GET_LOCK(&#39;ding&#39;, 999999)&amp;gt;=0 LIMIT 1;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ignore the &lt;strong&gt;RELEASE_LOCK&lt;/strong&gt; for now, this is merely cleanup. The query attempts to read one row from &lt;strong&gt;tbl&lt;/strong&gt; where &lt;strong&gt;GET_LOCK(&#39;ding&#39;)&amp;gt;=0&lt;/strong&gt;. But &lt;strong&gt;&#39;ding&#39;&lt;/strong&gt; is locked, hence the entire query blocks.&lt;br /&gt;
Otherwise, other queries on &lt;strong&gt;tbl&lt;/strong&gt; (both reads and writes) are running &lt;em&gt;fine&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;#3&lt;/strong&gt;:&lt;br /&gt;
&lt;blockquote&gt;
&lt;pre&gt;RENAME TABLE tbl TO tbl_old, tbl_new TO tbl;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now the magic begins. The &lt;strong&gt;RENAME&lt;/strong&gt; operation cannot proceed while queries are executing on &lt;strong&gt;tbl&lt;/strong&gt;. In particular, it waits on &lt;strong&gt;#2&lt;/strong&gt; to complete. But &lt;strong&gt;#2&lt;/strong&gt; is blocked on &lt;strong&gt;#1&lt;/strong&gt;, so it does not complete. Our &lt;strong&gt;RENAME&lt;/strong&gt; is also blocked!&lt;br /&gt;
There are further two consequences that work to our advantage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Any further incoming &lt;strong&gt;INSERT|UPDATE|DELETE&lt;/strong&gt; on &lt;strong&gt;tbl&lt;/strong&gt; is now unable to proceed; such queries will now wait for the &lt;strong&gt;RENAME&lt;/strong&gt; to complete. So &lt;em&gt;no further updated on &lt;strong&gt;tbl&lt;/strong&gt;&lt;/em&gt; are being applied. App is blocked&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tbl_new&lt;/strong&gt; is &lt;em&gt;nonblocked&lt;/em&gt;! And this is because how &lt;strong&gt;RENAME&lt;/strong&gt; works internally. Since it couldn&#39;t satisfy the first clause, it doesn&#39;t even check for the second, and does not place a &lt;strong&gt;LOCK&lt;/strong&gt; on &lt;strong&gt;tbl_new&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OSC:&lt;br /&gt;
Now that no further writes are possible on &lt;strong&gt;tbl&lt;/strong&gt;, we satisfy ourselves that we&#39;ve iterated to the last of the changelog entries and have applied changes to &lt;strong&gt;tbl_new&lt;/strong&gt;. Exactly how we satisfy ourselves is a matter of implementation. Rumor is that we use a &lt;em&gt;rumor&lt;/em&gt; that the last entry was handled in our rumored solution. That last part is actually not a pun.&lt;br /&gt;
We are now content that all changes have been applied to &lt;strong&gt;tbl_new&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;#1&lt;/strong&gt;:&lt;br /&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT RELEASE_LOCK(&#39;ding&#39;);&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ding!&lt;/strong&gt; Connection &lt;strong&gt;#2&lt;/strong&gt; gets released, reads some row from &lt;strong&gt;tbl&lt;/strong&gt; (but no one is actually interested in the result set) and completes. The &lt;strong&gt;#3 RENAME&lt;/strong&gt; is not blocking on anything anymore. It executes. The tables are swapped. Once they are swapped, any &lt;strong&gt;INSERT|UPDATE|DELETE&lt;/strong&gt;s that were pending on &lt;strong&gt;tbl&lt;/strong&gt; are released and App is unblocked.&lt;br /&gt;
The atomic swap is complete.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Implementation&lt;/h4&gt;
&lt;p&gt;Agony. This workaround is agonizing. Is &lt;em&gt;agonization&lt;/em&gt; a word? By rumor written in Go, our OSC has this implemented via goroutines, and the code is one of those atrocities you are ashamed to look at. Well, it&#39;s OK under the circumstances. But really, implementing this is painful, and actually more complicated than the above description. Why is that?&lt;/p&gt;
&lt;p&gt;In the above we make fro two blocking operations: &lt;strong&gt;#2&lt;/strong&gt; and &lt;strong&gt;#3&lt;/strong&gt;. We must not proceed to &lt;strong&gt;#3&lt;/strong&gt; before &lt;strong&gt;#2&lt;/strong&gt; is applied, and we must not proceed to OSC completion before &lt;strong&gt;#3&lt;/strong&gt; is applied. But how does our code &lt;em&gt;know&lt;/em&gt; that it&#39;s being blocked? If it&#39;s being blocked, it can&#39;t tell me anything, because it&#39;s blocked. If it&#39;s not blocked yet, it can tell me it&#39;s not blocked yet, but I&#39;m really interested in knowing the time it gets blocked.&lt;/p&gt;
&lt;p&gt;But preferably the exact time, or near exact, because one we start blocking, App suffers. Connections accumulate. We really want to make the swap as quick as possible (and by rumor we have a rollback &amp;amp; retry mechanism for this operation if it exceeds &lt;strong&gt;X&lt;/strong&gt; seconds).&lt;/p&gt;
&lt;p&gt;Unfortunately the solution involves polling. That is, Once we issue &lt;strong&gt;#2&lt;/strong&gt; (asynchronously, right? It&#39;s &lt;em&gt;blocking&lt;/em&gt;), we aggressively poll &lt;strong&gt;SHOW PROCESSLIST&lt;/strong&gt; and look for that blocked query. And the same for &lt;strong&gt;#3&lt;/strong&gt;. Polling is a form of necessary ugliness in this flow.&lt;/p&gt;
&lt;p&gt;Other solutions&lt;/p&gt;
&lt;p&gt;The other two solutions do not use a voluntary lock. Instead:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Use a &lt;strong&gt;LOCK&lt;/strong&gt; on some yet another table and a query involving &lt;em&gt;that&lt;/em&gt; table JOINed with &lt;strong&gt;tbl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;SELECT ... FOR UPDATE&lt;/strong&gt; on yet another table followed by a &lt;strong&gt;SELECT&lt;/strong&gt; on the locked row on &lt;em&gt;that&lt;/em&gt; table JOINed with &lt;strong&gt;tbl.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We leave the implementation as an exercise for the reader.&lt;/p&gt;
&lt;h3&gt;Can&#39;t we just make the RENAME work under LOCK?&lt;/h3&gt;
&lt;p&gt;Yeah. That&#39;s what the Facebook people said. &#34;Hey, we can just fix this&#34;.&lt;/p&gt;
&lt;h3&gt;Update: caveat&lt;/h3&gt;
&lt;p&gt;Should connection #1 or connection #2 die unexpectedly before we are satisfied the events have all been applied, the `RENAME` gets unblocked due to the collapse of locks, and we end up with a premature swap of the tables, potentially before we have applied the latest entries from the changelog table. This was noted by my colleague Gillian Gunson, and we keep looking into this.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator progress</title>
      <link>/blog/mysql/orchestrator-progress/</link>
      <pubDate>Wed, 23 Dec 2015 18:01:59 +0000</pubDate>
      
      <guid>/blog/mysql/orchestrator-progress/</guid>
      <description>&lt;p&gt;This comes mostly to reassure, having moved into GitHub: &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt; development continues.&lt;/p&gt;
&lt;p&gt;I will have the privilege of working on this open source solution in GitHub. There are a few directions we can take orchestrator to, and we will be looking into the possibilities. We will continue to strengthen the crash recovery process, and in fact I&#39;ve got a couple ideas on drastically shortening Pseudo-GTID recovery time as well as other debts. We will look into yet other directions, which we will share. My new and distinguished team will co-work on/with orchestrator and will no doubt provide useful and actionable input.&lt;/p&gt;
&lt;p&gt;Orchestrator continues to be open for pull requests, with a temporal latency in response time (it&#39;s the Holidays, mostly).&lt;/p&gt;
&lt;p&gt;Some Go(lang) limitations (namely the import path, I&#39;ll blog more about it) will most probably imply some changes to the code, which will be well communicated to existing collaborators.&lt;/p&gt;
&lt;p&gt;Most of all, we will keep orchestrator a generic solution, while keeping focus on what we think is most important - and there&#39;s some interesting vision here. Time will reveal as we make progress.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Joining GitHub</title>
      <link>/blog/general/joining-github/</link>
      <pubDate>Mon, 30 Nov 2015 17:26:24 +0000</pubDate>
      
      <guid>/blog/general/joining-github/</guid>
      <description>&lt;p&gt;Today was my last day at &lt;strong&gt;Booking.com&lt;/strong&gt;, and shortly I will be joining the team at &lt;strong&gt;GitHub&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I&#39;d like to thank the many kind, friendly &amp;amp; smart people I&#39;ve worked with at Booking.com!&lt;/p&gt;
&lt;p&gt;The challenges at Booking.com are big. There is such a diversity within the technology stack; even within the database range. A solution that &lt;em&gt;works&lt;/em&gt; on all the various Booking.com production environments is something to value. Indeed, the Booking.com Production environment it is an amazing playground for developers, offering high volume, large numbers, and differing workloads to tackle. Your code just gets hammered down and you get very quick feedback on whether you did it right or wrong.&lt;/p&gt;
&lt;p&gt;I was happy to have worked on serious reliability and operational topics, and to have made a meaningful contribution.&lt;/p&gt;
&lt;p&gt;Joining GitHub, I&#39;m to be a systems engineer in a great team (friends included), building great products, in and around the database zone, delivering open source, pretty much expecting to do awesome stuff! That, and the swag.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orchestrator visual cheatsheet, TL;DR the &#34;smart&#34; way</title>
      <link>/blog/mysql/orchestrator-visual-cheatsheet-tldr-the-smart-way/</link>
      <pubDate>Wed, 02 Sep 2015 09:14:05 +0000</pubDate>
      
      <guid>/blog/mysql/orchestrator-visual-cheatsheet-tldr-the-smart-way/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt;&lt;/strong&gt; is &lt;em&gt;really&lt;/em&gt; growing. And the amount of users (DBAs, sys admins) using it is growing. Which gives me a lot of immediate feedback in the form of &lt;em&gt;&#34;Look, there&#39;s just too many options to move slaves around! Which ones should we use?&#34;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;TL;DR look at the two visualized commands below&lt;/h3&gt;
&lt;p&gt;They are enough&lt;/p&gt;
&lt;h3&gt;The &#34;smart&#34; commands to end all commands&lt;/h3&gt;
&lt;p&gt;So all relocation commands are important, and give you fine-grained, pin-pointed control of the method of topology refactoring. However, most of the time you &lt;em&gt;just want to move those servers around&lt;/em&gt;. Which is why there&#39;s a new &#34;smart&#34; mode which support these two commands, which you should be happy using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;relocate&lt;/strong&gt;: move a single slave to another position&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;relocate-slaves&lt;/strong&gt;: move all/some slaves of some server to another position.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What makes these commands Smart? You can move slaves around from &lt;em&gt;anywhere&lt;/em&gt; to &lt;em&gt;anywhere&lt;/em&gt;. And &lt;em&gt;orchestrator&lt;/em&gt; figures out the bast execution path. If possible, it uses GTID. Not possible? Is Pseudo-GTID available? Great, using Pseudo-GTID. Oh, are there binlog servers involved? Really simple, use them. None of the above? &lt;em&gt;Orchestrator&lt;/em&gt; will use &#34;standard&#34; binlog file:pos math (with limitations). &lt;em&gt;Orchestrator&lt;/em&gt; will even figure out if multiple steps are necessary and will combine any of the above.&lt;/p&gt;
&lt;p&gt;So you don&#39;t have to remember all the possible ways and options. The visual cheatsheet now boils down to these two:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-cheatsheet-visualized-relocate.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7357&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-relocate.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-relocate&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-cheatsheet-visualized-relocate-slaves.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7350&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-relocate-slaves.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-relocate-slaves&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s take a slightly deeper look&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;relocate&lt;/h3&gt;
&lt;p&gt;Moves a single slave &lt;strong&gt;X&lt;/strong&gt; from any point to replicate another some server &lt;strong&gt;Z&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As usual, &lt;em&gt;orchestrator&lt;/em&gt; first confirms that &lt;strong&gt;X&lt;/strong&gt; &lt;em&gt;can&lt;/em&gt; replicate from &lt;strong&gt;Z&lt;/strong&gt; (&lt;strong&gt;Z&lt;/strong&gt; has &lt;strong&gt;log-slave-updates&lt;/strong&gt; or is a binlog server; binlog format compatible, etc.)&lt;/li&gt;
&lt;li&gt;With GTID/Pseudo-GTID, move from any point to any point&lt;/li&gt;
&lt;li&gt;With binlog servers, move around the binlog server environment (at this point you are not using binlog servers, so ignore)&lt;/li&gt;
&lt;li&gt;With normal replication, requires an &#34;atomic&#34; operation: either move the slave one level up, or make it replicate from a sibling.&lt;/li&gt;
&lt;li&gt;You can &lt;em&gt;relocate&lt;/em&gt; the same master, effectively repointing the slave back to its existing position. This serves to re-resolve master hostname; to reset relay logs; to verify slave is aligned with master.&lt;/li&gt;
&lt;li&gt;Or combination of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;relocate-slaves&lt;/h3&gt;
&lt;p&gt;Moves multiple slaves of server &lt;strong&gt;X&lt;/strong&gt; to replicate from some other server &lt;strong&gt;W&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By default moves all slaves of &lt;strong&gt;X&lt;/strong&gt;, where possible&lt;/li&gt;
&lt;li&gt;Each slave verified to be able to replicate from &lt;strong&gt;W&lt;/strong&gt;. Those that can&#39;t are left behind.&lt;/li&gt;
&lt;li&gt;Can filter using regular expression via &lt;strong&gt;--pattern=some?[reg]ex&lt;/strong&gt; on slave hostnames&lt;/li&gt;
&lt;li&gt;Can relocate under same master, effectively repointing all slaves (see above explanation)&lt;/li&gt;
&lt;li&gt;Can relocate below one of the very slaves of X. If Y is in itself a slave of X and you&#39;re executing:&lt;br /&gt;
&lt;strong&gt;orchestrator -c relocate-slaves -i X -d Y&lt;/strong&gt;&lt;br /&gt;
then &lt;strong&gt;Y&lt;/strong&gt; is excluded from the list of relocated slaves. This effectively means &#34;make &lt;strong&gt;Y&lt;/strong&gt; local master of its current siblings&#34;. Very cool stuff.&lt;/li&gt;
&lt;li&gt;When binlog servers involved, simple math-less repointing takes place&lt;/li&gt;
&lt;li&gt;When GTID involved, let MySQL/MariaDB (both supported) do the math on a per-server basis&lt;/li&gt;
&lt;li&gt;When Pseudo-GTID involved, &lt;em&gt;greatly&lt;/em&gt; optimize by dividing into &lt;a href=&#34;https://en.wikipedia.org/wiki/Equivalence_class&#34;&gt;equivalence classes&lt;/a&gt; and only doing the math on a representative of each class.&lt;/li&gt;
&lt;li&gt;Or combination of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What about the other commands?&lt;/h3&gt;
&lt;p&gt;The above covers such commands as &lt;strong&gt;move-up&lt;/strong&gt;, &lt;strong&gt;move-below&lt;/strong&gt;, &lt;strong&gt;repoint&lt;/strong&gt;, &lt;strong&gt;repoint-slaves&lt;/strong&gt;, &lt;strong&gt;match-below&lt;/strong&gt;, &lt;strong&gt;multi-match-slaves&lt;/strong&gt;, &lt;strong&gt;regroup-slaves&lt;/strong&gt; and more. It does not cover &lt;strong&gt;enslave-master&lt;/strong&gt; and &lt;strong&gt;make-co-master&lt;/strong&gt; which are a bit different.&lt;/p&gt;
&lt;p&gt;My guess is you can pass &lt;strong&gt;98%&lt;/strong&gt; of your operations with &lt;strong&gt;relocate &lt;/strong&gt;and &lt;strong&gt;relocate-slaves&lt;/strong&gt;. Otherwise just run &lt;em&gt;orchestrator&lt;/em&gt; with no arguments nor options to get a full-blown breakdown of available commands.&lt;/p&gt;
&lt;h3&gt;GUI drag-n-drop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;relocate-slaves&lt;/strong&gt; is achieved by dragging the slaves of an instance on top of a new master, as follows:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-before.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7372&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-before.png&#34; alt=&#34;orchestrator-relocate-slaves-before&#34; width=&#34;994&#34; height=&#34;369&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-hover.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7373&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-hover.png&#34; alt=&#34;orchestrator-relocate-slaves-hover&#34; width=&#34;996&#34; height=&#34;339&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-drag1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7377&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-drag1.png&#34; alt=&#34;orchestrator-relocate-slaves-drag&#34; width=&#34;980&#34; height=&#34;363&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-after.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7375&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-after.png&#34; alt=&#34;orchestrator-relocate-slaves-after&#34; width=&#34;993&#34; height=&#34;345&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Find latest &lt;em&gt;orchestrator&lt;/em&gt; release at &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;https://github.com/outbrain/orchestrator/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.4.340: GTID, binlog servers, Smart Mode, failovers and lots of goodies</title>
      <link>/blog/mysql/orchestrator-1-4-340-gtid-binlog-servers-smart-mode-failovers-and-lots-of-goodies/</link>
      <pubDate>Tue, 01 Sep 2015 12:10:15 +0000</pubDate>
      
      <guid>/blog/mysql/orchestrator-1-4-340-gtid-binlog-servers-smart-mode-failovers-and-lots-of-goodies/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;&lt;strong&gt;Orchestrator&lt;/strong&gt; 1.4.340 is released&lt;/a&gt;. Not quite competing with the MySQL latest changelog, and as I haven&#39;t blogged about &lt;em&gt;orchestrator&lt;/em&gt; featureset in a while, this is a quick listing of &lt;em&gt;orchestrator&lt;/em&gt; features available since my last publication:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Supports &lt;strong&gt;GTID&lt;/strong&gt; (Oracle &amp;amp; MariaDB)
&lt;ul&gt;
&lt;li&gt;GTID still not being used in automated recovery -- in progress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable-gtid&lt;/strong&gt;, &lt;strong&gt;disable-gtid&lt;/strong&gt;, &lt;strong&gt;skip-query&lt;/strong&gt; for GTID commands&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Supports &lt;strong&gt;binlog servers&lt;/strong&gt; (MaxScale)
&lt;ul&gt;
&lt;li&gt;Discovery &amp;amp; operations on binlog servers&lt;/li&gt;
&lt;li&gt;Understanding slave repositioning in a binlog-server architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart mode&lt;/strong&gt;: relocate &amp;amp; relocate-below commands (or Web/GUI drag-n-drop) let &lt;em&gt;orchestrator&lt;/em&gt; figure out the best way of slave repositioning. &lt;em&gt;Orchestrator&lt;/em&gt; picks from GTID, Pseudo GTID, binlog servers, binlog file:pos math (and more) options, or combinations of the above. Fine grained commands still there, but mostly you won&#39;t need them.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Crash recoveries&lt;/strong&gt; (did you know &lt;em&gt;orchestrator&lt;/em&gt; does that?):
&lt;ul&gt;
&lt;li&gt;For intermediate master recovery: improved logic in picking the best recovery plan (prefer in-DC, prefer promoting local slave, supporting binlog server topologies, ...)&lt;/li&gt;
&lt;li&gt;For master recovery: even better slave promotion; supports &lt;em&gt;candidate slaves &lt;/em&gt;(prefer promoting such slaves); supports binlog server shared topologies&lt;/li&gt;
&lt;li&gt;Better auditing and logging of recovery cases&lt;/li&gt;
&lt;li&gt;Better analysis of crash scenarios, also in the event of lost VIPs, hanging connections; emergent checks in crash suspected scenarios&lt;/li&gt;
&lt;li&gt;recover-lite: do all topology-only recovery steps, without invoking external processes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better browser support&lt;/strong&gt;: used to only work on Firefox and Chrome (and the latter has had issues), the Web UI should now work well on all browsers, at the cost of reduced &lt;strong&gt;d3&lt;/strong&gt; animation. More work still in progress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Faster&lt;/strong&gt;, more parallel, less blocking operations on all counts; removed a lots of serialized code; less locks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web enhancements&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;More verbose drag-n-drop (operation hint; color hints)&lt;/li&gt;
&lt;li&gt;Drag-n-drop for &lt;em&gt;slaves-of-a-server&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Replication/crash analysis dashboard&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pools&lt;/strong&gt;: &lt;em&gt;orchestrator&lt;/em&gt; can be &lt;em&gt;told&lt;/em&gt; about instance-to-pool association (&lt;strong&gt;submit-pool-instances&lt;/strong&gt; command)
&lt;ul&gt;
&lt;li&gt;And can then present pool status (web)&lt;/li&gt;
&lt;li&gt;Or pool hints within topologies (web)&lt;/li&gt;
&lt;li&gt;Or queried for all pools (&lt;strong&gt;cluster-pool-instances&lt;/strong&gt; command)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other:
&lt;ul&gt;
&lt;li&gt;Supports MySQL &lt;strong&gt;5.7&lt;/strong&gt; (tested with &lt;strong&gt;5.7.8&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Configurable graphite path for metrics&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--noop&lt;/strong&gt; flag; does all the work except for actually changing master on slaves. Shows intentions.&lt;/li&gt;
&lt;li&gt;Web (or cli &lt;strong&gt;which-cluster-osc-slaves&lt;/strong&gt; command) provide list of control slaves to use in &lt;strong&gt;pt-osc&lt;/strong&gt; operation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hostname-unresolve&lt;/strong&gt;: force &lt;em&gt;orchestrator&lt;/em&gt; to unresolve a fqdn into VIP/CNAME/... when issuing a CHANGE MASTER TO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3rd party contributions (hey, thanks!) include:
&lt;ul&gt;
&lt;li&gt;More &amp;amp; better SSL support&lt;/li&gt;
&lt;li&gt;Vagrant templates&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For developers:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Orchestrator&lt;/em&gt; now go-gettable. Just &lt;strong&gt;go get github.com/outbrain/orchestrator&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Improved build script; supports more architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Also consider these manuals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual&#34;&gt;The Orchestrator Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-deployment&#34;&gt;Orchestrator deployment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-first-steps&#34;&gt;Orchestrator first steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-for-developers&#34;&gt;Orchestrator for developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; is free and open source (Apache 2.0 License).&lt;/p&gt;
&lt;p&gt;I&#39;ll be &lt;a href=&#34;https://www.percona.com/live/europe-amsterdam-2015/sessions/managing-and-visualizing-your-replication-topologies-orchestrator&#34;&gt;speaking about orchestrator in PerconaLive Amsterdam&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>&#34;awesome-mysql&#34; curated list created, open for pull requests</title>
      <link>/blog/mysql/awesome-mysql-curated-list-created-open-for-pull-requests/</link>
      <pubDate>Tue, 28 Apr 2015 14:48:30 +0000</pubDate>
      
      <guid>/blog/mysql/awesome-mysql-curated-list-created-open-for-pull-requests/</guid>
      <description>&lt;p&gt;Following up on popular &lt;em&gt;&#34;awesome-*&#34;&lt;/em&gt; lists (e.g. &lt;a href=&#34;https://github.com/vinta/awesome-python&#34;&gt;awesome-python&lt;/a&gt;, &lt;a href=&#34;https://github.com/avelino/awesome-go&#34;&gt;awesome-golang&lt;/a&gt; etc.), I&#39;ve created the &lt;strong&gt;&lt;a href=&#34;https://github.com/shlomi-noach/awesome-mysql&#34;&gt;awesome-mysql&lt;/a&gt;&lt;/strong&gt; curated list.&lt;/p&gt;
&lt;p&gt;This is a list of technologies (and resources) in and around MySQL, and means to serve as a place to find reliable software and info. I recently happened to notice there are some tools I&#39;m familiar with that are unknown to others; tools unknown to me that are in good use.&lt;/p&gt;
&lt;p&gt;The list is naturally and intentionally incomplete. I wish this to be a community based creation; so I put some categories and some tools. I left many out, &lt;em&gt;deliberatey&lt;/em&gt;. Please assist by filling in the missing projects, tools, libraries! Additions gladly accepted via pull-requests. Do note the &lt;a href=&#34;https://github.com/shlomi-noach/awesome-mysql/blob/master/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt; (somewhat lengthy, I apologize).&lt;/p&gt;
&lt;p&gt;I will moderate FUDs, promotional, commercials etc., and otherwise it may take some days for me to merge requests.&lt;/p&gt;
&lt;p&gt;The work is licensed under the &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Percona Live 2015: Reflections; the Apache CCLA offer</title>
      <link>/blog/mysql/percona-live-2015-reflections-the-apache-ccla-offer/</link>
      <pubDate>Sat, 18 Apr 2015 03:11:56 +0000</pubDate>
      
      <guid>/blog/mysql/percona-live-2015-reflections-the-apache-ccla-offer/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Facebook, Google, Twitter, LinkedIn, Alibaba, MariaDB, Percona team up and offer Oracle all public changes under the &lt;a href=&#34;https://www.apache.org/licenses/cla-corporate.txt&#34;&gt;Apache CCLA&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Read again please.&lt;/p&gt;
&lt;p&gt;My one word summary of this is: Romantic. In the most positive sense.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Disclaimer: I am not a lawyer; this is my understanding of the current status and of the offer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Summarizing the deal: the teams participating with WebScaleSQL would like to push code upstream. Current legal issues limit their options. Existing patches/contributions from Percona &amp;amp; MariaDB are licensed by GPLv2, which Oracle cannot import as it distributes a commercial, closed source, edition, in addition to its open source MySQL community edition.&lt;/p&gt;
&lt;p&gt;So what happens is that there is a lot of free code, great patches, new features out there, that are only available via MariaDB or WebscaleSQL or Percona Server, but not in the Oracle MySQL code base. This, in turn, means Oracle re-implements many features originating from said companies. And, more importantly, said companies need to routinely rebase their code on new Oracle releases, repeating tedious work.&lt;/p&gt;
&lt;p&gt;The offer is that Oracle agrees to the Apache CCLA as a license by which it would be able to incorporate contributions. Oracle would then be able to use incorporated code in both open source and commercial edition. Oracle will choose what code to incorporate; hopefully many patches will be accepted upstream, and the community will benefit from a rich featureset, rapid developed MySQL server.&lt;/p&gt;
&lt;p&gt;Clearly a lot of work, persuasion, lawyer time, discussions etc. have been invested in this effort. I would like to add my humble &lt;strong&gt;+1/like/favorite/whathaveyou&lt;/strong&gt;. You may add yours by letting Oracle know your opinion on the subject. Media tools are great for this.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Speaking at Percona Live: Pseudo GTID and Easy Replication Topology Management</title>
      <link>/blog/mysql/speaking-at-percona-live-pseudo-gtid-and-easy-replication-topology-management/</link>
      <pubDate>Tue, 31 Mar 2015 17:42:21 +0000</pubDate>
      
      <guid>/blog/mysql/speaking-at-percona-live-pseudo-gtid-and-easy-replication-topology-management/</guid>
      <description>&lt;p&gt;In two weeks time I will be presenting &lt;a href=&#34;https://www.percona.com/live/mysql-conference-2015/sessions/pseudo-gtid-and-easy-replication-management&#34;&gt;Pseudo GTID and Easy Replication Topology Management&lt;/a&gt; at Percona Live. From the time I submitted the proposal a LOT has been developed, experimented, deployed and used with both &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; and with &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;. In my talk I will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suggest that you skip the &#34;to GTID or not to GTID&#34; question and go for the lightweight Pseudo GTID&lt;/li&gt;
&lt;li&gt;Show how Pseudo GTID is used in production to recover from various replication failures and server crashes&lt;/li&gt;
&lt;li&gt;Do an outrageous demonstration&lt;/li&gt;
&lt;li&gt;Tell you about 50,000 successful experiments and tests done in production&lt;/li&gt;
&lt;li&gt;Show off orchestrator and its support for Pseudo GTID, including automated crash analysis and recovery mechanism.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will further show how the orchestrator tooling makes for a less restrictive, more performant, less locking, non-intrusive, trusted and lightweight replication topology management solution.&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/03/orchestrator-topology-simple.png&#34;&gt;&lt;img class=&#34;wp-image-7206 size-full&#34; src=&#34;/blog/blog/assets/orchestrator-topology-simple.png&#34; alt=&#34;orchestrator-topology-simple&#34; width=&#34;1010&#34; height=&#34;286&#34; /&gt;&lt;/a&gt; An anonymized topology&lt;/blockquote&gt;
&lt;p&gt;Please come by my talk! &lt;/p&gt;
&lt;p&gt;Slides: &lt;/p&gt;
&lt;p&gt;[speakerdeck https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management]&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.2.9 GA released</title>
      <link>/blog/mysql/orchestrator-1-2-9-ga-released/</link>
      <pubDate>Thu, 18 Dec 2014 18:24:59 +0000</pubDate>
      
      <guid>/blog/mysql/orchestrator-1-2-9-ga-released/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt; &lt;strong&gt;1.2.9 GA&lt;/strong&gt; &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases/tag/v1.2.9&#34;&gt;has been released&lt;/a&gt;. Noteworthy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Added &#34;&lt;strong&gt;ReadOnly&lt;/strong&gt;&#34; (true/false) configuration param. You can have orchestrator completely read-only&lt;/li&gt;
&lt;li&gt;Added &lt;strong&gt;&#34;AuthenticationMethod&#34;: &#34;multi&#34;&lt;/strong&gt;: works like BasicAuth (your normal HTTP user+password) only it also accepts the special user called &lt;strong&gt;&#34;readonly&#34;&lt;/strong&gt;, which, surprise, can only view and not modify&lt;/li&gt;
&lt;li&gt;Centralized/serialized most backend database writes (with hundreds/thousands monitored servers it was possible or probable that high concurrency led to too-many-connections openned on the backend database).&lt;/li&gt;
&lt;li&gt;Fixed evil evil bug that would skip some checks if binary logs were not enabled&lt;/li&gt;
&lt;li&gt;Better hostname resolve (now also asking MySQL server to resolve hostname; resolving is cached)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pseudo-GTID&lt;/strong&gt; (read &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;http://code.openark.org/blog/mysql/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topologies-with-pseudo-gtid-a-visual-tour&#34;&gt;here&lt;/a&gt;) support now considered stable (apart from being tested it has already been put to practice multiple times in production at &lt;strong&gt;Outbrain&lt;/strong&gt;, in different planned and unplanned crash scenarios)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I continue developing &lt;em&gt;orchestrator&lt;/em&gt; as free and open source at my new employer, &lt;a href=&#34;http://www.booking.com&#34;&gt;Booking.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.2.1 BETA: Pseudo GTID support, reconnect slaves even after master failure</title>
      <link>/blog/mysql/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure/</link>
      <pubDate>Mon, 27 Oct 2014 11:51:51 +0000</pubDate>
      
      <guid>/blog/mysql/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure/</guid>
      <description>&lt;p&gt;&lt;em&gt;orchestrator&lt;/em&gt; &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases/tag/v1.2.1-beta&#34;&gt;1.2.1 BETA is released&lt;/a&gt;. This version supports &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt;, and provides one with powerful refactoring of one&#39;s replication topologies, even across failed instances.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-begin-drag.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7101&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-begin-drag-1024x292.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-begin-drag&#34; width=&#34;1024&#34; height=&#34;292&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Depicted: moving a slave up the topology even though its local master is inaccessible&lt;/blockquote&gt;
&lt;h4&gt;Enabling Pseudo-GTID&lt;/h4&gt;
&lt;p&gt;You will need to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Inject a periodic unique entry onto your binary logs&lt;/li&gt;
&lt;li&gt;Configure &lt;em&gt;orchestrator&lt;/em&gt; to recognize said entry.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Pseudo GTID injection example&lt;/h4&gt;
&lt;p&gt;We will use the &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.5/en/events.html&#34;&gt;event scheduler&lt;/a&gt; (must be enabled) to inject an entry every &lt;strong&gt;10&lt;/strong&gt; seconds, recognized both in statement-based and row-based replication.&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;create database if not exists meta;

drop event if exists meta.create_pseudo_gtid_view_event;

delimiter ;;
create event if not exists
  meta.create_pseudo_gtid_view_event
  on schedule every 10 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @pseudo_gtid := uuid();
      set @_create_statement := concat(&#39;create or replace view meta.pseudo_gtid_view as select 
&lt;/blockquote&gt;
Make sure to enable &lt;em&gt;event_scheduler&lt;/em&gt; in your &lt;strong&gt;my.cnf&lt;/strong&gt; config file.
An entry in the binary logs would look like this:&lt;!--more--&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql [localhost] {msandbox} (meta) &amp;gt; show binlog events in &#39;mysql-bin.000002&#39; LIMIT 2,1;
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                                                                                                                                                                                               |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000002 | 388 | Query      |         1 |         669 | use `meta`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_view` AS select &#39;2f6ad653-5db3-11e4-b91d-3c970ea31ea8&#39; as pseudo_gtid_unique_val from dual |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entry will be unique, and orchestrator will be able to find it in the binary log if configured with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;{
    ...
    &#34;PseudoGTIDPattern&#34;: &#34;CREATE OR REPLACE .*? VIEW `pseudo_gtid_view` AS select&#34;
}&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The value of &lt;strong&gt;&#34;PseudoGTIDPattern&#34;&lt;/strong&gt; is a regular expression which must match the Pseudo GTID entries in the binary log, and &lt;em&gt;nothing but those entries&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Pre-release&lt;/h4&gt;
&lt;p&gt;This is BETA quality; though I have high confidence in its safety: the process of matching the binary log entries makes for a self-validating mechanism. The process will abort on any mismatch or uncertainty.&lt;/p&gt;
&lt;p&gt;Still there can be use cases I haven&#39;t encountered yet. You input is appreciated!&lt;/p&gt;
&#39;, @pseudo_gtid, &#39;
&lt;/blockquote&gt;
&lt;p&gt;Make sure to enable &lt;em&gt;event_scheduler&lt;/em&gt; in your &lt;strong&gt;my.cnf&lt;/strong&gt; config file.&lt;/p&gt;
&lt;p&gt;An entry in the binary logs would look like this:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql [localhost] {msandbox} (meta) &amp;gt; show binlog events in &#39;mysql-bin.000002&#39; LIMIT 2,1;
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                                                                                                                                                                                               |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000002 | 388 | Query      |         1 |         669 | use `meta`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_view` AS select &#39;2f6ad653-5db3-11e4-b91d-3c970ea31ea8&#39; as pseudo_gtid_unique_val from dual |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entry will be unique, and orchestrator will be able to find it in the binary log if configured with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;{
    ...
    &#34;PseudoGTIDPattern&#34;: &#34;CREATE OR REPLACE .*? VIEW `pseudo_gtid_view` AS select&#34;
}&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The value of &lt;strong&gt;&#34;PseudoGTIDPattern&#34;&lt;/strong&gt; is a regular expression which must match the Pseudo GTID entries in the binary log, and &lt;em&gt;nothing but those entries&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Pre-release&lt;/h4&gt;
&lt;p&gt;This is BETA quality; though I have high confidence in its safety: the process of matching the binary log entries makes for a self-validating mechanism. The process will abort on any mismatch or uncertainty.&lt;/p&gt;
&lt;p&gt;Still there can be use cases I haven&#39;t encountered yet. You input is appreciated!&lt;/p&gt;
 as pseudo_gtid_unique_val from dual&#39;);
      PREPARE st FROM @_create_statement;
      EXECUTE st;
      DEALLOCATE PREPARE st;
    end
;;

delimiter ;

set global event_scheduler := 1;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Make sure to enable &lt;em&gt;event_scheduler&lt;/em&gt; in your &lt;strong&gt;my.cnf&lt;/strong&gt; config file.&lt;/p&gt;
&lt;p&gt;An entry in the binary logs would look like this:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql [localhost] {msandbox} (meta) &amp;gt; show binlog events in &#39;mysql-bin.000002&#39; LIMIT 2,1;
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                                                                                                                                                                                               |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000002 | 388 | Query      |         1 |         669 | use `meta`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_view` AS select &#39;2f6ad653-5db3-11e4-b91d-3c970ea31ea8&#39; as pseudo_gtid_unique_val from dual |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entry will be unique, and orchestrator will be able to find it in the binary log if configured with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;{
    ...
    &#34;PseudoGTIDPattern&#34;: &#34;CREATE OR REPLACE .*? VIEW `pseudo_gtid_view` AS select&#34;
}&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The value of &lt;strong&gt;&#34;PseudoGTIDPattern&#34;&lt;/strong&gt; is a regular expression which must match the Pseudo GTID entries in the binary log, and &lt;em&gt;nothing but those entries&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Pre-release&lt;/h4&gt;
&lt;p&gt;This is BETA quality; though I have high confidence in its safety: the process of matching the binary log entries makes for a self-validating mechanism. The process will abort on any mismatch or uncertainty.&lt;/p&gt;
&lt;p&gt;Still there can be use cases I haven&#39;t encountered yet. You input is appreciated!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>orchestrator 1.1.18: new features, support for orchestrator-agent</title>
      <link>/blog/mysql/orchestrator-1-1-18-new-features-support-for-orchestrator-agent/</link>
      <pubDate>Mon, 13 Oct 2014 15:00:35 +0000</pubDate>
      
      <guid>/blog/mysql/orchestrator-1-1-18-new-features-support-for-orchestrator-agent/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain&#34;&gt;Outbrain&lt;/a&gt;&#39;s &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;&lt;strong&gt;orchestrator 1.1.18&lt;/strong&gt;&lt;/a&gt; is released:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support for &lt;a href=&#34;https://github.com/outbrain/orchestrator-agent&#34;&gt;&lt;strong&gt;orchestrator-agent&lt;/strong&gt;&lt;/a&gt; (see &lt;a href=&#34;http://code.openark.org/blog/mysql/announcing-orchestrator-agent&#34;&gt;announcement&lt;/a&gt;): agent pages, support for agent actions, initiation of seeds (provisioning of new/corrupted servers), auditing of seeds.&lt;/li&gt;
&lt;li&gt;Clusters dashboard&lt;/li&gt;
&lt;li&gt;Support for long query auditing&lt;/li&gt;
&lt;li&gt;SSL&lt;/li&gt;
&lt;li&gt;Proxy authentication (e.g. apache2 serving as reverse-proxy with LDAP)&lt;/li&gt;
&lt;li&gt;User control&lt;/li&gt;
&lt;li&gt;Better slave moving rules.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quick links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Get &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases/tag/v1.1.18&#34;&gt;&lt;strong&gt;orchestrator 1.1.18&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Read the &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual&#34;&gt;orchestrator manual&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Check out &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator-agent&#34;&gt;orchestrator-agent&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;orchestrator&lt;/em&gt; now allows for seeding/provisioning of servers via &lt;em&gt;orchestrator-agent&lt;/em&gt;. It communicates with agents executing on the MySQL hosts and coordinate transfer of data between them. orchestrator now supports invocation and auditing of seeding operations, and protects you from breaking your seeds. The &lt;em&gt;orchestrator-agent&lt;/em&gt; is a solution to Outbrain&#39;s specific use case, and may not appeal to the greater crowd. Nonetheless it is extendible and is released as open source.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;A nice overview of all topologies is provided in the &lt;em&gt;clusters &amp;gt; dashboard&lt;/em&gt; page. The dashboard points out the clusters, amount of servers per cluster, and amount and type of problems per cluster. It also provides configurable aliasing to your clusters, so you may name your &lt;strong&gt;mysql01.myservice.mydomain.com:3306&lt;/strong&gt; as &lt;strong&gt;&#34;customer db&#34;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;orchestrator will list each instance&#39;s long running queries in its own backend database, and will present the user with such data. It also provides with a &#34;&lt;strong&gt;kill query&#34;&lt;/strong&gt; functionality (do note that polling for long running queries is done once per minute only).&lt;/p&gt;
&lt;p&gt;SSL is supported in agents communication.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;orchestrator&lt;/em&gt; now accepts proxy authentication (configurable). This lets you put, for example, apache2 as reverse proxy, which communicates with LDAP and authenticates access. The authenticated user is then relayed to orchestrator. With this method of authentication you are now able to pre-define &#34;power users&#34;. In this authentication mode orchestrator will limit user actions to read-only, unless the user is a power-user. Thus, viewing the topologies is open to everyone, but moving slaves around is limited to a smaller group of people. &lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual#security&#34;&gt;Read more&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You may now move up a slave if it&#39;s master is in stopped-slave state, which allows extracting good, healthy slaves from underneath busy, slow relay-slaves.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;orchestrator&lt;/em&gt; is released by &lt;a href=&#34;http://www.outbrain.com/&#34;&gt;Outbrain&lt;/a&gt; under the &lt;a href=&#34;https://github.com/outbrain/orchestrator/blob/master/LICENSE&#34;&gt;Apache 2.0 license&lt;/a&gt;, and is free to use.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
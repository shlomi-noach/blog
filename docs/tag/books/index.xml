<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Books on code.openark.org</title>
    <link>/blog/tag/books/</link>
    <description>Recent content in Books on code.openark.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Tue, 01 Dec 2009 10:25:00 +0000</lastBuildDate>
    <atom:link href="/blog/tag/books/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>On restoring a single table from mysqldump</title>
      <link>/blog/mysql/on-restoring-a-single-table-from-mysqldump/</link>
      <pubDate>Tue, 01 Dec 2009 10:25:00 +0000</pubDate>
      
      <guid>/blog/mysql/on-restoring-a-single-table-from-mysqldump/</guid>
      <description>&lt;p&gt;Following &lt;a href=&#34;http://everythingmysql.ning.com/profiles/blogs/restore-one-table-from-an-all&#34;&gt;Restore one table from an ALL database dump&lt;/a&gt; and &lt;a href=&#34;http://gtowey.blogspot.com/2009/11/restore-single-table-from-mysqldump.html&#34;&gt;Restore a Single Table From mysqldump&lt;/a&gt;, I would like to add my own thoughts and comments on the subject.&lt;/p&gt;
&lt;p&gt;I also wish to note performance issues with the two suggested solutions, and offer improvements.&lt;/p&gt;
&lt;h4&gt;Problem relevance&lt;/h4&gt;
&lt;p&gt;While the problem is interesting, I just want to note that it is relevant in very specific database dimensions. Too small - and it doesn&#39;t matter how you solve it (e.g. just open vi/emacs and copy+paste). Too big - and it would not be worthwhile to restore from &lt;em&gt;mysqldump&lt;/em&gt; anyway. I would suggest that the problem is interesting in the whereabouts of a few dozen GB worth of data.&lt;/p&gt;
&lt;h4&gt;Problem recap&lt;/h4&gt;
&lt;p&gt;Given a dump file (generated by mysqldump), how do you restore a single table, without making any changes to other tables?&lt;/p&gt;
&lt;p&gt;Let&#39;s review the two referenced solutions. I&#39;ll be using the &lt;a href=&#34;http://dev.mysql.com/doc/employee/en/employee.html&#34;&gt;employees db&lt;/a&gt; on &lt;a href=&#34;https://launchpad.net/mysql-sandbox&#34;&gt;mysql-sandbox&lt;/a&gt; for testing. I&#39;ll choose a very small table to restore: &lt;strong&gt;departments&lt;/strong&gt; (only a few rows in this table).&lt;/p&gt;
&lt;h4&gt;Security based solution&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://everythingmysql.ning.com/profiles/blogs/restore-one-table-from-an-all&#34;&gt;&lt;strong&gt;Chris&lt;/strong&gt;&lt;/a&gt; offers to create a special purpose account, which will only have write (CREATE, INSERT, etc.) privileges on the particular table to restore. Cool hack! But, I&#39;m afraid, not too efficient, for two reasons:&lt;span id=&#34;more-1630&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL needs to process all irrelevant queries (ALTER, INSERT, ...) only to disallow them due to access violation errors.&lt;/li&gt;
&lt;li&gt;Assuming restore is from remote host, we overload the network with all said irrelevant queries.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Just how inefficient? Let&#39;s time it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql&amp;gt; grant usage on *.* to &#39;restoreuser&#39;@&#39;localhost&#39;;
mysql&amp;gt; grant select on *.* to &#39;restoreuser&#39;@&#39;localhost&#39;;
mysql&amp;gt; grant all on employees.departments to &#39;restoreuser&#39;@&#39;localhost&#39;;

$ time mysql --user=restoreuser --socket=/tmp/mysql_sandbox21701.sock --force employees &amp;lt; /tmp/employees.sql
...
ERROR 1142 (42000) at line 343: INSERT command denied to user &#39;restoreuser&#39;@&#39;localhost&#39; for table &#39;titles&#39;
ERROR 1142 (42000) at line 344: ALTER command denied to user &#39;restoreuser&#39;@&#39;localhost&#39; for table &#39;titles&#39;
...
(lot&#39;s of these messages)
...

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m31.945s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m6.328s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.508s&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, at about &lt;strong&gt;30&lt;/strong&gt; seconds to restore a 9 rows table.&lt;/p&gt;
&lt;h4&gt;Text filtering based solution.&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://gtowey.blogspot.com/2009/11/restore-single-table-from-mysqldump.html&#34;&gt;&lt;strong&gt;gtowey&lt;/strong&gt;&lt;/a&gt; offers parsing the dump file beforehand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, parse with &lt;em&gt;grep&lt;/em&gt;, to detect rows where tables are referenced within dump file&lt;/li&gt;
&lt;li&gt;Second, parse with &lt;em&gt;sed&lt;/em&gt;, extracting relevant rows.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&#39;s time this one:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ time grep -n &#39;Table structure&#39; /tmp/employees.sql
23:-- Table structure for table `departments`
48:-- Table structure for table `dept_emp`
89:-- Table structure for table `dept_manager`
117:-- Table structure for table `employees`
161:-- Table structure for table `salaries`
301:-- Table structure for table `titles`

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m0.397s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.232s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.164s

$ time sed -n 23,48p /tmp/employees.sql | ./use employees

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m0.562s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.380s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.176s&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Much faster: about &lt;strong&gt;1&lt;/strong&gt; second, compared to &lt;strong&gt;30&lt;/strong&gt; seconds from above.&lt;/p&gt;
&lt;p&gt;Nevertheless, I find two issues here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A correctness problem: this solution somewhat assumes that there&#39;s only a single table with desired name. I say &#34;somewhat&#34; since it leaves this for the user.&lt;/li&gt;
&lt;li&gt;An efficiency problem: it reads the dump file &lt;em&gt;twice&lt;/em&gt;. First parsing it with &lt;em&gt;grep&lt;/em&gt;, then with &lt;em&gt;sed&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;A third solution&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;sed&lt;/em&gt; is much stronger than presented. In fact, the inquiry made by &lt;em&gt;grep&lt;/em&gt; in gtowey&#39;s solution can be easily handled by &lt;em&gt;sed&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ time sed -n &#34;/^-- Table structure for table \`departments\`/,/^-- Table structure for table/p&#34; /tmp/employees.sql | ./use employees

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m0.573s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.416s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.152s&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, the &lt;strong&gt;&#34;/^-- Table structure for table \`departments\`/,/^-- Table structure for table/p&#34;&lt;/strong&gt; part tells &lt;em&gt;sed&lt;/em&gt; to only print those rows starting from the &lt;strong&gt;departments&lt;/strong&gt; table structure, and ending in the next table structure (this is for clarity: had department been the last table, there would not be a next table, but we could nevertheless solve this using other anchors).&lt;/p&gt;
&lt;p&gt;And, we only do it in &lt;strong&gt;0.57&lt;/strong&gt; seconds: about half the time of previous attempt.&lt;/p&gt;
&lt;p&gt;Now, just to be more correct, we only wish to consider the &lt;strong&gt;employees.department&lt;/strong&gt; table. So, &lt;em&gt;assuming&lt;/em&gt; there&#39;s more than one database dumped (and, by consequence, &lt;strong&gt;USE&lt;/strong&gt; statements in the dump-file), we use:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;cat /tmp/employees.sql | sed -n &#34;/^USE \`employees\`/,/^USE \`/p&#34; | sed -n &#34;/^-- Table structure for table \`departments\`/,/^-- Table structure for table/p&#34; | ./use employees&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Further notes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;All tests used warmed-up caches.&lt;/li&gt;
&lt;li&gt;The sharp eyed readers would notice that &lt;strong&gt;departments&lt;/strong&gt; is the first table in the dump file. Would that give an unfair advantage to the parsing-based restore methods? The answer is no. I&#39;ve created an &lt;strong&gt;xdepartments&lt;/strong&gt; table, to be located at the end of the dump. The difference in time is neglectful and inconclusive; we&#39;re still at ~0.58-0.59 seconds. The effect will be more visible on really large dumps; but then, so would the security-based effects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[&lt;strong&gt;UPDATE&lt;/strong&gt;: see also following similar post: &lt;a href=&#34;http://blog.tsheets.com/2008/tips-tricks/extract-a-single-table-from-a-mysqldump-file.html&#34;&gt;Extract a Single Table from a mysqldump File&lt;/a&gt;]&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/Classic-Shell-Scripting-Arnold-Robbins/dp/0596005954/ref=sr_1_1&#34;&gt;&lt;img class=&#34;alignright&#34; title=&#34;classic-shell-scripting&#34; src=&#34;http://code.openark.org/blog/wp-content/uploads/2009/12/classic-shell-scripting.png&#34; alt=&#34;classic-shell-scripting&#34; width=&#34;144&#34; height=&#34;189&#34; scale=&#34;0&#34;&gt;&lt;/a&gt;Its is always best to test on large datasets, to get a feel on performance.&lt;/p&gt;
&lt;p&gt;It&#39;s best to save MySQL the trouble of parsing &amp;amp; ignoring statements. Scripting utilities like &lt;em&gt;sed&lt;/em&gt;, &lt;em&gt;awk&lt;/em&gt; &amp;amp; &lt;em&gt;grep&lt;/em&gt; have been around for ages, and are well optimized. They excel at text processing.&lt;/p&gt;
&lt;p&gt;I&#39;ve used &lt;em&gt;sed&lt;/em&gt; many times in transforming dump outputs; for example, in converting MyISAM to InnoDB tables; to convert Antelope InnoDB tables to Barracuda format, etc. grep &amp;amp; awk are also very useful.&lt;/p&gt;
&lt;p&gt;May I recommend, at this point, reading &lt;a href=&#34;http://www.amazon.com/Classic-Shell-Scripting-Arnold-Robbins/dp/0596005954/ref=sr_1_1&#34;&gt;Classic Shell Scripting&lt;/a&gt;, a very easy to follow book, which lists the most popular command line utilities like &lt;em&gt;grep&lt;/em&gt;, &lt;em&gt;sed&lt;/em&gt;, &lt;em&gt;awk&lt;/em&gt;, &lt;em&gt;sort&lt;/em&gt;, (countless more) and shell scripting in general. While most of these utilities are well known, the book excels in providing suprisingly practical, simple solution to common tasks.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>High Performance MySQL - a book to re-read</title>
      <link>/blog/mysql/high-performance-mysql-a-book-to-re-read/</link>
      <pubDate>Sun, 27 Sep 2009 09:56:59 +0000</pubDate>
      
      <guid>/blog/mysql/high-performance-mysql-a-book-to-re-read/</guid>
      <description>&lt;p&gt;I first read &lt;a href=&#34;http://www.amazon.com/High-Performance-MySQL-Optimization-Replication/dp/0596101716&#34;&gt;High Performance MySQL, 2nd edition&lt;/a&gt; about a year ago, when it first came out. I since re-read a few pages on occasion.&lt;/p&gt;
&lt;p&gt;In my previous posts I&#39;ve suggested ways to improve upon the common ranking solution. Very innovative stuff! Or... so I thought.&lt;/p&gt;
&lt;p&gt;I happened to browse through the book today, and a section on User Variables caught my eye. &#34;&lt;em&gt;Let&#39;s see if I get get some insight&lt;/em&gt;&#34;, I thought to myself. Imagine my surprise when I realized almost everything I&#39;ve suggested is discussed in this modest section, black on white, sitting on my bookshelf for over a year!&lt;/p&gt;
&lt;p&gt;I have read it a year back, have forgotten all about it, have re-invented stuff already solved and discussed... Oh, for more brain capacity...&lt;/p&gt;
&lt;p&gt;To be honest, this has happened to me more than once in the past few months; I&#39;m taking the habit of browsing the web when I&#39;m looking for answers to my problems; I forget that this book contains the answers to so many common, practical MySQL problems, and does so in a very direct and helpful manner.&lt;/p&gt;
&lt;p&gt;So, yet again, thumbs up to &lt;em&gt;High Performance MySQL&lt;/em&gt;. Really a must book. Get it if you haven&#39;t already!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unwalking a string with GROUP_CONCAT</title>
      <link>/blog/mysql/unwalking-a-string-with-group_concat/</link>
      <pubDate>Tue, 16 Jun 2009 07:54:49 +0000</pubDate>
      
      <guid>/blog/mysql/unwalking-a-string-with-group_concat/</guid>
      <description>&lt;p&gt;&#34;Walking a string&#34; is an SQL technique to convert a single value into multiple rows result set. For example, walking the string &lt;strong&gt;&#39;hello&#39;&lt;/strong&gt; results with 5 rows, each of which contains a single character from the text.&lt;/p&gt;
&lt;p&gt;I&#39;ll present a brief example of walking a string, and then show how to &#34;unwalk&#34; the string: do the reverse operation.&lt;/p&gt;
&lt;p&gt;To walk a string, an integers table is required (or this could be a good use for &lt;a href=&#34;http://www.mysqlconf.com/mysql2009/public/schedule/detail/6891&#34;&gt;SeqEngine&lt;/a&gt;):&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;CREATE TABLE `int_table` (
  `int_col` int(11) NOT NULL,
  PRIMARY KEY  (`int_col`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1

-- ...
-- INSERTS follow here
-- ...

mysql&amp;gt; SELECT * FROM int_table;
+---------+
| int_col |
+---------+
|       0 |
|       1 |
|       2 |
|       3 |
|       4 |
|       5 |
|       6 |
|       7 |
|       8 |
|       9 |
+---------+
10 rows in set (0.00 sec)&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;To convert a string to rows of characters, we join the text with the integers table (we assume there are enough numbers for covering the length of the text):&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql&amp;gt; SELECT
         SUBSTRING(s, int_col+1, 1) AS c
       FROM int_table, (SELECT &#39;hello&#39; AS s) sel1
       WHERE int_col &amp;lt; char_length(s);
+---+
| c |
+---+
| h |
| e |
| l |
| l |
| o |
+---+
5 rows in set (0.00 sec)&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;More on this can be found in the excellent &lt;a href=&#34;http://www.amazon.com/Cookbook-Cookbooks-OReilly-Anthony-Molinaro/dp/0596009763&#34;&gt;SQL Cookbook&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Unwalking the string&lt;/h4&gt;
&lt;p&gt;Doing the inverse action - combining the string back from the multiple rows, can be easily done using &lt;strong&gt;GROUP_CONCAT&lt;/strong&gt;. It&#39;s interesting to learn that&lt;strong&gt; GROUP_CONCAT&lt;/strong&gt; does not actually require any &lt;strong&gt;GROUP BY&lt;/strong&gt; clause. When no such clause is provided in the SQL query, all searched rows are used.&lt;/p&gt;
&lt;p&gt;Let&#39;s assume now that we have a table of character values, which we want to concatenate back to a complete string. We can easily build this table:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;CREATE TABLE characters AS
  SELECT
    SUBSTRING(s, int_col+1, 1) AS c
  FROM int_table, (SELECT &#39;hello&#39; AS s) sel1
  WHERE int_col &amp;lt; char_length(s);&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;To reconstruct the text, we simply use MySQL&#39;s &lt;strong&gt;GROUP_CONCAT&lt;/strong&gt; with an empty separator:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql&amp;gt; SELECT GROUP_CONCAT(c separator &#39;&#39;) AS s FROM characters;
+-------+
| s     |
+-------+
| hello |
+-------+
1 row in set (0.00 sec)&lt;/pre&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>7 ways to convince MySQL to use the right index</title>
      <link>/blog/mysql/7-ways-to-convince-mysql-to-use-the-right-index/</link>
      <pubDate>Thu, 02 Apr 2009 18:06:32 +0000</pubDate>
      
      <guid>/blog/mysql/7-ways-to-convince-mysql-to-use-the-right-index/</guid>
      <description>&lt;p&gt;Sometimes MySQL gets it wrong. It doesn&#39;t use the right index.&lt;/p&gt;
&lt;p&gt;It happens that MySQL generates a query plan which is really bad (EXPLAIN says it&#39;s going to explore some 10,000,000 rows), when another plan (soon to show how was generated) says: &#34;Sure, I can do that with 100 rows using a key&#34;.&lt;/p&gt;
&lt;h4&gt;A true story&lt;/h4&gt;
&lt;p&gt;A customer had issues with his database. Queries were taking 15 minutes to complete, and the db in general was not responsive. Looking at the slow query log, I found the criminal query. Allow me to bring you up to speed:&lt;/p&gt;
&lt;p&gt;A table is defined like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;CREATE TABLE t (
  id INT UNSIGNED AUTO_INCREMENT,
  type INT UNSIGNED,
  level TINYINT unsigned,
  ...
  PRIMARY KEY(id),
  KEY `type` (type)
) ENGINE=InnoDB;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The offending query was this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id FROM data
WHERE type=12345 AND level &amp;gt; 3
ORDER BY id&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The facts were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;`t` has about 10,000,000 rows.&lt;/li&gt;
&lt;li&gt;The index on `type` is selective: about 100 rows per value on average.&lt;/li&gt;
&lt;li&gt;The query took a long time to complete.&lt;/li&gt;
&lt;li&gt;EXPLAIN has shown that MySQL uses the PRIMARY KEY, hence searches 10,000,000 rows, filtered &#34;using where&#34;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;other&lt;/em&gt; EXPLAIN has shown that by using the `type` key, only 110 rows are expected, to be filtered &#34;using where&#34;, then sorted &#34;using filesort&#34;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So MySQL acknowledged it was generating the wrong plan. The &lt;em&gt;other&lt;/em&gt; plan was better by its own standards.&lt;/p&gt;
&lt;h4&gt;Solving the problem&lt;/h4&gt;
&lt;p&gt;Let&#39;s walk through 7 ways to solve the problem, starting with the more aggressive solutions, refining to achieve desired behavior through subtle changes.&lt;!--more--&gt;&lt;/p&gt;
&lt;h4&gt;Solution #1: OPTIMIZE&lt;/h4&gt;
&lt;p&gt;If MySQL got it wrong, it may be because the table was frequently changed. This affects the statistics. If we can spare the time (table is locked during that time), we could help out by rebuilding the table.&lt;/p&gt;
&lt;h4&gt;Solution #2: ANALYZE&lt;/h4&gt;
&lt;p&gt;ANALYZE TABLE is less time consuming, in particular on InnoDB, where it is barely noticed. An ANALYZE will update the index statistics and help out in generating better query plans.&lt;/p&gt;
&lt;p&gt;But hold on, the above two solutions are fine, but in the given case, MySQL &lt;em&gt;already&lt;/em&gt; acknowledges better plans are at hand. The fact was I tried to run ANALYZE a few times, to no avail.&lt;/p&gt;
&lt;h4&gt;Solution #3: USE INDEX&lt;/h4&gt;
&lt;p&gt;Since the issue was urgent, my first thought went for the ultimate weapon:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id FROM data USE INDEX(type)
WHERE type=12345 AND level &amp;gt; 3
ORDER BY id&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;This instructs MySQL to only consider the indexes listed; in our example, I only want MySQL to consider using the `type` index. It is using this method that generated the &lt;em&gt;other&lt;/em&gt; (good) EXPLAIN result. I could have gone even more ruthless and ask for FORCE INDEX.&lt;/p&gt;
&lt;h4&gt;Solution #4: IGNORE INDEX&lt;/h4&gt;
&lt;p&gt;A similar approach would be to explicitly negate the use of the PRIMARY KEY, like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id FROM data IGNORE INDEX(PRIMARY)
WHERE type=12345 AND level &amp;gt; 3
ORDER BY id&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;A moment of thinking&lt;/h4&gt;
&lt;p&gt;The above solutions are &#34;ugly&#34;, in the sense that this is not standard SQL. It&#39;s too MySQL specific.&lt;/p&gt;
&lt;p&gt;I&#39;ve asked the programmers to do a quick rewrite, and had a few moments to consider: why did MySQL insist on using the PRIMARY KEY. Was it because I&#39;ve asked it for the `id` column only? I rewrote as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id, type, level FROM data
WHERE type=12345 AND level &amp;gt; 3
ORDER BY id&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nope. EXPLAIN got me the same bad plan. Then it must be the ORDER BY clause:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id FROM data
WHERE type=12345 AND level &amp;gt; 3&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sure enough, EXPLAIN nowÂ  indicates using the `type` index, only reading 110 rows. So MySQL preferred to scan 10,000,000 rows, just so that the rows are generated in the right ORDER, and so no sorting is required, when it could have read 110 rows (where each row is a mere INT) and sort them in no time.&lt;/p&gt;
&lt;p&gt;Armed with this knowledge, a few more options come at hand.&lt;/p&gt;
&lt;h4&gt;Solution #5:Move some logic to the application&lt;/h4&gt;
&lt;p&gt;At about that point I got a message that the programmers were unable to add the USE INDEX part. Why? They were using the EJB framework, which limits your SQL-like queries to something very generic. Well, you can always drop the ORDER BY part and sort on the application side. That isn&#39;t fun, but it&#39;s been done.&lt;/p&gt;
&lt;h4&gt;Solution #6: Negate use of PRIMARY KEY&lt;/h4&gt;
&lt;p&gt;Can we force MySQL to use the `type` index, retain the ORDER BY, and do it all with standard SQL? Sure. The following query does this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id, type, level FROM data
WHERE type=12345 AND level &amp;gt; 3
ORDER BY id+0&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;id+0 is a function on the `id` column. This makes MySQL unable to utilize the PRIMARY KEY (or any other index on `id`, had there been one).&lt;/p&gt;
&lt;p&gt;In his book &#34;&lt;a title=&#34;SQL Tuning by Dan Tow&#34; href=&#34;http://www.amazon.com/SQL-Tuning-Dan-Tow/dp/0596005733&#34;&gt;SQL Tuning&lt;/a&gt;&#34;, Dan Tow dedicates a chapter on hints and tips like the above. He shows how to control the use or non-use of indexes, the order by which subqueries are calculated, and more.&lt;/p&gt;
&lt;p&gt;Unfortunately, the EJB specification said this was not allowed. You could not ORDER BY a fucntion. Only on normal column.&lt;/p&gt;
&lt;h4&gt;Solution #7: Make MySQL think the problem is harder than it really is&lt;/h4&gt;
&lt;p&gt;Almost out of options. Just a moment before settling for sorting on the application side, another issue can be considered: since MySQL was fooled once, can it be fooled again to make things right? Can we fool it to believe that the PRIMARY KEY would not be worthwhile to use? The following query does this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SELECT id, type, level FROM data
WHERE type=12345 AND level &amp;gt; 3
ORDER BY id, type, level&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s reflect on this one. What is the order by which the rows are returned now? Answer: exactly as before. Since `id` is PRIMARY KEY, it is also UNIQUE, so no two `id` values are the same. Therefore, the secondary sorting column is redudant, and so is the following one. We get exactly the same result as &#34;ORDER BY id&#34;.&lt;/p&gt;
&lt;p&gt;But MySQL didn&#39;t catch this. This query caused MySQL to say: &lt;em&gt;&#34;Mmmmm. &#39;ORDER BY id, type, level&#39; is not doable with the PRIMARY KEY only. Well, in this case, I had better used the `type` index&#34;&lt;/em&gt;. Is this a weakness of MySQL? I guess so. Maybe it will be fixed in the future. But this was the fix that made the day.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backup on code.openark.org</title>
    <link>/blog/tags/backup/</link>
    <description>Recent content in Backup on code.openark.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Mon, 13 Oct 2014 14:59:24 +0000</lastBuildDate>
    <atom:link href="/blog/tags/backup/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Announcing orchestrator-agent</title>
      <link>/blog/2014/10/13/announcing-orchestrator-agent/</link>
      <pubDate>Mon, 13 Oct 2014 14:59:24 +0000</pubDate>
      
      <guid>/blog/2014/10/13/announcing-orchestrator-agent/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator-agent&#34;&gt;orchestrator-agent&lt;/a&gt;&lt;/strong&gt; is a side-kick, complementary project of &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;&lt;/strong&gt;, implementing a daemon service on one&#39;s MySQL hosts which communicates with and accepts commands from &lt;em&gt;orchestrator&lt;/em&gt;, built with the original purpose of providing an automated solution for provisioning new or corrupted slaves.&lt;/p&gt;
&lt;p&gt;It was built by &lt;a href=&#34;https://github.com/outbrain&#34;&gt;Outbrain&lt;/a&gt;, with Outbrain&#39;s specific use case in mind. While we release it as open source, only a small part of its functionality will appeal to the public (this is why it&#39;s not strictly part of the &lt;em&gt;orchestrator&lt;/em&gt; project, which is a general purpose, wide-audience solution). Nevertheless, it is a simple implementation of a daemon, such that can be easily extended by the community. The project is open for pull-requests!&lt;/p&gt;
&lt;p&gt;A quick breakdown of &lt;em&gt;orchestrator-agent&lt;/em&gt; is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executes as a daemon on linux hosts&lt;/li&gt;
&lt;li&gt;Interacts and invokes OS commands (via &lt;em&gt;bash&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Does not directly interact with a MySQL server running on that host (does not connect via mysql credentials)&lt;/li&gt;
&lt;li&gt;Expects a single MySQL service on host&lt;/li&gt;
&lt;li&gt;Can control the MySQL service (e.g. stop, start)&lt;/li&gt;
&lt;li&gt;Is familiar with LVM layer on host&lt;/li&gt;
&lt;li&gt;Can take LVM snapshots, mount snapshots, remove snapshots&lt;/li&gt;
&lt;li&gt;Is familiar with the MySQL data directory, disk usage, file system&lt;/li&gt;
&lt;li&gt;Can send snapshot data from a mounted snapshot on a running MySQL host&lt;/li&gt;
&lt;li&gt;Can prepare data directory and receive snapshot data from another host&lt;/li&gt;
&lt;li&gt;Recognizes local/remote datacenters&lt;/li&gt;
&lt;li&gt;Controlled by &lt;em&gt;orchestrator,&lt;/em&gt; two &lt;em&gt;orchestrator-agents&lt;/em&gt; implement an automated and audited solution for seeding a new/corrupted MySQL host based on a running server.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!--more--&gt;Offline, hard-copy backups aside, Outbrain implements quick backups via LVM snapshots. Some slaves (depending on strength, datacenter etc.) take the role of &lt;em&gt;snapshot servers&lt;/em&gt;. These slaves take an LVM snapshot once per day, and &lt;em&gt;keep it open&lt;/em&gt; unmounted. At any given time we might have multiple open snapshots on a snapshot server. At a few minutes notice, we are able to restore MySQL to yesterday&#39;s, the day before, two days before, ... state. This only takes mounting of the desired snapshot and starting MySQL over the mounted volume.&lt;/p&gt;
&lt;p&gt;We&#39;ve in fact put this method to practice in at least one major occasion last year, that proved it to be of significant worth: we were able to fix a compromise to some dataset within minutes of action.&lt;/p&gt;
&lt;p&gt;But we also use these snapshots on a daily basis, putting them constantly to practice (hence validating this backup method routinely): we provision new MySQL servers based on those snapshots. A new or corrupted server can be seeded with a snapshot data (preferably from a host in same datacenter). We don&#39;t need to perform a backup &lt;em&gt;now&lt;/em&gt;. We can take the one from &lt;em&gt;tonight&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There is some fuss around this: need to verify MySQL not running on target host, clean up the target host, choose the best source host, choose the best snapshot on source host, mount it, deliver the data, accept the data, do post-copy cleanup, start the MySQL service on target host, ... Or we might choose to actually do take a fresh, immediate snapshot from a server not configured as &lt;em&gt;snapshot server&lt;/em&gt;... We used to do all these by shell scripts, but realized this will not sustain us.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Orchestrator-agent&lt;/em&gt; was invented with this particular use case in mind, and &lt;em&gt;orchestrator&lt;/em&gt; was extended to support these operations. &lt;em&gt;Orchestrator&lt;/em&gt; can act as the controller of a seed/provisioning operation, getting info from/to &lt;em&gt;orchestrator-agent&lt;/em&gt; and coordinating two agents to send/receive the data.&lt;/p&gt;
&lt;p&gt;The agent still relies on some external commands (via &lt;em&gt;bash&lt;/em&gt;) to implement some functionality; to some extent, we have broken down complex shell scripts then wrapped again, now controlled and audited by the agent; but this will slowly change as we move more code into &lt;em&gt;orchestrator-agent&lt;/em&gt; itself.&lt;/p&gt;
&lt;h4&gt;Should you use orchestrator-agent?&lt;/h4&gt;
&lt;p&gt;If, like us, you use LVM snapshots, at least as a partial form of backup - bingo!&lt;/p&gt;
&lt;p&gt;Otherwise, &lt;em&gt;orchestrator-agent&lt;/em&gt; can assist in stopping/starting the MySQL service, tailing the error log; simple stuff like that -- probably too much fuss for such basic operations.&lt;/p&gt;
&lt;p&gt;But it can be easily extended to support other forms of backup (though do note that &lt;em&gt;orchestrator-agent&lt;/em&gt; does not and should not perform scheduled backups, merely manipulate them); so if you like to contribute code into &lt;em&gt;orchestrator-agent&lt;/em&gt;, please let us know! It would be nice to have a solution that works for multiple use cases.&lt;/p&gt;
&lt;h4&gt;Get it&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;orchestrator-agent&lt;/em&gt; is released under the &lt;a href=&#34;https://github.com/outbrain/orchestrator-agent/blob/master/LICENSE&#34;&gt;Apache 2.0 license&lt;/a&gt;, and is free to use.&lt;/p&gt;
&lt;p&gt;Pre-compiled, &lt;strong&gt;RPM&lt;/strong&gt; and &lt;strong&gt;deb&lt;/strong&gt; packages &lt;a href=&#34;https://github.com/outbrain/orchestrator-agent/releases&#34;&gt;can be found on the releases page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A new MySQL backups temperature scale, with showers</title>
      <link>/blog/2012/06/26/a-new-mysql-backups-temperature-scale-with-showers/</link>
      <pubDate>Tue, 26 Jun 2012 08:08:15 +0000</pubDate>
      
      <guid>/blog/2012/06/26/a-new-mysql-backups-temperature-scale-with-showers/</guid>
      <description>&lt;p&gt;We&#39;re used to Cold, Warm and Hot backups. This scale of three temperatures does not quite reflect the impact of backups on your MySQL database.&lt;/p&gt;
&lt;p&gt;In this post I offer a new backup temperature scale, and (somewhat seriously) compare it with showers. Call it the &lt;em&gt;backup shower scale&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;A database backup is like a shower: the colder it is, the less time you want to spend doing it.&lt;/blockquote&gt;
&lt;h4&gt;Cold&lt;/h4&gt;
&lt;p&gt;A cold backup requires taking your database down (i.e. stop the service).&lt;/p&gt;
&lt;p&gt;Example: file system copy&lt;/p&gt;
&lt;p&gt;This can work well for replicating slaves, which may not be required for normal operation. You take the slave down, turn off the service, make your backup, turn everything on again, and let the backup catch up. Just make sure its master has all the necessary binary logs.&lt;/p&gt;
&lt;p&gt;A friend was staying at my place and was lecturing me on the benefits of cold showers; how it was good for your health. A couple hours later, preparing for bed, I hear him exclaiming from the bathroom: &lt;em&gt;&#34;Whaaaaa! There&#39;s no hot water!&#34;&lt;!--more--&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;Warm&lt;/h4&gt;
&lt;p&gt;A backup which requires locking down your database as read-only.&lt;/p&gt;
&lt;p&gt;Examples: MyDumper, mysqlhotcopy (MyISAM only), mysqldump (non-transactional)&lt;/p&gt;
&lt;p&gt;Again, this may do well on slaves. As for working out a warm backup on the master: I don&#39;t know. Is a mildly-warm shower really any better than a cold one?&lt;/p&gt;
&lt;h4&gt;Not quite hot&lt;/h4&gt;
&lt;p&gt;A backup which is supposedly non-interruptive to normal operation. You are allowed to keep writes to the database. But, things are not quite as they seem.&lt;/p&gt;
&lt;p&gt;Example: mysqldump --single-transaction&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mysqldump&lt;/em&gt; can make a backup in an open transaction. With InnoDB this means a consistent snapshot of the data. But open transactions lead to locks. These accumulate. MVCC makes for changes unable to fall back into the baseline, waiting for the backup&#39;s transaction to complete. Eventually, there are so many locks that your database is as good as dead. &lt;em&gt;mysqldump&lt;/em&gt; doesn&#39;t work well for very large databases under heavy load.&lt;/p&gt;
&lt;p&gt;[&lt;em&gt;UPDATE&lt;/em&gt;: As per Domas&#39; clarification, MyDumper falls under this category, as well]&lt;/p&gt;
&lt;p&gt;In terms of shower, you have reasonably hot water for some time, but they eventually run cold.&lt;/p&gt;
&lt;h4&gt;Hot&lt;/h4&gt;
&lt;p&gt;A hot backup is such that does not impose any constraints on the database itself. But it may impose load on other components, such as the disks, memory, CPU. This leads to an implicit impact on MySQL&#39;s performance.&lt;/p&gt;
&lt;p&gt;An LVM snapshot works this way. With LVM snapshots, writes to the database cause for blocks copy-on-write. The disk is busier. MySQL has to compete for disk use. An LVM backup works just well, but has a noticeable impact on the database&#39;s ability to keep up as before.&lt;/p&gt;
&lt;p&gt;You may have enough hot water for your shower, but there&#39;s not enough pressure. The minute the dishwasher starts working, your shower turns to a sad dripping.&lt;/p&gt;
&lt;h4&gt;Searing hot&lt;/h4&gt;
&lt;p&gt;A searing hot backup is one that does not interfere with database operation, explicitly or implicitly, to a reasonable extent.&lt;/p&gt;
&lt;p&gt;Xtrabackup with throttling is such a backup. The impact can be made low such that it is unnoticeable. You are willing to have the backup take longer time to complete.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Upgrading to Barracuda &amp; getting rid of huge ibdata1 file</title>
      <link>/blog/2011/02/15/upgrading-to-barracuda-getting-rid-of-huge-ibdata1-file/</link>
      <pubDate>Tue, 15 Feb 2011 10:01:15 +0000</pubDate>
      
      <guid>/blog/2011/02/15/upgrading-to-barracuda-getting-rid-of-huge-ibdata1-file/</guid>
      <description>&lt;p&gt;Some of this is old stuff, but more people are now converting to InnoDB plugin, so as to enjoy table compression, performance boosts. Same holds for people converting to Percona&#39;s XtraDB. InnoDB plugin requires &lt;strong&gt;innodb_file_per_table&lt;/strong&gt;. No more shared tablespace file.&lt;/p&gt;
&lt;p&gt;So your &lt;strong&gt;ibdata1&lt;/strong&gt; file is some &lt;strong&gt;150GB&lt;/strong&gt;, and it won&#39;t reduce. Really, it won&#39;t reduce. You set &lt;strong&gt;innodb_file_per_table=1&lt;/strong&gt;, do &lt;strong&gt;ALTER TABLE t ENGINE=InnoDB&lt;/strong&gt; (optionally &lt;strong&gt;ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8&lt;/strong&gt;), and you get all your tables in file-per-table &lt;strong&gt;.ibd&lt;/strong&gt; files.&lt;/p&gt;
&lt;p&gt;But the original &lt;strong&gt;ibdata1&lt;/strong&gt; file is still there. It has to be there, don&#39;t delete it! It contains more than your old data.&lt;/p&gt;
&lt;p&gt;InnoDB tablespace files never reduce in size, it&#39;s an old-time annoyance. The only way to go round it, if you need the space, is to completely drop them and start afresh. That&#39;s one of the things so nice about file-per-table: an &lt;strong&gt;ALTER TABLE&lt;/strong&gt; actually creates a new tablespace file and drops the original one.&lt;/p&gt;
&lt;h4&gt;The procedure&lt;/h4&gt;
&lt;p&gt;The procedure is somewhat painful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dump everything logically (either use &lt;em&gt;mysqldump&lt;/em&gt;, &lt;a href=&#34;http://www.maatkit.org/doc/mk-parallel-dump.html&#34;&gt;mk-parallel-dump&lt;/a&gt;, or do it your own way)&lt;/li&gt;
&lt;li&gt;Erase your data (literally, delete everything under your &lt;strong&gt;datadir&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Generate a new empty database&lt;/li&gt;
&lt;li&gt;Load your dumped data.&lt;!--more--&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Using replication&lt;/h4&gt;
&lt;p&gt;Replication makes this less painful. Set up a slave, have it follow up on the master.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stop your slave.&lt;/li&gt;
&lt;li&gt;Make sure to backup the replication position (e.g. write &lt;strong&gt;SHOW SLAVE STATUS&lt;/strong&gt; on a safe location, or copy &lt;strong&gt;master.info&lt;/strong&gt; file).&lt;/li&gt;
&lt;li&gt;Work out the dump-erase-generate-load steps on the slave.&lt;/li&gt;
&lt;li&gt;Reattach the slave to the master using saved data.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this to succeed you must keep enough binary logs on the master for the entire dump-load period, which could be lengthy.&lt;/p&gt;
&lt;h4&gt;Upgrading to barracuda&lt;/h4&gt;
&lt;p&gt;If you wish to upgrade your InnoDB tables to &lt;em&gt;Barracuda&lt;/em&gt; format, my advice is this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Follow the steps above to generate a file-per-table working slave&lt;/li&gt;
&lt;li&gt;Stop the slave&lt;/li&gt;
&lt;li&gt;Configure &lt;strong&gt;skip_slave_start&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Restart MySQL&lt;/li&gt;
&lt;li&gt;One by one do the &lt;strong&gt;ALTER TABLE&lt;/strong&gt; into &lt;em&gt;Barracuda&lt;/em&gt; format (&lt;strong&gt;ROW_FORMAT=COMPACT&lt;/strong&gt; or &lt;strong&gt;ROW_FORMAT=COMPRESSED&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that if you&#39;re about to do table compression, the &lt;strong&gt;ALTER&lt;/strong&gt; statements become &lt;em&gt;considerably&lt;/em&gt; slower the better the compression is.&lt;/p&gt;
&lt;p&gt;If your dataset is very large, and you can&#39;t keep so many binary logs, you may wish to break step &lt;strong&gt;5&lt;/strong&gt; above into:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ALTER a large table&lt;/li&gt;
&lt;li&gt;Restart MySQL&lt;/li&gt;
&lt;li&gt;Start slave, wait for it to catch up&lt;/li&gt;
&lt;li&gt;Restart MySQL again&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and do the same for all large tables.&lt;/p&gt;
&lt;h4&gt;Why all these restarts?&lt;/h4&gt;
&lt;p&gt;I&#39;ve been upgrading to Barracuda for a long time now. I have clearly noticed that &lt;strong&gt;ALTER&lt;/strong&gt; into a &lt;strong&gt;COMPRESSED&lt;/strong&gt; format works considerably slower after the slave has done some &#34;real work&#34;. This in particular relates to the last &#34;renaming table&#34; stage. There was a bug with earlier InnoDB plugin versions which made this stage hang. It was solved. But it still takes some time for this last, weird stage, where the new replacement table is complete, and it&#39;s actually been renamed in place of the old table, and the old table renamed into something like &#34;#sql-12345.ibd&#34;, and all that needs to be done is have it dropped, and... Well, it takes time.&lt;/p&gt;
&lt;p&gt;My observation is it works faster on a freshly started server. Which is why I take the bother to restart MySQL before each large table conversion.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>An argument for using mysqldump</title>
      <link>/blog/2010/11/09/an-argument-for-using-mysqldump/</link>
      <pubDate>Tue, 09 Nov 2010 06:29:54 +0000</pubDate>
      
      <guid>/blog/2010/11/09/an-argument-for-using-mysqldump/</guid>
      <description>&lt;p&gt;I fully agree with Morgan&#39;s &lt;a href=&#34;http://www.mysqlperformanceblog.com/2010/11/08/an-argument-for-not-using-mysqldump-in-production/&#34;&gt;An argument for not using mysqldump&lt;/a&gt;. This post does not come to contradict it, but rather shed a positive light on &lt;em&gt;mysqldump&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I usually prefer an LVM snapshot based backup, or using XtraBackup. And, with databases as large as dozens of GB and above, I consider &lt;em&gt;mysqldump&lt;/em&gt; to be a poor alternative. Poor in runtime, poor in overhead while taking the backup.&lt;/p&gt;
&lt;p&gt;However once in a while I get to be reminded that &lt;em&gt;mysqldump just works&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As a recent example, I had a server which was killed after an ALTER TABLE statement hanged forever (table already ALTERed, but old scheme never dropped). The old table data still hanged around the file system, but was not recognized by InnoDB. Trying out DISCARD TABLESPACE did not do the job, and eventually file was dropped.&lt;/p&gt;
&lt;p&gt;So far, reasonable. InnoDB would complain about some table it never recognized in the first place, but all would work. That is, until backup was concerned. With &lt;em&gt;innobackup&lt;/em&gt; or XtraBackup the restore would fail on some internal problem. LVM would work, but would only copy+paste the problem: &lt;em&gt;innobackup&lt;/em&gt; would never again be able to be used on this database.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;It turned out a &lt;strong&gt;120GB&lt;/strong&gt; InnoDB compressed data (roughly &lt;strong&gt;250GB&lt;/strong&gt; uncompressed) would dump in &lt;strong&gt;--single-transaction&lt;/strong&gt; in a matter of &lt;strong&gt;4&lt;/strong&gt; hours and would restore in a matter of some &lt;strong&gt;20&lt;/strong&gt; hours. A whole lot more than the &lt;strong&gt;3&lt;/strong&gt; hours total it would take for an LVM backup for that database. But the data would load well; no missing tablespaces.&lt;/p&gt;
&lt;p&gt;I&#39;ve had similar incidents in the past. Not to mention the issue of compressing shared tablespace file.&lt;/p&gt;
&lt;p&gt;There&#39;s something about being able to say &#34;&lt;em&gt;I&#39;m not sure how long this is going to take; maybe a day or two. But in the end, we will have problems P1, P2 &amp;amp; P3 resolved&lt;/em&gt;&#34;.&lt;/p&gt;
&lt;p&gt;I like the &lt;em&gt;clean state&lt;/em&gt; you get from a &lt;em&gt;mysqldump&lt;/em&gt; restore.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>mylvmbackup HOWTO: minimal privileges &amp; filesystem copy</title>
      <link>/blog/2010/08/17/mylvmbackup-howto-minimal-privileges-filesystem-copy/</link>
      <pubDate>Tue, 17 Aug 2010 19:42:40 +0000</pubDate>
      
      <guid>/blog/2010/08/17/mylvmbackup-howto-minimal-privileges-filesystem-copy/</guid>
      <description>&lt;p&gt;This HOWTO discusses two (unrelated) issues with &lt;a href=&#34;http://www.lenzg.net/mylvmbackup/&#34;&gt;&lt;em&gt;mylvmbackup&lt;/em&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The minimal privileges required to take MySQL backups with &lt;em&gt;mylvmbackup.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Making (non compressed) file system copy of one&#39;s data files.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Minimal privileges&lt;/h4&gt;
&lt;p&gt;Some just give &lt;em&gt;mylvmbackup&lt;/em&gt; the root account, which is far too permissive. We now consider what the minimal requirements of &lt;em&gt;mylvmbackup&lt;/em&gt; are.&lt;/p&gt;
&lt;p&gt;The queries &lt;em&gt;mylvmbackup&lt;/em&gt; issues are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FLUSH TABLES&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FLUSH TABLES WITH READ LOCK&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SHOW MASTER STATUS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SHOW SLAVE STATUS&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UNLOCK TABLES&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both &lt;strong&gt;SHOW MASTER STATUS&lt;/strong&gt; &amp;amp; &lt;strong&gt;SHOW SLAVE STATUS&lt;/strong&gt; require either the &lt;strong&gt;SUPER&lt;/strong&gt; or &lt;strong&gt;REPLICATION CLIENT&lt;/strong&gt; privilege. Since &lt;strong&gt;SUPER&lt;/strong&gt; is more powerful, we choose &lt;strong&gt;REPLICATION CLIENT&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;FLUSH TABLES&lt;/strong&gt; * and &lt;strong&gt;UNLOCK TABLES&lt;/strong&gt; require the &lt;strong&gt;RELOAD&lt;/strong&gt; privilege.&lt;/p&gt;
&lt;p&gt;However, we are not done yet. &lt;em&gt;mylvmbackup&lt;/em&gt; connects to the &lt;strong&gt;mysql&lt;/strong&gt; database, which means we must also have some privilege there, too. We choose the &lt;strong&gt;SELECT&lt;/strong&gt; privilege.&lt;/p&gt;
&lt;p&gt;&lt;!--more--&gt;Finally, here are the commands to create a &lt;em&gt;mylvmbackup&lt;/em&gt; user with minimal privileges:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;CREATE USER &#39;mylvmbackup&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345&#39;;
GRANT RELOAD, REPLICATION CLIENT ON *.* TO &#39;mylvmbackup&#39;@&#39;localhost&#39;;
GRANT SELECT ON mysql.* TO &#39;mylvmbackup&#39;@&#39;localhost&#39;;
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the &lt;strong&gt;mylvmbackup.conf&lt;/strong&gt; file, the correlating rows are:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;[mysql]
user=mylvmbackup
password=12345
host=localhost
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Filesystem copy&lt;/h4&gt;
&lt;p&gt;By default, &lt;em&gt;mylvmbackup&lt;/em&gt; creates a &lt;strong&gt;.tar.gz&lt;/strong&gt; compressed backup file of your data. This is good if the reason you&#39;re running &lt;em&gt;mylvmbackup&lt;/em&gt; is to, well, make a backup. However, as with all backups, one may be making the backup so as to create a replication server. But in this case you don&#39;t really want compressed data: you want the data extracted on the replication server, just as it is on the original host.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;mylvmbackup&lt;/em&gt; supports backing up the files using &lt;em&gt;rsync&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To copy MySQL data to a remote host, configure the following in the mylvmbackup.conf file:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;[fs]
backupdir=shlomi@backuphost:/data/backup/mysql
[misc]
backuptype=rsync
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;You may be prompted to enter password, unless you have the user&#39;s public key stored on the remote host.&lt;/p&gt;
&lt;p&gt;Normally, &lt;em&gt;rsync&lt;/em&gt; is considered as &lt;strong&gt;r&lt;/strong&gt;emote-&lt;strong&gt;sync&lt;/strong&gt;, but it also works on local file systems. If you have a remote directory mounted on your file system (e.g. with &lt;em&gt;nfs&lt;/em&gt;), you can use the fact that &lt;em&gt;rsync&lt;/em&gt; works just as well with local file systems:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;[fs]
backupdir=/mnt/backup/mysql
[misc]
backuptype=rsync
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Voila! Your backup is complete.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tips for taking MySQL backups using LVM</title>
      <link>/blog/2010/08/03/tips-for-taking-mysql-backups-using-lvm/</link>
      <pubDate>Tue, 03 Aug 2010 08:45:29 +0000</pubDate>
      
      <guid>/blog/2010/08/03/tips-for-taking-mysql-backups-using-lvm/</guid>
      <description>&lt;p&gt;LVM uses copy-on-write to implement snapshots. Whenever you&#39;re writing data to some page, LVM copies the original page (the way it looked like when the snapshot was taken) to the snapshot volume. The snapshot volume must be large enough to accommodate all pages written to for the duration of the snapshot&#39;s lifetime. In other words, you must be able to copy the data somewhere outside (tape, NFS, rsync, etc.) in less time than it would take for the snapshot to fill up.&lt;/p&gt;
&lt;p&gt;While LVM allows for hot backups of MySQL, it still poses an impact on the disks. An LVM snapshot backup may not go unnoticed by the MySQL users.&lt;/p&gt;
&lt;p&gt;Some general guidelines for making life easier with LVM backups follow.&lt;/p&gt;
&lt;h4&gt;Lighter, longer snapshots&lt;/h4&gt;
&lt;p&gt;If you&#39;re confident that you have enough space on your snapshot volume, you may take the opportunity to make for a &lt;em&gt;longer&lt;/em&gt; backup time. Why? Because you would then be able to reduce the stress from the file system. Use &lt;strong&gt;ionice&lt;/strong&gt; when copying your data from the snapshot volume:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;ionice -c 2 cp -R /mnt/mysql_snapshot /mnt/backup/daily/20100719/
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;[Update: this is only on the cfq I/O scheduler; thanks, Vojtech]&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;Are you running out of space?&lt;/h4&gt;
&lt;p&gt;Monitor snapshot&#39;s allocated size: if there&#39;s just one snapshot, do it like this:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;lvdisplay | grep Allocated                                                                                                                  Mon Jul 19 09:51:29 2010

 Allocated to snapshot  3.63%
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Don&#39;t let it reach 100%.&lt;/p&gt;
&lt;h4&gt;Avoid running out of space&lt;/h4&gt;
&lt;p&gt;To make sure you don&#39;t run out of snapshot allocated size, stop all administrative scripts.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Are you running your weekly purging of old data? You will be writing a lot of pages, and all will have to fit in the snapshot.&lt;/li&gt;
&lt;li&gt;Building your reports? You may be creating large temporary tables; make sure these are not on the snapshot volume.&lt;/li&gt;
&lt;li&gt;Rebuilding your Sphinx fulltext index? Make sure it is not on the snapshot volume, or postpone till after backup.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You will gain not only snapshot space, but also faster backups.&lt;/p&gt;
&lt;h4&gt;Someone did the job before you&lt;/h4&gt;
&lt;p&gt;Use &lt;a href=&#34;http://www.lenzg.net/mylvmbackup/&#34;&gt;mylvmbackup&lt;/a&gt;: the MySQL LVM backup script by Lenz Grimmer. Or do it manually: follow this old-yet-relevant &lt;a href=&#34;http://www.mysqlperformanceblog.com/2006/08/21/using-lvm-for-mysql-backup-and-replication-setup/&#34;&gt;post&lt;/a&gt; by Peter Zaitsev.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A MyISAM backup is blocking as read-only, including mysqldump backup</title>
      <link>/blog/2010/05/18/a-myisam-backup-is-blocking-as-read-only-including-mysqldump-backup/</link>
      <pubDate>Tue, 18 May 2010 19:29:05 +0000</pubDate>
      
      <guid>/blog/2010/05/18/a-myisam-backup-is-blocking-as-read-only-including-mysqldump-backup/</guid>
      <description>&lt;p&gt;Actually this is (almost) all I wanted to say. This is intentionally posted with all related keywords in title, in the hope that a related search on Google will result with this post on first page.&lt;/p&gt;
&lt;p&gt;I&#39;m just still encountering companies who use MyISAM as their storage engine and are &lt;em&gt;unaware&lt;/em&gt; that their nightly backup actually blocks their application, basically rendering their product unavailable for long minutes to hours on a nightly basis.&lt;/p&gt;
&lt;p&gt;So this is posted as a warning for those who were not aware of this fact.&lt;/p&gt;
&lt;p&gt;There is no hot (non blocking) backup for MyISAM. Closest would be file system snapshot, but even this requires flushing of tables, which may take a while to complete. If you must have a hot backup, then either use replication - and take the risk of the slave not being in complete sync with the master - or use another storage engine, i.e. InnoDB.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Defined your MySQL backup &amp; recovery plan recently?</title>
      <link>/blog/2010/02/17/defined-your-mysql-backup-recovery-plan-recently/</link>
      <pubDate>Wed, 17 Feb 2010 11:52:00 +0000</pubDate>
      
      <guid>/blog/2010/02/17/defined-your-mysql-backup-recovery-plan-recently/</guid>
      <description>&lt;p&gt;Following up on &lt;a href=&#34;http://ronaldbradford.com/&#34;&gt;Ronald Bradford&lt;/a&gt;&#39;s &lt;a href=&#34;http://ronaldbradford.com/blog/checked-your-mysql-recovery-process-recently-2010-02-15/&#34;&gt;Checked your MySQL recovery process recently?&lt;/a&gt; post, I wish to add a &lt;em&gt;prequel&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To see whether you have a clear definition of your backup requirements, ask yourself these questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is there a backup/restore plan?&lt;/li&gt;
&lt;li&gt;Is there a written backup/restore plan?&lt;/li&gt;
&lt;li&gt;How fast do you need to recover a backup? What&#39;s the longest downtime you will allow from the point of failure to the point of restored, functional database?&lt;/li&gt;
&lt;li&gt;How much data are you willing to lose in case of crash? A second&#39;s worth of data? An hour&#39;s worth? A day&#39;s worth? None?&lt;/li&gt;
&lt;li&gt;Are you willing to allow that the database becomes read-only when taking the backup? Or completely down?&lt;/li&gt;
&lt;li&gt;Are you willing to take the risk that the backup will not be 100% compatible with the data? (Backing up your slave holds this risk)&lt;/li&gt;
&lt;li&gt;Is your manager willing to all that you are willing?&lt;/li&gt;
&lt;li&gt;Is the backup plan known to the management team, or do they just know that &#34;&lt;em&gt;the database has backups&lt;/em&gt;&#34;?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The above checklist is by no means complete.&lt;/p&gt;
&lt;p&gt;I have a vivid memory of a very good sys admin who failed on the last two points. He had some very sour days when recovering a lost file from tape took much longer than was affordable to some contract.&lt;/p&gt;
&lt;p&gt;I found that technical people rarely share the same views as marketing/management. Make sure to consult with the management team; they will have a clearer view on what the company can afford and what it cannot afford.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>On restoring a single table from mysqldump</title>
      <link>/blog/2009/12/01/on-restoring-a-single-table-from-mysqldump/</link>
      <pubDate>Tue, 01 Dec 2009 10:25:00 +0000</pubDate>
      
      <guid>/blog/2009/12/01/on-restoring-a-single-table-from-mysqldump/</guid>
      <description>&lt;p&gt;Following &lt;a href=&#34;http://everythingmysql.ning.com/profiles/blogs/restore-one-table-from-an-all&#34;&gt;Restore one table from an ALL database dump&lt;/a&gt; and &lt;a href=&#34;http://gtowey.blogspot.com/2009/11/restore-single-table-from-mysqldump.html&#34;&gt;Restore a Single Table From mysqldump&lt;/a&gt;, I would like to add my own thoughts and comments on the subject.&lt;/p&gt;
&lt;p&gt;I also wish to note performance issues with the two suggested solutions, and offer improvements.&lt;/p&gt;
&lt;h4&gt;Problem relevance&lt;/h4&gt;
&lt;p&gt;While the problem is interesting, I just want to note that it is relevant in very specific database dimensions. Too small - and it doesn&#39;t matter how you solve it (e.g. just open vi/emacs and copy+paste). Too big - and it would not be worthwhile to restore from &lt;em&gt;mysqldump&lt;/em&gt; anyway. I would suggest that the problem is interesting in the whereabouts of a few dozen GB worth of data.&lt;/p&gt;
&lt;h4&gt;Problem recap&lt;/h4&gt;
&lt;p&gt;Given a dump file (generated by mysqldump), how do you restore a single table, without making any changes to other tables?&lt;/p&gt;
&lt;p&gt;Let&#39;s review the two referenced solutions. I&#39;ll be using the &lt;a href=&#34;http://dev.mysql.com/doc/employee/en/employee.html&#34;&gt;employees db&lt;/a&gt; on &lt;a href=&#34;https://launchpad.net/mysql-sandbox&#34;&gt;mysql-sandbox&lt;/a&gt; for testing. I&#39;ll choose a very small table to restore: &lt;strong&gt;departments&lt;/strong&gt; (only a few rows in this table).&lt;/p&gt;
&lt;h4&gt;Security based solution&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://everythingmysql.ning.com/profiles/blogs/restore-one-table-from-an-all&#34;&gt;&lt;strong&gt;Chris&lt;/strong&gt;&lt;/a&gt; offers to create a special purpose account, which will only have write (CREATE, INSERT, etc.) privileges on the particular table to restore. Cool hack! But, I&#39;m afraid, not too efficient, for two reasons:&lt;span id=&#34;more-1630&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL needs to process all irrelevant queries (ALTER, INSERT, ...) only to disallow them due to access violation errors.&lt;/li&gt;
&lt;li&gt;Assuming restore is from remote host, we overload the network with all said irrelevant queries.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Just how inefficient? Let&#39;s time it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql&amp;gt; grant usage on *.* to &#39;restoreuser&#39;@&#39;localhost&#39;;
mysql&amp;gt; grant select on *.* to &#39;restoreuser&#39;@&#39;localhost&#39;;
mysql&amp;gt; grant all on employees.departments to &#39;restoreuser&#39;@&#39;localhost&#39;;

$ time mysql --user=restoreuser --socket=/tmp/mysql_sandbox21701.sock --force employees &amp;lt; /tmp/employees.sql
...
ERROR 1142 (42000) at line 343: INSERT command denied to user &#39;restoreuser&#39;@&#39;localhost&#39; for table &#39;titles&#39;
ERROR 1142 (42000) at line 344: ALTER command denied to user &#39;restoreuser&#39;@&#39;localhost&#39; for table &#39;titles&#39;
...
(lot&#39;s of these messages)
...

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m31.945s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m6.328s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.508s&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, at about &lt;strong&gt;30&lt;/strong&gt; seconds to restore a 9 rows table.&lt;/p&gt;
&lt;h4&gt;Text filtering based solution.&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://gtowey.blogspot.com/2009/11/restore-single-table-from-mysqldump.html&#34;&gt;&lt;strong&gt;gtowey&lt;/strong&gt;&lt;/a&gt; offers parsing the dump file beforehand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, parse with &lt;em&gt;grep&lt;/em&gt;, to detect rows where tables are referenced within dump file&lt;/li&gt;
&lt;li&gt;Second, parse with &lt;em&gt;sed&lt;/em&gt;, extracting relevant rows.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&#39;s time this one:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ time grep -n &#39;Table structure&#39; /tmp/employees.sql
23:-- Table structure for table `departments`
48:-- Table structure for table `dept_emp`
89:-- Table structure for table `dept_manager`
117:-- Table structure for table `employees`
161:-- Table structure for table `salaries`
301:-- Table structure for table `titles`

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m0.397s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.232s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.164s

$ time sed -n 23,48p /tmp/employees.sql | ./use employees

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m0.562s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.380s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.176s&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Much faster: about &lt;strong&gt;1&lt;/strong&gt; second, compared to &lt;strong&gt;30&lt;/strong&gt; seconds from above.&lt;/p&gt;
&lt;p&gt;Nevertheless, I find two issues here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A correctness problem: this solution somewhat assumes that there&#39;s only a single table with desired name. I say &#34;somewhat&#34; since it leaves this for the user.&lt;/li&gt;
&lt;li&gt;An efficiency problem: it reads the dump file &lt;em&gt;twice&lt;/em&gt;. First parsing it with &lt;em&gt;grep&lt;/em&gt;, then with &lt;em&gt;sed&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;A third solution&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;sed&lt;/em&gt; is much stronger than presented. In fact, the inquiry made by &lt;em&gt;grep&lt;/em&gt; in gtowey&#39;s solution can be easily handled by &lt;em&gt;sed&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ time sed -n &#34;/^-- Table structure for table \`departments\`/,/^-- Table structure for table/p&#34; /tmp/employees.sql | ./use employees

real&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;0m0.573s&lt;/strong&gt;
user&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.416s
sys&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0m0.152s&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, the &lt;strong&gt;&#34;/^-- Table structure for table \`departments\`/,/^-- Table structure for table/p&#34;&lt;/strong&gt; part tells &lt;em&gt;sed&lt;/em&gt; to only print those rows starting from the &lt;strong&gt;departments&lt;/strong&gt; table structure, and ending in the next table structure (this is for clarity: had department been the last table, there would not be a next table, but we could nevertheless solve this using other anchors).&lt;/p&gt;
&lt;p&gt;And, we only do it in &lt;strong&gt;0.57&lt;/strong&gt; seconds: about half the time of previous attempt.&lt;/p&gt;
&lt;p&gt;Now, just to be more correct, we only wish to consider the &lt;strong&gt;employees.department&lt;/strong&gt; table. So, &lt;em&gt;assuming&lt;/em&gt; there&#39;s more than one database dumped (and, by consequence, &lt;strong&gt;USE&lt;/strong&gt; statements in the dump-file), we use:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;cat /tmp/employees.sql | sed -n &#34;/^USE \`employees\`/,/^USE \`/p&#34; | sed -n &#34;/^-- Table structure for table \`departments\`/,/^-- Table structure for table/p&#34; | ./use employees&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Further notes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;All tests used warmed-up caches.&lt;/li&gt;
&lt;li&gt;The sharp eyed readers would notice that &lt;strong&gt;departments&lt;/strong&gt; is the first table in the dump file. Would that give an unfair advantage to the parsing-based restore methods? The answer is no. I&#39;ve created an &lt;strong&gt;xdepartments&lt;/strong&gt; table, to be located at the end of the dump. The difference in time is neglectful and inconclusive; we&#39;re still at ~0.58-0.59 seconds. The effect will be more visible on really large dumps; but then, so would the security-based effects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[&lt;strong&gt;UPDATE&lt;/strong&gt;: see also following similar post: &lt;a href=&#34;http://blog.tsheets.com/2008/tips-tricks/extract-a-single-table-from-a-mysqldump-file.html&#34;&gt;Extract a Single Table from a mysqldump File&lt;/a&gt;]&lt;/p&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/Classic-Shell-Scripting-Arnold-Robbins/dp/0596005954/ref=sr_1_1&#34;&gt;&lt;img class=&#34;alignright&#34; title=&#34;classic-shell-scripting&#34; src=&#34;http://code.openark.org/blog/wp-content/uploads/2009/12/classic-shell-scripting.png&#34; alt=&#34;classic-shell-scripting&#34; width=&#34;144&#34; height=&#34;189&#34; scale=&#34;0&#34;&gt;&lt;/a&gt;Its is always best to test on large datasets, to get a feel on performance.&lt;/p&gt;
&lt;p&gt;It&#39;s best to save MySQL the trouble of parsing &amp;amp; ignoring statements. Scripting utilities like &lt;em&gt;sed&lt;/em&gt;, &lt;em&gt;awk&lt;/em&gt; &amp;amp; &lt;em&gt;grep&lt;/em&gt; have been around for ages, and are well optimized. They excel at text processing.&lt;/p&gt;
&lt;p&gt;I&#39;ve used &lt;em&gt;sed&lt;/em&gt; many times in transforming dump outputs; for example, in converting MyISAM to InnoDB tables; to convert Antelope InnoDB tables to Barracuda format, etc. grep &amp;amp; awk are also very useful.&lt;/p&gt;
&lt;p&gt;May I recommend, at this point, reading &lt;a href=&#34;http://www.amazon.com/Classic-Shell-Scripting-Arnold-Robbins/dp/0596005954/ref=sr_1_1&#34;&gt;Classic Shell Scripting&lt;/a&gt;, a very easy to follow book, which lists the most popular command line utilities like &lt;em&gt;grep&lt;/em&gt;, &lt;em&gt;sed&lt;/em&gt;, &lt;em&gt;awk&lt;/em&gt;, &lt;em&gt;sort&lt;/em&gt;, (countless more) and shell scripting in general. While most of these utilities are well known, the book excels in providing suprisingly practical, simple solution to common tasks.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Parameters to use on mysqldump</title>
      <link>/blog/2008/10/13/parameters-to-use-on-mysqldump/</link>
      <pubDate>Mon, 13 Oct 2008 09:03:50 +0000</pubDate>
      
      <guid>/blog/2008/10/13/parameters-to-use-on-mysqldump/</guid>
      <description>&lt;p&gt;mysqldump is commonly used for making a MySQL database backup or for setting up a replication.&lt;/p&gt;
&lt;p&gt;As in all mysql binaries, there are quite a few parameters to mysqldump. Some are just niceties but some flags are a must. Of course, choosing the parameters to use greatly depends on your requirements, database setup, network capacity etc.&lt;/p&gt;
&lt;p&gt;Here is my usual setup for mysqldump. The parameters below apply for an InnoDB based schema (no MyISAM, Memory tables). Parameters can be specified on the command line, or under the &lt;code&gt;[mysqld]&lt;/code&gt; scope in the MySQL configuration file.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p style=&#34;text-align: left;&#34;&gt;&lt;code&gt;mysqldump -u dump_user -p -h db_host --routines --master-data --single-transaction  --skip-add-locks --skip-lock-tables --default-character-set=utf8 --compress my_db&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s review these parameters and see their effect:&lt;!--more--&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; or &lt;code&gt;--user&lt;/code&gt;: This is the user which initiates the dump. Depending on other parameters, the user may need to have quite a few privileges, such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;RELOAD&lt;/code&gt;, &lt;code&gt;FILE&lt;/code&gt;, &lt;code&gt;REPLICATION CLIENT&lt;/code&gt; etc. Since I do not usually allow for remote root access into mysql, I create a temporary user solely for the purpose of the dump (many times it&#39;s a one-time action), for the specific machine from which the dump is run, and provide this user with all necessary permissions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--host&lt;/code&gt;: I try not to dump from the same machine on which MySQL is running. If I do, I prefer to dump into a different disk from that on which the data and log files reside. The dump itself may create a heavy load on the machine (setting locks, performing lots of non cached IO operations). Since the target of the dump is mostly to create a backup on another machine, or set up replication on another machine, the dump has better not run from the MySQL machine.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--routines&lt;/code&gt;: It is really an annoyance to have to remember this flag. In contrast to --triggers, which is by default TRUE, the &lt;code&gt;--routines&lt;/code&gt; parameter is by default FALSE, which means if you forget it - you don&#39;t get the stored functions and procedures in your schema.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--master-data&lt;/code&gt;: I always enable binary logs on the MySQL nodes I work on. While binary logs may lead to more IO operations (writing binary logs make for more disk writes, obviously, but also disable some InnoDB optimizations), may consume more disk space (once I&#39;ve worked with a company which had such a burst of traffic, that the binary logs to completely filled their disk in less than one day). If binary logs are enabled, the &lt;code&gt;--master-data&lt;/code&gt; parameter allows for easy replication setup: the dump includes the &lt;code&gt;CHANGE MASTER TO MASTER_LOG_FILE=&#39;...&#39;, MASTER_LOG_POS=...&lt;/code&gt; statement, so no need to do stuff like &lt;code&gt;SHOW MASTER STATUS&lt;/code&gt; on the dumped node. Optionally, you can set &lt;code&gt;--master-data=2&lt;/code&gt; to have the statement commented.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--single-transaction&lt;/code&gt; &lt;code&gt;--skip-add-locks&lt;/code&gt; &lt;code&gt;--skip-lock-tables&lt;/code&gt;: When working with transactional-only storage engines (InnoDB is the most popular choice, but new engines are coming: Falcon, PBXT, Transactional-Maria, SolidDB and more), these parameters allow for a non-interruptive backup, which does not place read locks on all tables. It is possible to keep on reading and writing to the database while mysqldump is running with single transaction. Running in this mode does have its penalty: more IO operations (due to MVCC&#39;s duplication of data while many transactions access the same data for Read/Write). The server is likely to perform more slowly during the dump time.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--default-character-set=utf8&lt;/code&gt;: I&#39;ve seen so many MySQL installations in which world-wide textual data was stored in the Latin1 charset than I can remember. Many developers, who are testing using standard English data, are not even aware of the issues arrising from changing the data later on to utf8. But even those who are, are usually unaware of the necessity to configure the character set on a per connection basis, or for their specific clients (JDBC or PHP connectors, etc). mysqldump is no different, and if you have non-latin text in your tables, always remember to set this option.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--compress&lt;/code&gt;: when dumping to another machine, especially a remote one, using this option to GZIP the data between the MySQL server and the mysqldump client. This will make for more CPU operations, but CPU is usually cheap nowdays, and the compression may well save you hours of network transfer time.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
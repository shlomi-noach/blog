<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pseudo Gtid on code.openark.org</title>
    <link>/blog/tags/pseudo-gtid/</link>
    <description>Recent content in Pseudo Gtid on code.openark.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Fri, 20 Nov 2015 11:41:13 +0000</lastBuildDate>
    <atom:link href="/blog/tags/pseudo-gtid/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>State of automated recovery via Pseudo-GTID &amp; Orchestrator @ Booking.com</title>
      <link>/blog/2015/11/20/state-of-automated-recovery-via-pseudo-gtid-orchestrator-booking-com/</link>
      <pubDate>Fri, 20 Nov 2015 11:41:13 +0000</pubDate>
      
      <guid>/blog/2015/11/20/state-of-automated-recovery-via-pseudo-gtid-orchestrator-booking-com/</guid>
      <description>&lt;p&gt;This post sums up some of my work on MySQL resilience and high availability at &lt;a href=&#34;http://www.booking.com&#34;&gt;Booking.com&lt;/a&gt; by presenting the current state of automated master and intermediate master recoveries via &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo-GTID&lt;/a&gt; &amp;amp; &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Booking.com uses many different MySQL topologies, of varying vendors, configurations and workloads: Oracle MySQL, MariaDB, statement based replication, row based replication, hybrid, OLTP, OLAP, GTID (few), no GTID (most), Binlog Servers, filters, hybrid of all the above.&lt;/p&gt;
&lt;p&gt;Topologies size varies from a single server to many-many-many. Our typical topology has a master in one datacenter, a bunch of slaves in same DC, a slave in another DC acting as an intermediate master to further bunch of slaves in the other DC. Something like this, give or take:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/11/booking-topology-sample.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-7480 size-medium&#34; src=&#34;/blog/blog/assets/booking-topology-sample-300x169.png&#34; alt=&#34;booking-topology-sample&#34; width=&#34;300&#34; height=&#34;169&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;However as we are building our third data center (with MySQL deployments mostly completed) the graph turns more complex.&lt;/p&gt;
&lt;p&gt;Two high availability questions are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What happens when an intermediate master dies? What of all its slaves?&lt;/li&gt;
&lt;li&gt;What happens when the master dies? What of the entire topology?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is not a technical drill down into the solution, but rather on overview of the state. For more, please refer to recent presentations in &lt;a href=&#34;https://speakerdeck.com/shlominoach/managing-and-visualizing-your-replication-topologies-with-orchestrator&#34;&gt;September&lt;/a&gt; and &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;April&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At this time we have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pseudo-GTID deployed on all chains
&lt;ul&gt;
&lt;li&gt;Injected every 5 seconds&lt;/li&gt;
&lt;li&gt;Using the &lt;a href=&#34;http://code.openark.org/blog/mysql/pseudo-gtid-ascending&#34;&gt;monotonically ascending&lt;/a&gt; variation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pseudo-GTID based automated failover for intermediate masters on all chains&lt;/li&gt;
&lt;li&gt;Pseudo-GTID based automated failover for masters on roughly 30% of the chains.
&lt;ul&gt;
&lt;li&gt;The rest of 70% of chains are set for manual failover using Pseudo-GTID.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pseudo-GTID is in particular used for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Salvaging slaves of a dead intermediate master&lt;/li&gt;
&lt;li&gt;Correctly grouping and connecting slaves of a dead master&lt;/li&gt;
&lt;li&gt;Routine refactoring of topologies. This includes:
&lt;ul&gt;
&lt;li&gt;Manual repointing of slaves for various operations (e.g. offloading slaves from a busy box)&lt;/li&gt;
&lt;li&gt;Automated refactoring (for example, used by our automated upgrading script, which consults with &lt;em&gt;orchestrator&lt;/em&gt;, upgrades, shuffles slaves around, updates intermediate master, suffles back...)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(In the works), failing over binlog reader apps that audit our binary logs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!--more--&gt;Furthermore, Booking.com is also &lt;a href=&#34;https://www.percona.com/live/europe-amsterdam-2015/sessions/binlog-servers-bookingcom&#34;&gt;working on Binlog Servers&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;These take production traffic and offload masters and intermediate masters&lt;/li&gt;
&lt;li&gt;Often co-serve slaves using round-robin VIP, such that failure of one Binlog Server makes for simple slave replication self-recovery.&lt;/li&gt;
&lt;li&gt;Are interleaved alongside standard replication
&lt;ul&gt;
&lt;li&gt;At this time we have no &#34;pure&#34; Binlog Server topology in production; we always have normal intermediate masters and slaves&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This hybrid state makes for greater complexity:
&lt;ul&gt;
&lt;li&gt;Binlog Servers are not designed to participate in a game of changing masters/intermediate master, unless &lt;a href=&#34;http://jfg-mysql.blogspot.nl/2015/09/abstracting-binlog-servers-and-mysql-master-promotion-wo-reconfiguring-slaves.html&#34;&gt;successors come from their own sub-topology&lt;/a&gt;, which is not the case today.
&lt;ul&gt;
&lt;li&gt;For example, a Binlog Server that replicates directly from the master, cannot be repointed to just any new master.&lt;/li&gt;
&lt;li&gt;But can still hold valuable binary log entries that other slaves may not.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Are not actual MySQL servers, therefore of course cannot be promoted as masters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; &amp;amp; Pseudo-GTID makes this hybrid topology still resilient:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Orchestrator&lt;/em&gt; understands the limitations on the hybrid topology and can salvage slaves of 1st tier Binlog Servers via Pseudo-GTID&lt;/li&gt;
&lt;li&gt;In the case where the Binlog Servers were the most up to date slaves of a failed master, &lt;em&gt;orchestrator&lt;/em&gt; knows to first move potential candidates under the Binlog Server and then extract them out again.&lt;/li&gt;
&lt;li&gt;At this time Binlog Servers are still unstable. Pseudo-GTID allows us to comfortably test them on a large setup with reduced fear of losing slaves.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Otherwise &lt;em&gt;orchestrator&lt;/em&gt; already understands pure Binlog Server topologies and can do master promotion. When pure binlog servers topologies will be in production &lt;em&gt;orchestrator&lt;/em&gt; will be there to watch over.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;To date, Pseudo-GTID has high scores in automated failovers of our topologies; &lt;em&gt;orchestrator&#39;s&lt;/em&gt; &lt;a href=&#34;http://code.openark.org/blog/mysql/what-makes-a-mysql-server-failurerecovery-case&#34;&gt;holistic approach&lt;/a&gt; makes for reliable diagnostics; together they reduce our dependency on specific servers &amp;amp; hardware, physical location, latency implied by SAN devices.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator &amp; Pseudo-GTID for binlog reader failover</title>
      <link>/blog/2015/11/19/orchestrator-pseudo-gtid-for-binlog-reader-failover/</link>
      <pubDate>Thu, 19 Nov 2015 10:52:16 +0000</pubDate>
      
      <guid>/blog/2015/11/19/orchestrator-pseudo-gtid-for-binlog-reader-failover/</guid>
      <description>&lt;p&gt;One of our internal apps at &lt;strong&gt;Booking.com&lt;/strong&gt; audits changes to our tables on various clusters. We used to use &lt;em&gt;tungsten replicator&lt;/em&gt;, but have since migrated onto our own solution.&lt;/p&gt;
&lt;p&gt;We have a binlog reader (uses &lt;a href=&#34;https://github.com/zendesk/open-replicator&#34;&gt;open-replicator&lt;/a&gt;) running on a slave. It expects Row Based Replication, hence our slave runs with &lt;strong&gt;log-slave-updates&lt;/strong&gt;, &lt;strong&gt;binlog-format=&#39;ROW&#39;&lt;/strong&gt;, to translate from the master&#39;s Statement Based Replication. The binlog reader reads what it needs to read, audits what it needs to audit, and we&#39;re happy.&lt;/p&gt;
&lt;h3&gt;However what happens if that slave dies?&lt;/h3&gt;
&lt;p&gt;In such case we need to be able to point our binlog reader to another slave, and it needs to be able to pick up auditing from the same point.&lt;/p&gt;
&lt;p&gt;This sounds an awful lot like slave repointing in case of master/intermediate master failure, and indeed the solutions are similar. However our binlog reader is not a real MySQL server and does not understands replication. It does not really replicate, it just parses binary logs.&lt;/p&gt;
&lt;p&gt;We&#39;re also not using GTID. But we &lt;em&gt;are&lt;/em&gt; using Pseudo-GTID. As it turns out, the failover solution is already built in by &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;, and this is how it goes:&lt;/p&gt;
&lt;h3&gt;Normal execution&lt;/h3&gt;
&lt;p&gt;Our binlog app reads entries from the binary log. Some are of interest for auditing purposes, some are not. An occasional Pseudo-GTID entry is found, and is being stored to ZooKeeper tagged as  &#34;last seen and processed Pseudo-GTID&#34;.&lt;/p&gt;
&lt;h3&gt;Upon slave failure&lt;/h3&gt;
&lt;p&gt;We recognize the death of a slave; we have other slaves in the pool; we pick another. Now we need to find the coordinates from which to carry on.&lt;/p&gt;
&lt;p&gt;We read our &#34;last seen and processed Pseudo-GTID&#34;. Say it reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`_pseudo_gtid_hint__asc:56373F17:00000000012B1C8B:50EC77A1`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;. We now issue:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ orchestrator &lt;strong&gt;-c find-binlog-entry&lt;/strong&gt; &lt;strong&gt;-i new.slave.fqdn.com&lt;/strong&gt; --pattern=&#39;drop view if exists `meta`.`_pseudo_gtid_hint__asc:56373F17:00000000012B1C8B:50EC77A1`&#39;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The output of such command are the binlog coordinates of that same entry as found in the new slave&#39;s binlogs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;binlog.000148:43664433&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pseudo-GTID entries are only injected once every few seconds (&lt;strong&gt;5&lt;/strong&gt; in our case). Either:&lt;!--more--&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We are OK to reprocess up to &lt;strong&gt;5&lt;/strong&gt; seconds worth of data (and indeed we are, our mechanism is such that this merely overwrites our previous audit, no corruption happens)&lt;/li&gt;
&lt;li&gt;Or our binlog reader also keeps track of the number of events since the last processed Pseudo-GTID entry, skipping the same amount of events after failing over.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Planned failover&lt;/h3&gt;
&lt;p&gt;In case we plan to repoint our binlog reader to another slave, we can further use orchestrator&#39;s power in making an exact correlation between the binlog positions of two slaves. This has always been within its power, but only recently exposed as it own command. We can, at any stage:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ sudo orchestrator &lt;strong&gt;-c correlate-binlog-pos&lt;/strong&gt; -i current.instance.fqdn.com --binlog=binlog.002011:72656109 -d some.other.instance.fqdn.com&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The output is the binlog coordinates in &lt;strong&gt;some.other.instance.fqdn.com&lt;/strong&gt; that exactly correlate with &lt;strong&gt;binlog.002011:72656109&lt;/strong&gt; in &lt;strong&gt;current.instance.fqdn.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The case of failure of the binlog reader itself is also handled, but is not the subject of this blog post.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator visual cheatsheet, TL;DR the &#34;smart&#34; way</title>
      <link>/blog/2015/09/02/orchestrator-visual-cheatsheet-tldr-the-smart-way/</link>
      <pubDate>Wed, 02 Sep 2015 09:14:05 +0000</pubDate>
      
      <guid>/blog/2015/09/02/orchestrator-visual-cheatsheet-tldr-the-smart-way/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt;&lt;/strong&gt; is &lt;em&gt;really&lt;/em&gt; growing. And the amount of users (DBAs, sys admins) using it is growing. Which gives me a lot of immediate feedback in the form of &lt;em&gt;&#34;Look, there&#39;s just too many options to move slaves around! Which ones should we use?&#34;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;TL;DR look at the two visualized commands below&lt;/h3&gt;
&lt;p&gt;They are enough&lt;/p&gt;
&lt;h3&gt;The &#34;smart&#34; commands to end all commands&lt;/h3&gt;
&lt;p&gt;So all relocation commands are important, and give you fine-grained, pin-pointed control of the method of topology refactoring. However, most of the time you &lt;em&gt;just want to move those servers around&lt;/em&gt;. Which is why there&#39;s a new &#34;smart&#34; mode which support these two commands, which you should be happy using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;relocate&lt;/strong&gt;: move a single slave to another position&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;relocate-slaves&lt;/strong&gt;: move all/some slaves of some server to another position.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What makes these commands Smart? You can move slaves around from &lt;em&gt;anywhere&lt;/em&gt; to &lt;em&gt;anywhere&lt;/em&gt;. And &lt;em&gt;orchestrator&lt;/em&gt; figures out the bast execution path. If possible, it uses GTID. Not possible? Is Pseudo-GTID available? Great, using Pseudo-GTID. Oh, are there binlog servers involved? Really simple, use them. None of the above? &lt;em&gt;Orchestrator&lt;/em&gt; will use &#34;standard&#34; binlog file:pos math (with limitations). &lt;em&gt;Orchestrator&lt;/em&gt; will even figure out if multiple steps are necessary and will combine any of the above.&lt;/p&gt;
&lt;p&gt;So you don&#39;t have to remember all the possible ways and options. The visual cheatsheet now boils down to these two:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-cheatsheet-visualized-relocate.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7357&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-relocate.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-relocate&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-cheatsheet-visualized-relocate-slaves.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7350&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-relocate-slaves.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-relocate-slaves&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s take a slightly deeper look&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;relocate&lt;/h3&gt;
&lt;p&gt;Moves a single slave &lt;strong&gt;X&lt;/strong&gt; from any point to replicate another some server &lt;strong&gt;Z&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As usual, &lt;em&gt;orchestrator&lt;/em&gt; first confirms that &lt;strong&gt;X&lt;/strong&gt; &lt;em&gt;can&lt;/em&gt; replicate from &lt;strong&gt;Z&lt;/strong&gt; (&lt;strong&gt;Z&lt;/strong&gt; has &lt;strong&gt;log-slave-updates&lt;/strong&gt; or is a binlog server; binlog format compatible, etc.)&lt;/li&gt;
&lt;li&gt;With GTID/Pseudo-GTID, move from any point to any point&lt;/li&gt;
&lt;li&gt;With binlog servers, move around the binlog server environment (at this point you are not using binlog servers, so ignore)&lt;/li&gt;
&lt;li&gt;With normal replication, requires an &#34;atomic&#34; operation: either move the slave one level up, or make it replicate from a sibling.&lt;/li&gt;
&lt;li&gt;You can &lt;em&gt;relocate&lt;/em&gt; the same master, effectively repointing the slave back to its existing position. This serves to re-resolve master hostname; to reset relay logs; to verify slave is aligned with master.&lt;/li&gt;
&lt;li&gt;Or combination of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;relocate-slaves&lt;/h3&gt;
&lt;p&gt;Moves multiple slaves of server &lt;strong&gt;X&lt;/strong&gt; to replicate from some other server &lt;strong&gt;W&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By default moves all slaves of &lt;strong&gt;X&lt;/strong&gt;, where possible&lt;/li&gt;
&lt;li&gt;Each slave verified to be able to replicate from &lt;strong&gt;W&lt;/strong&gt;. Those that can&#39;t are left behind.&lt;/li&gt;
&lt;li&gt;Can filter using regular expression via &lt;strong&gt;--pattern=some?[reg]ex&lt;/strong&gt; on slave hostnames&lt;/li&gt;
&lt;li&gt;Can relocate under same master, effectively repointing all slaves (see above explanation)&lt;/li&gt;
&lt;li&gt;Can relocate below one of the very slaves of X. If Y is in itself a slave of X and you&#39;re executing:&lt;br /&gt;
&lt;strong&gt;orchestrator -c relocate-slaves -i X -d Y&lt;/strong&gt;&lt;br /&gt;
then &lt;strong&gt;Y&lt;/strong&gt; is excluded from the list of relocated slaves. This effectively means &#34;make &lt;strong&gt;Y&lt;/strong&gt; local master of its current siblings&#34;. Very cool stuff.&lt;/li&gt;
&lt;li&gt;When binlog servers involved, simple math-less repointing takes place&lt;/li&gt;
&lt;li&gt;When GTID involved, let MySQL/MariaDB (both supported) do the math on a per-server basis&lt;/li&gt;
&lt;li&gt;When Pseudo-GTID involved, &lt;em&gt;greatly&lt;/em&gt; optimize by dividing into &lt;a href=&#34;https://en.wikipedia.org/wiki/Equivalence_class&#34;&gt;equivalence classes&lt;/a&gt; and only doing the math on a representative of each class.&lt;/li&gt;
&lt;li&gt;Or combination of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What about the other commands?&lt;/h3&gt;
&lt;p&gt;The above covers such commands as &lt;strong&gt;move-up&lt;/strong&gt;, &lt;strong&gt;move-below&lt;/strong&gt;, &lt;strong&gt;repoint&lt;/strong&gt;, &lt;strong&gt;repoint-slaves&lt;/strong&gt;, &lt;strong&gt;match-below&lt;/strong&gt;, &lt;strong&gt;multi-match-slaves&lt;/strong&gt;, &lt;strong&gt;regroup-slaves&lt;/strong&gt; and more. It does not cover &lt;strong&gt;enslave-master&lt;/strong&gt; and &lt;strong&gt;make-co-master&lt;/strong&gt; which are a bit different.&lt;/p&gt;
&lt;p&gt;My guess is you can pass &lt;strong&gt;98%&lt;/strong&gt; of your operations with &lt;strong&gt;relocate &lt;/strong&gt;and &lt;strong&gt;relocate-slaves&lt;/strong&gt;. Otherwise just run &lt;em&gt;orchestrator&lt;/em&gt; with no arguments nor options to get a full-blown breakdown of available commands.&lt;/p&gt;
&lt;h3&gt;GUI drag-n-drop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;relocate-slaves&lt;/strong&gt; is achieved by dragging the slaves of an instance on top of a new master, as follows:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-before.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7372&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-before.png&#34; alt=&#34;orchestrator-relocate-slaves-before&#34; width=&#34;994&#34; height=&#34;369&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-hover.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7373&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-hover.png&#34; alt=&#34;orchestrator-relocate-slaves-hover&#34; width=&#34;996&#34; height=&#34;339&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-drag1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7377&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-drag1.png&#34; alt=&#34;orchestrator-relocate-slaves-drag&#34; width=&#34;980&#34; height=&#34;363&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-after.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7375&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-after.png&#34; alt=&#34;orchestrator-relocate-slaves-after&#34; width=&#34;993&#34; height=&#34;345&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Find latest &lt;em&gt;orchestrator&lt;/em&gt; release at &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;https://github.com/outbrain/orchestrator/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.4.340: GTID, binlog servers, Smart Mode, failovers and lots of goodies</title>
      <link>/blog/2015/09/01/orchestrator-1-4-340-gtid-binlog-servers-smart-mode-failovers-and-lots-of-goodies/</link>
      <pubDate>Tue, 01 Sep 2015 12:10:15 +0000</pubDate>
      
      <guid>/blog/2015/09/01/orchestrator-1-4-340-gtid-binlog-servers-smart-mode-failovers-and-lots-of-goodies/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;&lt;strong&gt;Orchestrator&lt;/strong&gt; 1.4.340 is released&lt;/a&gt;. Not quite competing with the MySQL latest changelog, and as I haven&#39;t blogged about &lt;em&gt;orchestrator&lt;/em&gt; featureset in a while, this is a quick listing of &lt;em&gt;orchestrator&lt;/em&gt; features available since my last publication:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Supports &lt;strong&gt;GTID&lt;/strong&gt; (Oracle &amp;amp; MariaDB)
&lt;ul&gt;
&lt;li&gt;GTID still not being used in automated recovery -- in progress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable-gtid&lt;/strong&gt;, &lt;strong&gt;disable-gtid&lt;/strong&gt;, &lt;strong&gt;skip-query&lt;/strong&gt; for GTID commands&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Supports &lt;strong&gt;binlog servers&lt;/strong&gt; (MaxScale)
&lt;ul&gt;
&lt;li&gt;Discovery &amp;amp; operations on binlog servers&lt;/li&gt;
&lt;li&gt;Understanding slave repositioning in a binlog-server architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart mode&lt;/strong&gt;: relocate &amp;amp; relocate-below commands (or Web/GUI drag-n-drop) let &lt;em&gt;orchestrator&lt;/em&gt; figure out the best way of slave repositioning. &lt;em&gt;Orchestrator&lt;/em&gt; picks from GTID, Pseudo GTID, binlog servers, binlog file:pos math (and more) options, or combinations of the above. Fine grained commands still there, but mostly you won&#39;t need them.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Crash recoveries&lt;/strong&gt; (did you know &lt;em&gt;orchestrator&lt;/em&gt; does that?):
&lt;ul&gt;
&lt;li&gt;For intermediate master recovery: improved logic in picking the best recovery plan (prefer in-DC, prefer promoting local slave, supporting binlog server topologies, ...)&lt;/li&gt;
&lt;li&gt;For master recovery: even better slave promotion; supports &lt;em&gt;candidate slaves &lt;/em&gt;(prefer promoting such slaves); supports binlog server shared topologies&lt;/li&gt;
&lt;li&gt;Better auditing and logging of recovery cases&lt;/li&gt;
&lt;li&gt;Better analysis of crash scenarios, also in the event of lost VIPs, hanging connections; emergent checks in crash suspected scenarios&lt;/li&gt;
&lt;li&gt;recover-lite: do all topology-only recovery steps, without invoking external processes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better browser support&lt;/strong&gt;: used to only work on Firefox and Chrome (and the latter has had issues), the Web UI should now work well on all browsers, at the cost of reduced &lt;strong&gt;d3&lt;/strong&gt; animation. More work still in progress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Faster&lt;/strong&gt;, more parallel, less blocking operations on all counts; removed a lots of serialized code; less locks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web enhancements&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;More verbose drag-n-drop (operation hint; color hints)&lt;/li&gt;
&lt;li&gt;Drag-n-drop for &lt;em&gt;slaves-of-a-server&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Replication/crash analysis dashboard&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pools&lt;/strong&gt;: &lt;em&gt;orchestrator&lt;/em&gt; can be &lt;em&gt;told&lt;/em&gt; about instance-to-pool association (&lt;strong&gt;submit-pool-instances&lt;/strong&gt; command)
&lt;ul&gt;
&lt;li&gt;And can then present pool status (web)&lt;/li&gt;
&lt;li&gt;Or pool hints within topologies (web)&lt;/li&gt;
&lt;li&gt;Or queried for all pools (&lt;strong&gt;cluster-pool-instances&lt;/strong&gt; command)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other:
&lt;ul&gt;
&lt;li&gt;Supports MySQL &lt;strong&gt;5.7&lt;/strong&gt; (tested with &lt;strong&gt;5.7.8&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Configurable graphite path for metrics&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--noop&lt;/strong&gt; flag; does all the work except for actually changing master on slaves. Shows intentions.&lt;/li&gt;
&lt;li&gt;Web (or cli &lt;strong&gt;which-cluster-osc-slaves&lt;/strong&gt; command) provide list of control slaves to use in &lt;strong&gt;pt-osc&lt;/strong&gt; operation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hostname-unresolve&lt;/strong&gt;: force &lt;em&gt;orchestrator&lt;/em&gt; to unresolve a fqdn into VIP/CNAME/... when issuing a CHANGE MASTER TO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3rd party contributions (hey, thanks!) include:
&lt;ul&gt;
&lt;li&gt;More &amp;amp; better SSL support&lt;/li&gt;
&lt;li&gt;Vagrant templates&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For developers:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Orchestrator&lt;/em&gt; now go-gettable. Just &lt;strong&gt;go get github.com/outbrain/orchestrator&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Improved build script; supports more architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Also consider these manuals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual&#34;&gt;The Orchestrator Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-deployment&#34;&gt;Orchestrator deployment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-first-steps&#34;&gt;Orchestrator first steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-for-developers&#34;&gt;Orchestrator for developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; is free and open source (Apache 2.0 License).&lt;/p&gt;
&lt;p&gt;I&#39;ll be &lt;a href=&#34;https://www.percona.com/live/europe-amsterdam-2015/sessions/managing-and-visualizing-your-replication-topologies-orchestrator&#34;&gt;speaking about orchestrator in PerconaLive Amsterdam&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pseudo GTID, ASCENDING</title>
      <link>/blog/2015/07/29/pseudo-gtid-ascending/</link>
      <pubDate>Wed, 29 Jul 2015 12:59:50 +0000</pubDate>
      
      <guid>/blog/2015/07/29/pseudo-gtid-ascending/</guid>
      <description>&lt;p&gt;Pseudo GTID is a technique where we inject Globally Unique entries into MySQL, gaining GTID abilities without using GTID. It is supported by &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;&lt;/strong&gt; and described in more detail &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;http://code.openark.org/blog/tag/pseudo-gtid&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual#pseudo-gtid&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Quick recap: we can join two slaves to replicate from one another even if they never were in parent-child relationship, based on our uniquely identifiable entries which can be found in the slaves&#39; binary logs or relay logs. Having Pseudo-GTID injected and controlled by us allows us to optimize failovers into quick operations, especially where a large number of server is involved.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ascending Pseudo-GTID&lt;/strong&gt; further speeds up this process for delayed/lagging slaves.&lt;/p&gt;
&lt;h3&gt;Recap, visualized&lt;/h3&gt;
&lt;p&gt;(but do look at the &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;presentation&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/pseudo-gtid-quick1.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7303&#34; src=&#34;/blog/blog/assets/pseudo-gtid-quick1.png&#34; alt=&#34;pseudo-gtid-quick&#34; width=&#34;636&#34; height=&#34;366&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find last pseudo GTID in slave’s binary log (or last applied one in relay log)&lt;/li&gt;
&lt;li&gt;Search for exact match on new master’s binary logs&lt;/li&gt;
&lt;li&gt;Fast forward both through successive identical statements until end of slave’s applied entries is reached&lt;/li&gt;
&lt;li&gt;Point slave into cursor position on master&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;What happens if the slave we wish to reconnect is lagging? Or perhaps it is a delayed replica, set to run &lt;strong&gt;24&lt;/strong&gt; hours behind its master?&lt;/p&gt;
&lt;p&gt;The naive approach would expand bullet &lt;strong&gt;#2&lt;/strong&gt; into:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search for exact match on master’s last binary logs&lt;/li&gt;
&lt;li&gt;Unfound? Move on to previous (older) binary log on master&lt;/li&gt;
&lt;li&gt;Repeat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last Pseudo-GTID executed by the slave was issued by the master over &lt;strong&gt;24&lt;/strong&gt; hours ago. Suppose the master generates one binary log per hour. This means we would need to full-scan &lt;strong&gt;24&lt;/strong&gt; binary logs of the master where the entry will not be found; to only be matched in the &lt;strong&gt;25th&lt;/strong&gt; binary log (it&#39;s an off-by-one problem, don&#39;t hold the exact number against me).&lt;/p&gt;
&lt;h3&gt;Ascending Pseudo GTID&lt;/h3&gt;
&lt;p&gt;Since we control the generation of Pseudo-GTID, and since we control the search for Pseudo-GTID, we are free to choose the form of Pseudo-GTID entries. We recently switched into using Ascending Pseudo-GTID entries, and this works like a charm. Consider these Pseudo-GTID entries:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364E3:0000000000056EE2:6DD57B85&lt;/strong&gt;`
drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364E8:0000000000056EEC:ACF03802&lt;/strong&gt;`
drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364ED:0000000000056EF8:06279C24&lt;/strong&gt;`
drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364F2:0000000000056F02:19D785E4&lt;/strong&gt;`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entries are ascending in lexical order. The above is generated using a UTC timestamp, along with other watchdog/random values. For a moment let&#39;s trust that our generation is indeed always ascending. How does that help us?&lt;/p&gt;
&lt;p&gt;Suppose the last entry found in the slave is&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364E3:0000000000056EE2:6DD57B85&lt;/strong&gt;`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;And this is what we&#39;re to search on the master&#39;s binary logs. Starting with the optimistic hope that the entry is in the master&#39;s last binary log, we start reading. By nature of binary logs we have to scan them sequentially from start to end. As we read the binary log entries, we soon meet the first Pseudo-GTID injection, and it reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B730E6:0000000000058F02:19D785E4&lt;/strong&gt;`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;At this stage we know we can completely skip scanning the rest of the binary log. Our entry will not be there: this entry is larger than the one we&#39;re looking for, and they&#39;ll only get larger as we get along in the binary log. It is therefore safe to ignore the rest of this file and move on to the next-older binary log on the master, to repeat our search there.&lt;/p&gt;
&lt;p&gt;Binary logs where the entry cannot be in are only briefly examined: &lt;em&gt;orchestrator&lt;/em&gt; will probably read no more than first &lt;strong&gt;1,000&lt;/strong&gt; entries or so (can&#39;t give you a number, it&#39;s your workload) before giving up on the binary log.&lt;/p&gt;
&lt;p&gt;On every topology chain we have &lt;strong&gt;2&lt;/strong&gt; delayed replica slaves, to help us out in the case we make a grave mistake of DELETing the wrong data. These slaves would take, on some chains, &lt;strong&gt;5-6&lt;/strong&gt; minutes to reconnect to a new master using Pseudo-GTID, since it required scanning many many GBs of binary logs. This is no longer the case; we&#39;ve reduced scan time for such servers to about &lt;strong&gt;25s&lt;/strong&gt; at worst, and much quicker on average. There can still be dozens of binary logs to open, but all but one are given up very quickly. I should stress that those &lt;strong&gt;25s&lt;/strong&gt; are nonblocking for other slaves which are mote up to date than the delayed replicas.&lt;/p&gt;
&lt;h3&gt;Can there be a mistake?&lt;/h3&gt;
&lt;p&gt;Notice that the above algorithm does not require each and every entry to be ascending; it just compares the first entry in each binlog to determine whether our target entry is there or not. This means if we&#39;ve messed up our Ascending order and injected some out-of-order entries, we can still get away with it -- as long as those entries are not the first ones in the binary log, nor are they the last entries executed by the slave.&lt;/p&gt;
&lt;p&gt;But why be so negative? We&#39;re using UTC timestamp as the major sorting order, and inject Pseudo-GTID every &lt;strong&gt;5&lt;/strong&gt; seconds; even with leap second we&#39;re comfortable.&lt;/p&gt;
&lt;p&gt;On my TODO is to also include a &#34;Plan B&#34; full-scan search: if the Ascending algorithm fails, we can still opt for the full scan option. So there would be no risk at all.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;We inject Pseudo-GTID via event-scheduler. These are the good parts of the event definition:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;create event if not exists
  create_pseudo_gtid_event
  on schedule every 5 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @connection_id := connection_id();
      set @now := now();
      set @rand := floor(rand()*(1 &amp;lt;&amp;lt; 32));
      &lt;strong&gt;set @pseudo_gtid_hint := concat_ws(&#39;:&#39;, lpad(hex(unix_timestamp(@now)), 8, &#39;0&#39;), lpad(hex(@connection_id), 16, &#39;0&#39;), lpad(hex(@rand), 8, &#39;0&#39;));&lt;/strong&gt;
&lt;strong&gt;
      set @_create_statement := concat(&#39;drop &#39;, &#39;view if exists `meta`.`_pseudo_gtid_&#39;, &#39;hint__asc:&#39;, @pseudo_gtid_hint, &#39;`&#39;);&lt;/strong&gt;
      PREPARE st FROM @_create_statement;
      EXECUTE st;
      DEALLOCATE PREPARE st;
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;We accompany this by the following &lt;em&gt;orchestrator&lt;/em&gt; configuration:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt; &#34;PseudoGTIDPattern&#34;: &#34;drop view if exists .*?`_pseudo_gtid_hint__&#34;,
 &#34;PseudoGTIDMonotonicHint&#34;: &#34;asc:&#34;,&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&#34;PseudoGTIDMonotonicHint&#34;&lt;/strong&gt; notes a string; if that string (&lt;strong&gt;&#34;asc:&#34;&lt;/strong&gt;) is found in the slave&#39;s Pseudo-GTID entry, then the entry is assumed to have been injected as part of ascending entries, and the optimization kicks in.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual#pseudo-gtid&#34;&gt;The Manual&lt;/a&gt; has more on this.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Speaking at Percona Live: Pseudo GTID and Easy Replication Topology Management</title>
      <link>/blog/2015/03/31/speaking-at-percona-live-pseudo-gtid-and-easy-replication-topology-management/</link>
      <pubDate>Tue, 31 Mar 2015 17:42:21 +0000</pubDate>
      
      <guid>/blog/2015/03/31/speaking-at-percona-live-pseudo-gtid-and-easy-replication-topology-management/</guid>
      <description>&lt;p&gt;In two weeks time I will be presenting &lt;a href=&#34;https://www.percona.com/live/mysql-conference-2015/sessions/pseudo-gtid-and-easy-replication-management&#34;&gt;Pseudo GTID and Easy Replication Topology Management&lt;/a&gt; at Percona Live. From the time I submitted the proposal a LOT has been developed, experimented, deployed and used with both &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; and with &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;. In my talk I will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suggest that you skip the &#34;to GTID or not to GTID&#34; question and go for the lightweight Pseudo GTID&lt;/li&gt;
&lt;li&gt;Show how Pseudo GTID is used in production to recover from various replication failures and server crashes&lt;/li&gt;
&lt;li&gt;Do an outrageous demonstration&lt;/li&gt;
&lt;li&gt;Tell you about 50,000 successful experiments and tests done in production&lt;/li&gt;
&lt;li&gt;Show off orchestrator and its support for Pseudo GTID, including automated crash analysis and recovery mechanism.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will further show how the orchestrator tooling makes for a less restrictive, more performant, less locking, non-intrusive, trusted and lightweight replication topology management solution.&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/03/orchestrator-topology-simple.png&#34;&gt;&lt;img class=&#34;wp-image-7206 size-full&#34; src=&#34;/blog/blog/assets/orchestrator-topology-simple.png&#34; alt=&#34;orchestrator-topology-simple&#34; width=&#34;1010&#34; height=&#34;286&#34; /&gt;&lt;/a&gt; An anonymized topology&lt;/blockquote&gt;
&lt;p&gt;Please come by my talk! &lt;/p&gt;
&lt;p&gt;Slides: &lt;/p&gt;
&lt;p&gt;[speakerdeck https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management]&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Speaking at FOSDEM: Pseudo GTID and easy replication management</title>
      <link>/blog/2015/01/29/speaking-at-fosdem-pseudo-gtid-and-easy-replication-management/</link>
      <pubDate>Thu, 29 Jan 2015 21:06:10 +0000</pubDate>
      
      <guid>/blog/2015/01/29/speaking-at-fosdem-pseudo-gtid-and-easy-replication-management/</guid>
      <description>&lt;p&gt;This coming Sunday I&#39;ll be presenting &lt;a href=&#34;https://fosdem.org/2015/schedule/event/pseudo_gtid/&#34;&gt;Pseudo GTID and easy replication management&lt;/a&gt; at FOSDEM, Brussels.&lt;/p&gt;
&lt;p&gt;There&#39;s been a lot of development on &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; these last few weeks. In this talk I&#39;ll show you how you can use Pseudo GTID instead of &#34;normal&#34; GTID to easily repoint your slaves, recover from intermediate master failure, promote slaves to masters as well as emply crash safe replication without crash safe replication.&lt;/p&gt;
&lt;p&gt;Moreover, I will show how you can achieve all the above with &lt;em&gt;less constraints&lt;/em&gt; than GTID, and for bulk operations -- with &lt;em&gt;less overhead&lt;/em&gt; and in &lt;em&gt;shorter time&lt;/em&gt;. You will also see that Pseudo GTID is a non intrusive solution which does not require you to change anything in your topologies.&lt;/p&gt;
&lt;p&gt;Moral: I&#39;ll try and convince you to &lt;em&gt;drop your plans for using GTID&lt;/em&gt; in favor of &lt;em&gt;Pseudo GTID&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We will be employing Pseudo GTID as the basis for high availability and failover at Booking.com on many topologies, and as a safety mechanism in other topologies where we will employ &lt;a href=&#34;http://blog.booking.com/mysql_slave_scaling_and_more.html&#34;&gt;Binlog servers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;http://www.slideshare.net/shlominoach/pseudo-gtid-easy-replication-topology-management-fosdem&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Semi-automatic slave/master promotion via Pseudo GTID</title>
      <link>/blog/2014/11/10/semi-automatic-slavemaster-promotion-via-pseudo-gtid/</link>
      <pubDate>Mon, 10 Nov 2014 07:56:58 +0000</pubDate>
      
      <guid>/blog/2014/11/10/semi-automatic-slavemaster-promotion-via-pseudo-gtid/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt; release &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;1.2.7-beta&lt;/a&gt; now supports semi-automatic slave promotion to master upon master death, via &lt;a href=&#34;code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-make-master-highlighted.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7150&#34; src=&#34;/blog/blog/assets/orchestrator-make-master-highlighted.png&#34; alt=&#34;orchestrator-make-master-highlighted&#34; width=&#34;809&#34; height=&#34;363&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;When the master is dead, &lt;em&gt;orchestrator&lt;/em&gt; automatically picks the most up-to-date slaves and marks them as &lt;strong&gt;&#34;Master candidates&#34;&lt;/strong&gt;. It allows a &lt;strong&gt;/api/make-master&lt;/strong&gt; call on such a slave (S), in which case it uses &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; to enslave its siblings, and set S as &lt;strong&gt;read-only = 0&lt;/strong&gt;. All we need to do is click the &lt;strong&gt;&#34;Make master&#34;&lt;/strong&gt; button.&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-make-master-confirm1.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7145&#34; src=&#34;/blog/blog/assets/orchestrator-make-master-confirm1.png&#34; alt=&#34;orchestrator-make-master-confirm&#34; width=&#34;946&#34; height=&#34;367&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, &lt;strong&gt;&#34;OK&#34;&lt;/strong&gt;. A moment later:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-make-master-refactored1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7146&#34; src=&#34;/blog/blog/assets/orchestrator-make-master-refactored1-1024x256.png&#34; alt=&#34;orchestrator-make-master-refactored&#34; width=&#34;1024&#34; height=&#34;256&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;See how the two slaves &lt;strong&gt;22988&lt;/strong&gt;, &lt;strong&gt;22989&lt;/strong&gt; are happily replicating from &lt;strong&gt;22990&lt;/strong&gt;. Turning them into &lt;strong&gt;22990&lt;/strong&gt;&#39;s slave was possible even though their shared master was dead and were stopped at different replication positions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22990&lt;/strong&gt; is now writeable, and its on you to disconnect from its old master and to direct your application into this newly promoted instance.&lt;/p&gt;
&lt;h4&gt;Local master promotion&lt;/h4&gt;
&lt;p&gt;Likewise, a semi-automated solution for the corruption of a local master is in place. Consider the following, where &lt;strong&gt;22989&lt;/strong&gt; is dead/inaccessible. &lt;strong&gt;22988&lt;/strong&gt; and &lt;strong&gt;22990&lt;/strong&gt; are stuck in replication:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/11/orchestrator-make-local-master.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7164&#34; src=&#34;/blog/blog/assets/orchestrator-make-local-master-1024x263.png&#34; alt=&#34;orchestrator-make-local-master&#34; width=&#34;1024&#34; height=&#34;263&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; detects this situation and picks the most up-to-date slave, marking it as candidate for promotion. Click &lt;strong&gt;&#34;Make lock master&#34;&lt;/strong&gt; to get:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/11/orchestrator-make-local-master-confirm.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7165&#34; src=&#34;/blog/blog/assets/orchestrator-make-local-master-confirm-1024x257.png&#34; alt=&#34;orchestrator-make-local-master-confirm&#34; width=&#34;1024&#34; height=&#34;257&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Sure, OK:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/11/orchestrator-make-local-master-refactored.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7166&#34; src=&#34;/blog/blog/assets/orchestrator-make-local-master-refactored-1024x276.png&#34; alt=&#34;orchestrator-make-local-master-refactored&#34; width=&#34;1024&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;And now &lt;strong&gt;22990&lt;/strong&gt; takes over instead of &lt;strong&gt;22989&lt;/strong&gt;, enslaving &lt;strong&gt;22988&lt;/strong&gt;, both running happily ever after.&lt;/p&gt;
&lt;h4&gt; Automation&lt;/h4&gt;
&lt;p&gt;The above buttons are just convenience methods. You don&#39;t strictly need visualization/GUI for that. Everything is supported by the API, and can be used by a fully automated monitoring system. More to come in &lt;em&gt;orchestrator&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Refactoring replication topologies with Pseudo GTID: a visual tour</title>
      <link>/blog/2014/10/27/refactoring-replication-topologies-with-pseudo-gtid-a-visual-tour/</link>
      <pubDate>Mon, 27 Oct 2014 11:55:39 +0000</pubDate>
      
      <guid>/blog/2014/10/27/refactoring-replication-topologies-with-pseudo-gtid-a-visual-tour/</guid>
      <description>&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases/tag/v1.2.1-beta&#34;&gt;1.2.1-beta&lt;/a&gt; supports Pseudo GTID (&lt;a href=&#34;http://code.openark.org/blog/mysql/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure&#34;&gt;read announcement&lt;/a&gt;): a means to refactor the replication topology and connect slaves even without direct relationship; even across failed servers. This post illustrates two such scenarios and shows the visual way of mathcing/re-synching slaves.&lt;/p&gt;
&lt;p&gt;Of course, orchestrator is not just a GUI tool; anything done with drag-and-drop is also done via web API (in fact, the drag-and-drop invoke the web API) as well as via command line. I&#39;m mentioning this as this is the grounds for failover automation planned for the future.&lt;/p&gt;
&lt;h4&gt;Scenario 1: the master unexpectedly dies&lt;/h4&gt;
&lt;p&gt;The master crashes and cannot be contacted. All slaves are stopped as effect, but each in a different position. Some managed to salvage relay logs just before the master dies, some didn&#39;t. In our scenario, all three slaves are at least caught up with the relay log (that is, whatever they managed to pull through the network, they already managed to execute). So they&#39;re otherwise sitting idle waiting for something to happen. Well, something&#39;s about to happen.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7090&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-1024x323.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master&#34; width=&#34;1024&#34; height=&#34;323&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Note the green &#34;Safe mode&#34; button to the right. This means operation is through calculation of binary log files &amp;amp; positions with relation to one&#39;s master. But the master is now dead, so let&#39;s switch to adventurous mode; in this mode we can drag and drop slaves onto instances normally forbidden. At this stage the web interface allows us to drop a slave onto its sibling or any of its ancestors (including its very own parent, which is a means of reconnecting a slave with its parent). Anyhow:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master-pseudo-gtid-mode.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7091&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-pseudo-gtid-mode-1024x296.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master-pseudo-gtid-mode&#34; width=&#34;1024&#34; height=&#34;296&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;We notice that orchestrator is already kind enough to say which slave is best candidate to be the new master (&lt;strong&gt;127.0.0.1:22990&lt;/strong&gt;): this is the slave (or one of the slaves) with most up-to-date data. So we choose to take another server and make it a slave of &lt;strong&gt;127.0.0.1:22990&lt;/strong&gt;:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master-begin-drag.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7093&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-begin-drag.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master-begin-drag&#34; width=&#34;770&#34; height=&#34;349&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;And drop:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master-drop.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7094&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-drop.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master-drop&#34; width=&#34;799&#34; height=&#34;366&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;There we have it: although their shared master is inaccessible, and the two slave&#39;s binary log file names &amp;amp; position mean nothing to each other, we are able to correctly match the two and make one child of the other:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master-refactored-1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7095&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-refactored-1-1024x269.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master-refactored-1&#34; width=&#34;1024&#34; height=&#34;269&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Likewise, we do the same with &lt;strong&gt;127.0.0.1:22988&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master-begin-drag-2.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7096&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-begin-drag-2-1024x279.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master-begin-drag-2&#34; width=&#34;1024&#34; height=&#34;279&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;And end up with our (almost) final topology:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-master-refactored-2.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7097&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-master-refactored-2-1024x255.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-master-refactored-2&#34; width=&#34;1024&#34; height=&#34;255&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Notice how the two slaves &lt;strong&gt;22988&lt;/strong&gt;, &lt;strong&gt;22989&lt;/strong&gt; are happily replicating from &lt;strong&gt;22990&lt;/strong&gt;. As far as they&#39;re concerned, there is no problem in the topology any more. Now it&#39;s your decision: do you decommission the old master? You will need to &lt;strong&gt;RESET SLAVE&lt;/strong&gt; on &lt;strong&gt;22990&lt;/strong&gt; (can do via &lt;em&gt;orchestrator&lt;/em&gt;), turn off &lt;strong&gt;22990&lt;/strong&gt;&#39;s &lt;strong&gt;read_only&lt;/strong&gt; (can do via &lt;em&gt;orchestrator&lt;/em&gt;) and change DNS entries (or what have you).&lt;/p&gt;
&lt;h4&gt;Scenario 2: a local master (&#34;relay-master&#34;) unexpectedly dies&lt;/h4&gt;
&lt;p&gt;In this scenario we have a &lt;a href=&#34;http://code.openark.org/blog/mysql/using-deep-nested-replication-topologies&#34;&gt;deep nested topology&lt;/a&gt;, and a local master died. What of its slaves?&lt;/p&gt;
&lt;blockquote&gt; &lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7100&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-1024x237.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master&#34; width=&#34;1024&#34; height=&#34;237&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;We choose one of the children and drag it over onto the master, which is up and healthy:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-begin-drag.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7101&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-begin-drag-1024x292.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-begin-drag&#34; width=&#34;1024&#34; height=&#34;292&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;As you can see we are allowed (green instances are allowed drop places) to drop &lt;strong&gt;22989&lt;/strong&gt; on its sibling and on its grandparent, the latter bypassing a broken connection. There &lt;em&gt;is no&lt;/em&gt; connection between the two!&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-drop.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7102&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-drop-1024x282.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-drop&#34; width=&#34;1024&#34; height=&#34;282&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;And we get a new topology:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-refactored-1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7103&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-refactored-1-1024x264.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-refactored-1&#34; width=&#34;1024&#34; height=&#34;264&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;22989&lt;/strong&gt; is now lagging, but on the right path! Let&#39;s do the same for &lt;strong&gt;22988&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-begin-drag-2.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7104&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-begin-drag-2-1024x276.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-begin-drag-2&#34; width=&#34;1024&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;And finally:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-refactored-2.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7105&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-refactored-2.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-refactored-2&#34; width=&#34;809&#34; height=&#34;357&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Great success! &lt;strong&gt;22989&lt;/strong&gt; already caught up, &lt;strong&gt;22988&lt;/strong&gt; on the way, victory is ours!&lt;/p&gt;
&lt;p&gt;The real fun, of course, is to execute with &lt;strong&gt;--debug&lt;/strong&gt; and review the DEBUG messages as orchestrator seeks, finds, matches and follows up on Pseudo GTID entries in the binary logs. We each have our pleasures.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.2.1 BETA: Pseudo GTID support, reconnect slaves even after master failure</title>
      <link>/blog/2014/10/27/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure/</link>
      <pubDate>Mon, 27 Oct 2014 11:51:51 +0000</pubDate>
      
      <guid>/blog/2014/10/27/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure/</guid>
      <description>&lt;p&gt;&lt;em&gt;orchestrator&lt;/em&gt; &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases/tag/v1.2.1-beta&#34;&gt;1.2.1 BETA is released&lt;/a&gt;. This version supports &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt;, and provides one with powerful refactoring of one&#39;s replication topologies, even across failed instances.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-pseudo-gtid-dead-relay-master-begin-drag.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7101&#34; src=&#34;/blog/blog/assets/orchestrator-pseudo-gtid-dead-relay-master-begin-drag-1024x292.png&#34; alt=&#34;orchestrator-pseudo-gtid-dead-relay-master-begin-drag&#34; width=&#34;1024&#34; height=&#34;292&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Depicted: moving a slave up the topology even though its local master is inaccessible&lt;/blockquote&gt;
&lt;h4&gt;Enabling Pseudo-GTID&lt;/h4&gt;
&lt;p&gt;You will need to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Inject a periodic unique entry onto your binary logs&lt;/li&gt;
&lt;li&gt;Configure &lt;em&gt;orchestrator&lt;/em&gt; to recognize said entry.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Pseudo GTID injection example&lt;/h4&gt;
&lt;p&gt;We will use the &lt;a href=&#34;http://dev.mysql.com/doc/refman/5.5/en/events.html&#34;&gt;event scheduler&lt;/a&gt; (must be enabled) to inject an entry every &lt;strong&gt;10&lt;/strong&gt; seconds, recognized both in statement-based and row-based replication.&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;create database if not exists meta;

drop event if exists meta.create_pseudo_gtid_view_event;

delimiter ;;
create event if not exists
  meta.create_pseudo_gtid_view_event
  on schedule every 10 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @pseudo_gtid := uuid();
      set @_create_statement := concat(&#39;create or replace view meta.pseudo_gtid_view as select 
&lt;/blockquote&gt;
Make sure to enable &lt;em&gt;event_scheduler&lt;/em&gt; in your &lt;strong&gt;my.cnf&lt;/strong&gt; config file.
An entry in the binary logs would look like this:&lt;!--more--&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql [localhost] {msandbox} (meta) &amp;gt; show binlog events in &#39;mysql-bin.000002&#39; LIMIT 2,1;
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                                                                                                                                                                                               |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000002 | 388 | Query      |         1 |         669 | use `meta`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_view` AS select &#39;2f6ad653-5db3-11e4-b91d-3c970ea31ea8&#39; as pseudo_gtid_unique_val from dual |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entry will be unique, and orchestrator will be able to find it in the binary log if configured with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;{
    ...
    &#34;PseudoGTIDPattern&#34;: &#34;CREATE OR REPLACE .*? VIEW `pseudo_gtid_view` AS select&#34;
}&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The value of &lt;strong&gt;&#34;PseudoGTIDPattern&#34;&lt;/strong&gt; is a regular expression which must match the Pseudo GTID entries in the binary log, and &lt;em&gt;nothing but those entries&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Pre-release&lt;/h4&gt;
&lt;p&gt;This is BETA quality; though I have high confidence in its safety: the process of matching the binary log entries makes for a self-validating mechanism. The process will abort on any mismatch or uncertainty.&lt;/p&gt;
&lt;p&gt;Still there can be use cases I haven&#39;t encountered yet. You input is appreciated!&lt;/p&gt;
&#39;, @pseudo_gtid, &#39;
&lt;/blockquote&gt;
&lt;p&gt;Make sure to enable &lt;em&gt;event_scheduler&lt;/em&gt; in your &lt;strong&gt;my.cnf&lt;/strong&gt; config file.&lt;/p&gt;
&lt;p&gt;An entry in the binary logs would look like this:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql [localhost] {msandbox} (meta) &amp;gt; show binlog events in &#39;mysql-bin.000002&#39; LIMIT 2,1;
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                                                                                                                                                                                               |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000002 | 388 | Query      |         1 |         669 | use `meta`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_view` AS select &#39;2f6ad653-5db3-11e4-b91d-3c970ea31ea8&#39; as pseudo_gtid_unique_val from dual |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entry will be unique, and orchestrator will be able to find it in the binary log if configured with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;{
    ...
    &#34;PseudoGTIDPattern&#34;: &#34;CREATE OR REPLACE .*? VIEW `pseudo_gtid_view` AS select&#34;
}&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The value of &lt;strong&gt;&#34;PseudoGTIDPattern&#34;&lt;/strong&gt; is a regular expression which must match the Pseudo GTID entries in the binary log, and &lt;em&gt;nothing but those entries&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Pre-release&lt;/h4&gt;
&lt;p&gt;This is BETA quality; though I have high confidence in its safety: the process of matching the binary log entries makes for a self-validating mechanism. The process will abort on any mismatch or uncertainty.&lt;/p&gt;
&lt;p&gt;Still there can be use cases I haven&#39;t encountered yet. You input is appreciated!&lt;/p&gt;
 as pseudo_gtid_unique_val from dual&#39;);
      PREPARE st FROM @_create_statement;
      EXECUTE st;
      DEALLOCATE PREPARE st;
    end
;;

delimiter ;

set global event_scheduler := 1;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Make sure to enable &lt;em&gt;event_scheduler&lt;/em&gt; in your &lt;strong&gt;my.cnf&lt;/strong&gt; config file.&lt;/p&gt;
&lt;p&gt;An entry in the binary logs would look like this:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysql [localhost] {msandbox} (meta) &amp;gt; show binlog events in &#39;mysql-bin.000002&#39; LIMIT 2,1;
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                                                                                                                                                                                               |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000002 | 388 | Query      |         1 |         669 | use `meta`; CREATE OR REPLACE ALGORITHM=UNDEFINED DEFINER=`msandbox`@`localhost` SQL SECURITY DEFINER VIEW `pseudo_gtid_view` AS select &#39;2f6ad653-5db3-11e4-b91d-3c970ea31ea8&#39; as pseudo_gtid_unique_val from dual |
+------------------+-----+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entry will be unique, and orchestrator will be able to find it in the binary log if configured with:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;{
    ...
    &#34;PseudoGTIDPattern&#34;: &#34;CREATE OR REPLACE .*? VIEW `pseudo_gtid_view` AS select&#34;
}&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The value of &lt;strong&gt;&#34;PseudoGTIDPattern&#34;&lt;/strong&gt; is a regular expression which must match the Pseudo GTID entries in the binary log, and &lt;em&gt;nothing but those entries&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Pre-release&lt;/h4&gt;
&lt;p&gt;This is BETA quality; though I have high confidence in its safety: the process of matching the binary log entries makes for a self-validating mechanism. The process will abort on any mismatch or uncertainty.&lt;/p&gt;
&lt;p&gt;Still there can be use cases I haven&#39;t encountered yet. You input is appreciated!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Refactoring replication topology with Pseudo GTID</title>
      <link>/blog/2014/10/23/refactoring-replication-topology-with-pseudo-gtid/</link>
      <pubDate>Thu, 23 Oct 2014 12:37:17 +0000</pubDate>
      
      <guid>/blog/2014/10/23/refactoring-replication-topology-with-pseudo-gtid/</guid>
      <description>&lt;p&gt;This post describes in detail the method of using Pseudo GTID to achieve unplanned replication topology changes, i.e. connecting two arbitrary slaves, or recovering from a master failure even as all its slaves are hanging in different positions.&lt;/p&gt;
&lt;p&gt;Please read &lt;a href=&#34;http://code.openark.org/blog/mysql/pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; and &lt;a href=&#34;http://code.openark.org/blog/mysql/pseudo-gtid-row-based-replication&#34;&gt;Pseudo GTID, RBR&lt;/a&gt; as introduction.&lt;/p&gt;
&lt;p&gt;Consider the following case: the master dies unexpectedly, and its three slaves are all hanging, not necessarily at same binary log file/position (network broke down while some slaves managed to salvage more entries into their relay logs than others)&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-failed-master.jpeg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7059&#34; src=&#34;/blog/blog/assets/orchestrator-failed-master.jpeg&#34; alt=&#34;orchestrator-failed-master&#34; width=&#34;801&#34; height=&#34;365&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;(Did you notice the &lt;strong&gt;&#34;Candidate for master&#34;&lt;/strong&gt; message? To be discussed shortly)&lt;/p&gt;
&lt;h4&gt;GTID&lt;/h4&gt;
&lt;p&gt;With GTID each transaction (and entry in the binary log) is associated with a unique mark -- the Global Transaction ID. Just pick the slave with the most advanced GTID to be the next master, and just &lt;strong&gt;CHANGE MASTER TO MASTER_HOST=&#39;chosen_slave&#39;&lt;/strong&gt; on the other slaves, and everything magically works. A slave knows which GTID it has already processed, and can look that entry on its master&#39;s binary logs, resuming replication on the one that follows.&lt;/p&gt;
&lt;p&gt;How does that work? The master&#39;s binary logs are searched for that GTID entry. I&#39;m not sure how brute-force this is, since I&#39;m aware of a subtlety which requires brute-force scan of all binary logs; I don&#39;t actually know if it&#39;s always like that.&lt;/p&gt;
&lt;h4&gt;Pseudo GTID&lt;/h4&gt;
&lt;p&gt;We can mimick that above, but our solution can&#39;t be as fine grained. With the injection of Pseudo GTID we mark the binary log for unique entries. But instead of having a unique identifier for every entry, we have a unique identifier for every second, 10 seconds, or what have you, with otherwise normal, non-unique entries in between our Pseudo GTID entries.&lt;/p&gt;
&lt;h4&gt;Recognizing which slave is more up to date&lt;/h4&gt;
&lt;p&gt;Given two slaves, which is more up to date?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If both replicate(d) from same master, a &lt;strong&gt;SHOW SLAVE STATUS&lt;/strong&gt; comparison answers (safe method: wait till SQL thread catches up with broken IO thread, compare &lt;strong&gt;relay_master_log_file&lt;/strong&gt;, &lt;strong&gt;exec_master_log_pos&lt;/strong&gt; on both machines). This is the method by which the above &#34;Candidate for master&#34; message is produced.&lt;/li&gt;
&lt;li&gt;If one is/was descendent of the other, then obviously it is less advanced or equals its ancestor.&lt;/li&gt;
&lt;li&gt;Otherwise we&#39;re unsure - still solvable via bi-directional trial &amp;amp; error, as explained later on.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For now, let&#39;s assume we know which slave is more up to date (has received and executed more relay logs). Let&#39;s call it &lt;strong&gt;S1&lt;/strong&gt;, whereas the less up-to-date will be &lt;strong&gt;S2&lt;/strong&gt;. This will make our discussion simpler.&lt;!--more--&gt;&lt;/p&gt;
&lt;h4&gt;Prerequisites&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;We require a Pseudo GTID in place: a periodic injection of a known-to-be-unique query, and which we know how to intercept&lt;/li&gt;
&lt;li&gt;We require &lt;strong&gt;log_slave_updates&lt;/strong&gt; on all slaves. We will need to parse the binary logs on slaves. I have little trust in the availability of relay logs: these are flushed, rotated and auto-erased all too quickly. The proposed solution does not require any daemon running on the MySQL servers themselves. There will be nothing to back up the relay logs, so I can&#39;t trust these to exist. Binary logs, on the other hand, have expiry period in days, and so I can trust them to exist for a duration of a few minutes.&lt;/li&gt;
&lt;li&gt;Normal replication. Not multi threaded. Not multi-source.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The process of rematching slaves&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;S1&lt;/strong&gt; is more up to date, hence we want to make &lt;strong&gt;S2&lt;/strong&gt; a slave of &lt;strong&gt;S1&lt;/strong&gt;. We expect the statements/entries found in &lt;strong&gt;S2&lt;/strong&gt;&#39;s binary logs to exist in &lt;strong&gt;S1&lt;/strong&gt;, in the same order, but somewhere back in the past, padded by additional entries (zero or more) that are not found in &lt;strong&gt;S2&lt;/strong&gt;. Steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find latest Pseudo-GTID entry in &lt;strong&gt;S2&lt;/strong&gt;&#39;s logs. This can be done by iterating &lt;strong&gt;S2&lt;/strong&gt;&#39;s binary logs newest to oldest. The first (time DESC) binary log where such entry is found is to be searched for the last entry (latest). Keep record of the binlog &lt;strong&gt;file2:pos2&lt;/strong&gt; coordinates.&lt;/li&gt;
&lt;li&gt;Take note of the exact entry made in the above. This is the unique value.&lt;/li&gt;
&lt;li&gt;Search said unique value in &lt;strong&gt;S1&lt;/strong&gt;&#39;s binary logs. Since it is unique, your method of search is arbirtary, you just need to find it. Brute-force wise you start looking at newest binary log moving back in time. Not found? Unlikely, since this means the lag diff between &lt;strong&gt;S1&lt;/strong&gt; and &lt;strong&gt;S2&lt;/strong&gt; is as long as the binlog expiry. We will be handling with failures and with immediate actions; we can expect slave lags in the seconds or in the minutes - we don&#39;t even consider the possibility where the entry is not found.&lt;/li&gt;
&lt;li&gt;Take note of the coordinates &lt;strong&gt;file1:pos1&lt;/strong&gt; in &lt;strong&gt;S1&lt;/strong&gt; where we found the unique value.&lt;/li&gt;
&lt;li&gt;We now iterate &lt;strong&gt;S2&lt;/strong&gt;&#39;s binary logs starting with the Pseudo GTID &lt;strong&gt;file2:pos2&lt;/strong&gt;. We expect to find each entry in &lt;strong&gt;S1&lt;/strong&gt;&#39;s binary logs, successively, starting &lt;strong&gt;file1:pos1&lt;/strong&gt;. We verify the entries in both servers are identical. Exceptions above could be:
&lt;ul&gt;
&lt;li&gt;Meta-entries (start-of-log, end-of-log, shutdown), in which case we skip to the next entry (this is done in both &lt;strong&gt;S1&lt;/strong&gt; and &lt;strong&gt;S2&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Local statements executed directly on either &lt;strong&gt;S1&lt;/strong&gt; or &lt;strong&gt;S2&lt;/strong&gt;, such as &lt;strong&gt;ANALYZE TABLE&lt;/strong&gt; or whatever, which make no impact on data -- we may skip these&lt;/li&gt;
&lt;li&gt;Local, evil statements executed directly on the slaves,which make for data impact (&lt;strong&gt;INSERT&lt;/strong&gt;, &lt;strong&gt;DELETE&lt;/strong&gt;, ...). We choose to fail the operation in such case&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;After all entries in &lt;strong&gt;S2&lt;/strong&gt; (matched by entries in &lt;strong&gt;S1&lt;/strong&gt;) are iterated, our &lt;strong&gt;S1&lt;/strong&gt; &#34;cursor&#34; now looks at the first statement that never made it to &lt;strong&gt;S2&lt;/strong&gt;. This is &lt;strong&gt;file_win:pos_win&lt;/strong&gt;, into which we will point &lt;strong&gt;S2&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Or, we might find that upon iterating all entries in &lt;strong&gt;S2&lt;/strong&gt; we have exactly reached the end of binlog entries for S1: this means both S1 and S2 are actually in identical state. We point &lt;strong&gt;S2&lt;/strong&gt; into &lt;strong&gt;S1&lt;/strong&gt;&#39;s next-binlog-position.
&lt;ul&gt;
&lt;li&gt;This is in fact no different than the previous case, but of particular interest.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Or, we might run out of entries in &lt;strong&gt;S1&lt;/strong&gt;. No, we can&#39;t, because our assumption was that &lt;strong&gt;S1&lt;/strong&gt; is more advanced than (or equally advanced as) &lt;strong&gt;S2&lt;/strong&gt;. But this answers the question: &#34;&lt;strong&gt;what if didn&#39;t know in advance who&#39;s more advanced?&lt;/strong&gt;&#34; (no pun intended). In such case we conclude &lt;strong&gt;S2&lt;/strong&gt; is actually more advanced than &lt;strong&gt;S1&lt;/strong&gt; and we can try the other way around.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That last bullet is of importance: if you have two slaves whose &#34;family connection&#34; is complex, you can still match one below the other; you may try one way and fail, then try the other way around and succeed.&lt;/p&gt;
&lt;p&gt;Comparison of the events following the Pseudo-GTID is a good way of sanity checking (some meta-stuff should be ignored, like transaction IDs, table IDs, these can vary across servers), and builds up confidence in the correctness of the operation.&lt;/p&gt;
&lt;p&gt;The codebase is actually complete and pushed; I&#39;ll release a BETA version or &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt; next week, that supports Pseudo GTID. Let me tell you, doing this kind of crazy stuff with visual feedback (of course command line is available) is very very cool.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pseudo GTID</title>
      <link>/blog/2014/10/22/pseudo-gtid/</link>
      <pubDate>Wed, 22 Oct 2014 07:22:26 +0000</pubDate>
      
      <guid>/blog/2014/10/22/pseudo-gtid/</guid>
      <description>&lt;p&gt;Pseudo GTID is a method to implement a GTID-like solution where slaves are easily connected to one another. This blog post and the following ones will describe work in progress (some 80% completed), where simulation of GTID makes for a &lt;em&gt;good enough&lt;/em&gt; basis for refactoring replication topologies. I&#39;m coding this in &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;, which already provides a substantial infrastructure support for this.&lt;/p&gt;
&lt;p&gt;The final goal: &lt;em&gt;orchestrator&lt;/em&gt; will allow you to move a slave below another, using only the data available by those two slaves. The usage is obvious:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Easy master failover (master dead? &lt;em&gt;Orchestrator&lt;/em&gt; will choose the most advanced slave to promote &lt;em&gt;and&lt;/em&gt; make it master of its siblings)&lt;/li&gt;
&lt;li&gt;Slave promotion in complex topologies (with &lt;a href=&#34;http://code.openark.org/blog/mysql/using-deep-nested-replication-topologies&#34;&gt;deep nested topologies&lt;/a&gt;, be able to move a slave up the hierarchy even if its local master is corrupted).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This can all happen with your normal, &lt;em&gt;non GTID&lt;/em&gt;, MySQL replication, using your normal binary log files &amp;amp; positions.&lt;/p&gt;
&lt;p&gt;This work in progress is inspired by &lt;strong&gt;&lt;a href=&#34;https://github.com/samlambert&#34;&gt;Sam Lambert&lt;/a&gt;&lt;/strong&gt; at GitHub, who has worked on a similar solution with different implementation. I also recall discussions with other DBAs having similar solution.&lt;/p&gt;
&lt;h4&gt;Pseudo GTID&lt;/h4&gt;
&lt;p&gt;First thing&#39;s first, the basis for proposed solution is a &lt;em&gt;pseudo-GTID&lt;/em&gt;. A unique entry in the binary logs (not necessarily sequential; not necessarily in ascending order). While in GTID implementations we have a unique identifier &lt;em&gt;for each entry&lt;/em&gt; in the binary log, with pseudo-GTID we accept an &lt;em&gt;occasional&lt;/em&gt; (or &lt;em&gt;frequent&lt;/em&gt;) unique entry in the binary log.&lt;/p&gt;
&lt;p&gt;There are many ways to do so. Certainly a client can generate a unique Id and invoke some statement on MySQL involving that ID. That would serve as valid grounds for the proposed solution. But I like things to be contained within MySQL. Consider, for example, the following event, which would be my preferred choice in Statement Based Replication (for RBR solution, see next post):&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop table if exists test.pseudo_gtid;
create table if not exists test.pseudo_gtid (
  id int unsigned not null primary key,
  ts timestamp,
  gtid varchar(64) charset ascii
);


drop event if exists test.update_pseudo_gtid_event;

delimiter ;;
create event if not exists
  test.update_pseudo_gtid_event
  on schedule every 10 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @pseudo_gtid := uuid();
      insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid);
    end
;;

delimiter ;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above is based on &lt;a title=&#34;Link to Making UUID() and RAND() replication safe&#34; href=&#34;http://code.openark.org/blog/mysql/making-uuid-and-rand-replication-safe&#34; rel=&#34;bookmark&#34;&gt;Making UUID() and RAND() replication safe&lt;/a&gt;. What do we get? Once in 10 seconds (or what have you), a unique entry is written to the binary log.&lt;/p&gt;
&lt;p&gt;&lt;!--more--&gt;Consider that the event is already running by now, and the next conventional statements executed by the application:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;master [localhost] {msandbox} (test) &amp;gt; create table test.vals(id int);
master [localhost] {msandbox} (test) &amp;gt; insert into test.vals (id) values (17);
master [localhost] {msandbox} (test) &amp;gt; insert into test.vals (id) values (18);
master [localhost] {msandbox} (test) &amp;gt; insert into test.vals (id) values (19);
master [localhost] {msandbox} (test) &amp;gt; insert into test.vals (id) values (23);

master [localhost] {msandbox} (test) &amp;gt; show master logs;
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000036 |       531 |
| mysql-bin.000037 |      1269 |
| mysql-bin.000038 |      6627 |
| mysql-bin.000039 |      3313 |
+------------------+-----------+
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s look at the binary logs content:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;master [localhost] {msandbox} (test) &amp;gt; show binlog events in &#39;mysql-bin.000039&#39;;
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                        |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000039 |    4 | Format_desc |         1 |         107 | Server ver: 5.5.32-log, Binlog ver: 4                                                                                                       |
| mysql-bin.000039 |  107 | Query       |         1 |         183 | BEGIN                                                                                                                                       |
| mysql-bin.000039 |  183 | User var    |         1 |         263 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x37383435623633382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000039 |  263 | Query       |         1 |         461 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 |  461 | Xid         |         1 |         488 | COMMIT /* xid=74 */                                                                                                                         |
| mysql-bin.000039 |  488 | Query       |         1 |         581 | use `test`; create table test.vals(id int)                                                                                                  |
| mysql-bin.000039 |  581 | Query       |         1 |         657 | BEGIN                                                                                                                                       |
| mysql-bin.000039 |  657 | User var    |         1 |         737 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x37653362616434382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000039 |  737 | Query       |         1 |         935 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 |  935 | Xid         |         1 |         962 | COMMIT /* xid=82 */                                                                                                                         |
| mysql-bin.000039 |  962 | Query       |         1 |        1038 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1038 | User var    |         1 |        1118 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x38343331396662332D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000039 | 1118 | Query       |         1 |        1316 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 1316 | Xid         |         1 |        1343 | COMMIT /* xid=84 */                                                                                                                         |
| mysql-bin.000039 | 1343 | Query       |         1 |        1411 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1411 | Query       |         1 |        1512 | use `test`; insert into test.vals (id) values (17)                                                                                          |
| mysql-bin.000039 | 1512 | Xid         |         1 |        1539 | COMMIT /* xid=84 */                                                                                                                         |
| mysql-bin.000039 | 1539 | Query       |         1 |        1607 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1607 | Query       |         1 |        1708 | use `test`; insert into test.vals (id) values (18)                                                                                          |
| mysql-bin.000039 | 1708 | Xid         |         1 |        1735 | COMMIT /* xid=85 */                                                                                                                         |
| mysql-bin.000039 | 1735 | Query       |         1 |        1803 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 1803 | Query       |         1 |        1904 | use `test`; insert into test.vals (id) values (19)                                                                                          |
| mysql-bin.000039 | 1904 | Xid         |         1 |        1931 | COMMIT /* xid=86 */                                                                                                                         |
| mysql-bin.000039 | 1931 | Query       |         1 |        2007 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2007 | User var    |         1 |        2087 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x38613237376232352D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000039 | 2087 | Query       |         1 |        2285 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 2285 | Xid         |         1 |        2312 | COMMIT /* xid=89 */                                                                                                                         |
| mysql-bin.000039 | 2312 | Query       |         1 |        2380 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2380 | Query       |         1 |        2481 | use `test`; insert into test.vals (id) values (23)                                                                                          |
| mysql-bin.000039 | 2481 | Xid         |         1 |        2508 | COMMIT /* xid=89 */                                                                                                                         |
| mysql-bin.000039 | 2508 | Query       |         1 |        2584 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2584 | User var    |         1 |        2664 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x39303164373731612D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000039 | 2664 | Query       |         1 |        2862 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 2862 | Xid         |         1 |        2889 | COMMIT /* xid=92 */                                                                                                                         |
| mysql-bin.000039 | 2889 | Query       |         1 |        2965 | BEGIN                                                                                                                                       |
| mysql-bin.000039 | 2965 | User var    |         1 |        3045 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x39363133363965382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000039 | 3045 | Query       |         1 |        3243 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000039 | 3243 | Xid         |         1 |        3270 | COMMIT /* xid=94 */                                                                                                                         |
| mysql-bin.000039 | 3270 | Rotate      |         1 |        3313 | mysql-bin.000040;pos=4                                                                                                                      |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Marked in bold are the pseudo-GTID statements, aptly read &lt;strong&gt;&#34;@`pseudo_gtid`=_utf8 0x...&#34;&lt;/strong&gt;, and which are the resulting entry of the &lt;strong&gt;set @pseudo_gtid := uuid();&lt;/strong&gt; statement. These are interleaved with our normal statements. In busier servers there could be hundreds or thousands of statements between any two pseudo-GTID entries.&lt;/p&gt;
&lt;p&gt;We have a replicating slave to the above, which uses &lt;strong&gt;log_slave_updates&lt;/strong&gt;. For reasons to be explained later, I prefer and require &lt;strong&gt;log_slave_updates&lt;/strong&gt;, and will examine the slave&#39;s binary logs (instead of directly looking at the slave&#39;s relay logs):&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;slave3 [localhost] {msandbox} ((none)) &amp;gt; show master logs;

+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000046 |      1077 |
| mysql-bin.000047 |       126 |
| mysql-bin.000048 |       150 |
| mysql-bin.000049 |       150 |
| mysql-bin.000050 |     13860 |
| mysql-bin.000051 |       107 |
+------------------+-----------+

slave3 [localhost] {msandbox} ((none)) &amp;gt; show binlog events in &#39;mysql-bin.000051&#39;;
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                        |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
| mysql-bin.000051 |    4 | Format_desc |       103 |         107 | Server ver: 5.5.32-log, Binlog ver: 4                                                                                                       |
| mysql-bin.000051 |  107 | Query       |         1 |         174 | BEGIN                                                                                                                                       |
| mysql-bin.000051 |  174 | User var    |         1 |         254 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x37383435623633382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000051 |  254 | Query       |         1 |         452 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 |  452 | Xid         |         1 |         479 | COMMIT /* xid=2141 */                                                                                                                       |
| mysql-bin.000051 |  479 | Query       |         1 |         572 | use `test`; create table test.vals(id int)                                                                                                  |
| mysql-bin.000051 |  572 | Query       |         1 |         639 | BEGIN                                                                                                                                       |
| mysql-bin.000051 |  639 | User var    |         1 |         719 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x37653362616434382D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000051 |  719 | Query       |         1 |         917 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 |  917 | Xid         |         1 |         944 | COMMIT /* xid=2150 */                                                                                                                       |
| mysql-bin.000051 |  944 | Query       |         1 |        1011 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1011 | User var    |         1 |        1091 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x38343331396662332D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000051 | 1091 | Query       |         1 |        1289 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 | 1289 | Xid         |         1 |        1316 | COMMIT /* xid=2152 */                                                                                                                       |
| mysql-bin.000051 | 1316 | Query       |         1 |        1375 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1375 | Query       |         1 |        1476 | use `test`; insert into test.vals (id) values (17)                                                                                          |
| mysql-bin.000051 | 1476 | Xid         |         1 |        1503 | COMMIT /* xid=2154 */                                                                                                                       |
| mysql-bin.000051 | 1503 | Query       |         1 |        1562 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1562 | Query       |         1 |        1663 | use `test`; insert into test.vals (id) values (18)                                                                                          |
| mysql-bin.000051 | 1663 | Xid         |         1 |        1690 | COMMIT /* xid=2156 */                                                                                                                       |
| mysql-bin.000051 | 1690 | Query       |         1 |        1749 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1749 | Query       |         1 |        1850 | use `test`; insert into test.vals (id) values (19)                                                                                          |
| mysql-bin.000051 | 1850 | Xid         |         1 |        1877 | COMMIT /* xid=2158 */                                                                                                                       |
| mysql-bin.000051 | 1877 | Query       |         1 |        1944 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 1944 | User var    |         1 |        2024 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x38613237376232352D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000051 | 2024 | Query       |         1 |        2222 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 | 2222 | Xid         |         1 |        2249 | COMMIT /* xid=2160 */                                                                                                                       |
| mysql-bin.000051 | 2249 | Query       |         1 |        2308 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 2308 | Query       |         1 |        2409 | use `test`; insert into test.vals (id) values (23)                                                                                          |
| mysql-bin.000051 | 2409 | Xid         |         1 |        2436 | COMMIT /* xid=2162 */                                                                                                                       |
| mysql-bin.000051 | 2436 | Query       |         1 |        2503 | BEGIN                                                                                                                                       |
| mysql-bin.000051 | 2503 | User var    |         1 |        2583 | &lt;strong&gt;@`pseudo_gtid`=_utf8 0x39303164373731612D353631612D313165342D393135642D336339373065613331656138 COLLATE utf8_general_ci&lt;/strong&gt;                     |
| mysql-bin.000051 | 2583 | Query       |         1 |        2781 | use `test`; insert into test.pseudo_gtid (id, ts, gtid) values (1, NOW(), @pseudo_gtid) on duplicate key update ts=NOW(), gtid=VALUES(gtid) |
| mysql-bin.000051 | 2781 | Xid         |         1 |        2808 | COMMIT /* xid=2164 */                                                                                                                       |
| mysql-bin.000051 | 2808 | Rotate      |       103 |        2851 | mysql-bin.000052;pos=4                                                                                                                      |
+------------------+------+-------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can see the &lt;strong&gt;&#34;@`pseudo_gtid`=_utf8 0x&#34;&lt;/strong&gt; entries are replicated well, and are identical throughout the topology (this continue to work well on second-level slaves etc.).&lt;/p&gt;
&lt;p&gt;To be continued.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
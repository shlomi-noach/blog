<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Replication on code.openark.org</title>
    <link>/blog/tags/replication/</link>
    <description>Recent content in Replication on code.openark.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Wed, 28 Sep 2016 14:22:14 +0000</lastBuildDate>
    <atom:link href="/blog/tags/replication/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Three wishes for a new year</title>
      <link>/blog/mysql/three-wishes-for-a-new-year-4</link>
      <pubDate>Wed, 28 Sep 2016 14:22:14 +0000</pubDate>
      
      <guid>/blog/mysql/three-wishes-for-a-new-year-4</guid>
      <description>&lt;p&gt;(Almost) another new year by Jewish calendar. What do I wish for the following year?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;World peace&lt;/li&gt;
&lt;li&gt;Good health to all&lt;/li&gt;
&lt;li&gt;Relaxed GTID constraints&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I&#39;m still not using GTID, and still see operational issues with working with GTID. As a latest example, our new schema migration solution, gh-ost, allows us to test migrations in production, on replicas. The GTID catch? &lt;code&gt;gh-ost&lt;/code&gt;&amp;nbsp;has to write something to the binary log. Thus, it &#34;corrupts&#34; the replica with a bogus GTID entry that will never be met in another server, thus making said replica unsafe to promote. We can work around this, but...&lt;/p&gt;
&lt;p&gt;I understand the idea and need for the &lt;code&gt;Executed GTID Set&lt;/code&gt;. It will&amp;nbsp;certainly come in handy with multi-writer InnoDB Cluster. However for most use cases GTID poses a burden. The reason is that our topologies are imperfect, and we as humans are imperfect, and operations are most certainly imperfect. We may wish to operate on a replica: test something, by intention or mistake. We may wish to use a subchain as the seed for a new cluster split. We may wish to be able to write to downstream replicas. We may use a 3rd party tool that issues a &lt;code&gt;flush tables with read lock&lt;/code&gt;&amp;nbsp;without disabling &lt;code&gt;sql_log_bin&lt;/code&gt;. Things just happen.&lt;/p&gt;
&lt;p&gt;For that, I would like to suggest GTID control levels, such as:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Strict&lt;/em&gt;: same as Oracle&#39;s existing&amp;nbsp;implementation. Executed sets, purged sets, whatnot.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Last executed&lt;/em&gt;: a mode where the only thing that counts is the last executed GTID value. If I repoint replica,&amp;nbsp;all it needs to check is &#34;hey this is my last executed GTID entry, give me the coordinates of yours. And, no, I don&#39;t care about comparing executed and purged sets, I will trust you and keep running from that point on&#34;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Declarative&lt;/em&gt;: GTIDs are generated, are visible in each and every binary log entry, but are completely ignored.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I realize Oracle MySQL GTID is out for some over 3 years now, but I&#39;m sorry - I still have reservations and see&amp;nbsp;use cases where I fear it will not serve me right.&lt;/p&gt;
&lt;p&gt;How about my previous years wishes? World peace and good health never came through, however:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My &lt;a href=&#34;http://code.openark.org/blog/mysql/three-wishes-for-a-new-year-2015&#34;&gt;2015 wish&lt;/a&gt; for &#34;decent, operations friendly built in online table refactoring&#34; was unmet, however &lt;code&gt;gh-ost&lt;/code&gt;&amp;nbsp;is a thing now and exceeds my expectations. No, really. Please come see &lt;a href=&#34;https://www.percona.com/live/plam16/sessions/introducing-gh-ost-triggerless-painless-trusted-online-schema-migrations&#34;&gt;Tom &amp;amp; myself present gh-ost&lt;/a&gt; and how it changed our migration paradigm.&lt;/li&gt;
&lt;li&gt;My &lt;a href=&#34;http://code.openark.org/blog/mysql/three-wishes-for-a-new-year-201&#34;&gt;2012 wish&lt;/a&gt; for &#34;decent, long waited for, implementation of &lt;a href=&#34;http://en.wikipedia.org/wiki/Window_function_%28SQL%29#Window_function&#34;&gt;Window Functions&lt;/a&gt; (aka Analytic Functions) for MySQL&#34; was met by&amp;nbsp;MariaDB&#39;s &lt;a href=&#34;https://mariadb.com/kb/en/mariadb/window-functions/&#34;&gt;window functions&lt;/a&gt;.&lt;br&gt;
Not strictly Window Functions, but Oracle MySQL 8.0 will &lt;a href=&#34;http://mysqlserverteam.com/mysql-8-0-labs-recursive-common-table-expressions-in-mysql-ctes/&#34;&gt;support CTE&lt;/a&gt; (hierarchial/recursive), worth a mention.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See you in Amsterdam!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>State of automated recovery via Pseudo-GTID &amp; Orchestrator @ Booking.com</title>
      <link>/blog/2015/11/20/state-of-automated-recovery-via-pseudo-gtid-orchestrator-booking-com/</link>
      <pubDate>Fri, 20 Nov 2015 11:41:13 +0000</pubDate>
      
      <guid>/blog/2015/11/20/state-of-automated-recovery-via-pseudo-gtid-orchestrator-booking-com/</guid>
      <description>&lt;p&gt;This post sums up some of my work on MySQL resilience and high availability at &lt;a href=&#34;http://www.booking.com&#34;&gt;Booking.com&lt;/a&gt; by presenting the current state of automated master and intermediate master recoveries via &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo-GTID&lt;/a&gt; &amp;amp; &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Booking.com uses many different MySQL topologies, of varying vendors, configurations and workloads: Oracle MySQL, MariaDB, statement based replication, row based replication, hybrid, OLTP, OLAP, GTID (few), no GTID (most), Binlog Servers, filters, hybrid of all the above.&lt;/p&gt;
&lt;p&gt;Topologies size varies from a single server to many-many-many. Our typical topology has a master in one datacenter, a bunch of slaves in same DC, a slave in another DC acting as an intermediate master to further bunch of slaves in the other DC. Something like this, give or take:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/11/booking-topology-sample.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-7480 size-medium&#34; src=&#34;/blog/blog/assets/booking-topology-sample-300x169.png&#34; alt=&#34;booking-topology-sample&#34; width=&#34;300&#34; height=&#34;169&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;However as we are building our third data center (with MySQL deployments mostly completed) the graph turns more complex.&lt;/p&gt;
&lt;p&gt;Two high availability questions are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What happens when an intermediate master dies? What of all its slaves?&lt;/li&gt;
&lt;li&gt;What happens when the master dies? What of the entire topology?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is not a technical drill down into the solution, but rather on overview of the state. For more, please refer to recent presentations in &lt;a href=&#34;https://speakerdeck.com/shlominoach/managing-and-visualizing-your-replication-topologies-with-orchestrator&#34;&gt;September&lt;/a&gt; and &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;April&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At this time we have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pseudo-GTID deployed on all chains
&lt;ul&gt;
&lt;li&gt;Injected every 5 seconds&lt;/li&gt;
&lt;li&gt;Using the &lt;a href=&#34;http://code.openark.org/blog/mysql/pseudo-gtid-ascending&#34;&gt;monotonically ascending&lt;/a&gt; variation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pseudo-GTID based automated failover for intermediate masters on all chains&lt;/li&gt;
&lt;li&gt;Pseudo-GTID based automated failover for masters on roughly 30% of the chains.
&lt;ul&gt;
&lt;li&gt;The rest of 70% of chains are set for manual failover using Pseudo-GTID.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pseudo-GTID is in particular used for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Salvaging slaves of a dead intermediate master&lt;/li&gt;
&lt;li&gt;Correctly grouping and connecting slaves of a dead master&lt;/li&gt;
&lt;li&gt;Routine refactoring of topologies. This includes:
&lt;ul&gt;
&lt;li&gt;Manual repointing of slaves for various operations (e.g. offloading slaves from a busy box)&lt;/li&gt;
&lt;li&gt;Automated refactoring (for example, used by our automated upgrading script, which consults with &lt;em&gt;orchestrator&lt;/em&gt;, upgrades, shuffles slaves around, updates intermediate master, suffles back...)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(In the works), failing over binlog reader apps that audit our binary logs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!--more--&gt;Furthermore, Booking.com is also &lt;a href=&#34;https://www.percona.com/live/europe-amsterdam-2015/sessions/binlog-servers-bookingcom&#34;&gt;working on Binlog Servers&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;These take production traffic and offload masters and intermediate masters&lt;/li&gt;
&lt;li&gt;Often co-serve slaves using round-robin VIP, such that failure of one Binlog Server makes for simple slave replication self-recovery.&lt;/li&gt;
&lt;li&gt;Are interleaved alongside standard replication
&lt;ul&gt;
&lt;li&gt;At this time we have no &#34;pure&#34; Binlog Server topology in production; we always have normal intermediate masters and slaves&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This hybrid state makes for greater complexity:
&lt;ul&gt;
&lt;li&gt;Binlog Servers are not designed to participate in a game of changing masters/intermediate master, unless &lt;a href=&#34;http://jfg-mysql.blogspot.nl/2015/09/abstracting-binlog-servers-and-mysql-master-promotion-wo-reconfiguring-slaves.html&#34;&gt;successors come from their own sub-topology&lt;/a&gt;, which is not the case today.
&lt;ul&gt;
&lt;li&gt;For example, a Binlog Server that replicates directly from the master, cannot be repointed to just any new master.&lt;/li&gt;
&lt;li&gt;But can still hold valuable binary log entries that other slaves may not.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Are not actual MySQL servers, therefore of course cannot be promoted as masters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; &amp;amp; Pseudo-GTID makes this hybrid topology still resilient:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Orchestrator&lt;/em&gt; understands the limitations on the hybrid topology and can salvage slaves of 1st tier Binlog Servers via Pseudo-GTID&lt;/li&gt;
&lt;li&gt;In the case where the Binlog Servers were the most up to date slaves of a failed master, &lt;em&gt;orchestrator&lt;/em&gt; knows to first move potential candidates under the Binlog Server and then extract them out again.&lt;/li&gt;
&lt;li&gt;At this time Binlog Servers are still unstable. Pseudo-GTID allows us to comfortably test them on a large setup with reduced fear of losing slaves.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Otherwise &lt;em&gt;orchestrator&lt;/em&gt; already understands pure Binlog Server topologies and can do master promotion. When pure binlog servers topologies will be in production &lt;em&gt;orchestrator&lt;/em&gt; will be there to watch over.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;To date, Pseudo-GTID has high scores in automated failovers of our topologies; &lt;em&gt;orchestrator&#39;s&lt;/em&gt; &lt;a href=&#34;http://code.openark.org/blog/mysql/what-makes-a-mysql-server-failurerecovery-case&#34;&gt;holistic approach&lt;/a&gt; makes for reliable diagnostics; together they reduce our dependency on specific servers &amp;amp; hardware, physical location, latency implied by SAN devices.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator &amp; Pseudo-GTID for binlog reader failover</title>
      <link>/blog/2015/11/19/orchestrator-pseudo-gtid-for-binlog-reader-failover/</link>
      <pubDate>Thu, 19 Nov 2015 10:52:16 +0000</pubDate>
      
      <guid>/blog/2015/11/19/orchestrator-pseudo-gtid-for-binlog-reader-failover/</guid>
      <description>&lt;p&gt;One of our internal apps at &lt;strong&gt;Booking.com&lt;/strong&gt; audits changes to our tables on various clusters. We used to use &lt;em&gt;tungsten replicator&lt;/em&gt;, but have since migrated onto our own solution.&lt;/p&gt;
&lt;p&gt;We have a binlog reader (uses &lt;a href=&#34;https://github.com/zendesk/open-replicator&#34;&gt;open-replicator&lt;/a&gt;) running on a slave. It expects Row Based Replication, hence our slave runs with &lt;strong&gt;log-slave-updates&lt;/strong&gt;, &lt;strong&gt;binlog-format=&#39;ROW&#39;&lt;/strong&gt;, to translate from the master&#39;s Statement Based Replication. The binlog reader reads what it needs to read, audits what it needs to audit, and we&#39;re happy.&lt;/p&gt;
&lt;h3&gt;However what happens if that slave dies?&lt;/h3&gt;
&lt;p&gt;In such case we need to be able to point our binlog reader to another slave, and it needs to be able to pick up auditing from the same point.&lt;/p&gt;
&lt;p&gt;This sounds an awful lot like slave repointing in case of master/intermediate master failure, and indeed the solutions are similar. However our binlog reader is not a real MySQL server and does not understands replication. It does not really replicate, it just parses binary logs.&lt;/p&gt;
&lt;p&gt;We&#39;re also not using GTID. But we &lt;em&gt;are&lt;/em&gt; using Pseudo-GTID. As it turns out, the failover solution is already built in by &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;, and this is how it goes:&lt;/p&gt;
&lt;h3&gt;Normal execution&lt;/h3&gt;
&lt;p&gt;Our binlog app reads entries from the binary log. Some are of interest for auditing purposes, some are not. An occasional Pseudo-GTID entry is found, and is being stored to ZooKeeper tagged as  &#34;last seen and processed Pseudo-GTID&#34;.&lt;/p&gt;
&lt;h3&gt;Upon slave failure&lt;/h3&gt;
&lt;p&gt;We recognize the death of a slave; we have other slaves in the pool; we pick another. Now we need to find the coordinates from which to carry on.&lt;/p&gt;
&lt;p&gt;We read our &#34;last seen and processed Pseudo-GTID&#34;. Say it reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`_pseudo_gtid_hint__asc:56373F17:00000000012B1C8B:50EC77A1`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;. We now issue:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ orchestrator &lt;strong&gt;-c find-binlog-entry&lt;/strong&gt; &lt;strong&gt;-i new.slave.fqdn.com&lt;/strong&gt; --pattern=&#39;drop view if exists `meta`.`_pseudo_gtid_hint__asc:56373F17:00000000012B1C8B:50EC77A1`&#39;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The output of such command are the binlog coordinates of that same entry as found in the new slave&#39;s binlogs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;binlog.000148:43664433&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pseudo-GTID entries are only injected once every few seconds (&lt;strong&gt;5&lt;/strong&gt; in our case). Either:&lt;!--more--&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We are OK to reprocess up to &lt;strong&gt;5&lt;/strong&gt; seconds worth of data (and indeed we are, our mechanism is such that this merely overwrites our previous audit, no corruption happens)&lt;/li&gt;
&lt;li&gt;Or our binlog reader also keeps track of the number of events since the last processed Pseudo-GTID entry, skipping the same amount of events after failing over.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Planned failover&lt;/h3&gt;
&lt;p&gt;In case we plan to repoint our binlog reader to another slave, we can further use orchestrator&#39;s power in making an exact correlation between the binlog positions of two slaves. This has always been within its power, but only recently exposed as it own command. We can, at any stage:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ sudo orchestrator &lt;strong&gt;-c correlate-binlog-pos&lt;/strong&gt; -i current.instance.fqdn.com --binlog=binlog.002011:72656109 -d some.other.instance.fqdn.com&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The output is the binlog coordinates in &lt;strong&gt;some.other.instance.fqdn.com&lt;/strong&gt; that exactly correlate with &lt;strong&gt;binlog.002011:72656109&lt;/strong&gt; in &lt;strong&gt;current.instance.fqdn.com&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The case of failure of the binlog reader itself is also handled, but is not the subject of this blog post.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>New features I&#39;d like to see in MySQL 5.8</title>
      <link>/blog/2015/10/07/new-features-id-like-to-see-in-mysql-5-8/</link>
      <pubDate>Wed, 07 Oct 2015 10:02:16 +0000</pubDate>
      
      <guid>/blog/2015/10/07/new-features-id-like-to-see-in-mysql-5-8/</guid>
      <description>&lt;p&gt;Following up on Morgan Tocker&#39;s &lt;a href=&#34;http://www.tocker.ca/2015/09/14/what-would-you-like-to-see-in-mysql-5-8.html&#34;&gt;What would you like to see in MySQL 5.8?&lt;/a&gt;, having attended and participated at the &lt;a href=&#34;https://www.percona.com/live/europe-amsterdam-2015/sessions/mysql-58-dreaming-and-brainstorming&#34;&gt;brainstorming at Percona Live Amsterdam&lt;/a&gt;, and publishing this post while failing to comply with any of Morgan&#39;s suggested media, these are the features I would like to see in MySQL &lt;strong&gt;5.8&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dynamicly enable/disable &lt;strong&gt;log-bin&lt;/strong&gt; and &lt;strong&gt;log-slave-updates&lt;/strong&gt;&lt;br /&gt;
Today, when changing chef/puppet role of a server from a simple slave to an intermediate master and vice versa, a MySQL restart is required. This is a very big pain which makes replication automation complex, not to mention warmup times.&lt;/li&gt;
&lt;li&gt;&#34;&lt;strong&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man1/nice.1.html&#34;&gt;nice&lt;/a&gt;&lt;/strong&gt;&#34;.&lt;br /&gt;
I want to be able to execute a query that is &lt;em&gt;nice, i.e&lt;/em&gt; has lower priority; will not consume all resources; will stall/throttle so as to allow other queries to complete. Luis asked and I said this could be on a per statement basis, e.g. add a &lt;strong&gt;SQL_NICE&lt;/strong&gt; query hint. But I&#39;m unsure that would be the correct behavior. It also makes sense to do so on a per connection basis (perhaps provide connection attributed to hint &lt;em&gt;niceness&lt;/em&gt;?).&lt;/li&gt;
&lt;li&gt;Online-&lt;em&gt;ier&lt;/em&gt; &lt;strong&gt;ALTER TABLE&lt;/strong&gt;. I would in particular want it to apply the &lt;em&gt;nice&lt;/em&gt; feature, above. Otherwise throttle by user defined metrics.&lt;/li&gt;
&lt;li&gt;Online-&lt;em&gt;ier&lt;/em&gt; &lt;strong&gt;ALTER TABLE&lt;/strong&gt; in replication stream.  Can the slaves run the &lt;strong&gt;ALTER&lt;/strong&gt; statement in parallel?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Re-Group Commit&lt;/strong&gt;: in MTS, and when intermediate masters involved, copy+paste the group commit as applied on master as working downstream. I suspect this is easily achievable. The result: same parallelism for replicating slaves in all levels, whether they replicate directly from master or from 2nd, 3rd tier intermediate masters. Today parallelism decreases as we go downstream.&lt;/li&gt;
&lt;li&gt;Global user-defined-variables. I want to be able to define arbitrary (global) variables that I can later query via &lt;strong&gt;SELECT @@global.arbitrary&lt;/strong&gt;. This would be similar to HTML &lt;strong&gt;5&lt;/strong&gt;&#39;s &lt;strong&gt;&#34;data-*&#34;&lt;/strong&gt; attributes. I often wish I could tell &amp;amp; ask MySQL my puppet role; or the server status (is it live? Is it offline? Does it belong to a specific pool? etc.). Similar to &lt;strong&gt;&#34;loose-*&#34;&lt;/strong&gt; syntax, this could be a &lt;strong&gt;&#34;data-*&#34;&lt;/strong&gt; or &lt;strong&gt;&#34;user-*&#34;&lt;/strong&gt; name prefix system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will follow up on new &lt;em&gt;statements&lt;/em&gt; I would like to see in MySQL &lt;strong&gt;5.8&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The brainstorming session at PerconaLive, I should note, was pure joy, and apart from getting two nice furry dolphins I enjoyed the engagement, the diversity of ideas, and the fact Oracle engineers (Mark in particular) were very busy taking notes or otherwise openly discussing the viability of some requested features.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator visual cheatsheet, TL;DR the &#34;smart&#34; way</title>
      <link>/blog/2015/09/02/orchestrator-visual-cheatsheet-tldr-the-smart-way/</link>
      <pubDate>Wed, 02 Sep 2015 09:14:05 +0000</pubDate>
      
      <guid>/blog/2015/09/02/orchestrator-visual-cheatsheet-tldr-the-smart-way/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt;&lt;/strong&gt; is &lt;em&gt;really&lt;/em&gt; growing. And the amount of users (DBAs, sys admins) using it is growing. Which gives me a lot of immediate feedback in the form of &lt;em&gt;&#34;Look, there&#39;s just too many options to move slaves around! Which ones should we use?&#34;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;TL;DR look at the two visualized commands below&lt;/h3&gt;
&lt;p&gt;They are enough&lt;/p&gt;
&lt;h3&gt;The &#34;smart&#34; commands to end all commands&lt;/h3&gt;
&lt;p&gt;So all relocation commands are important, and give you fine-grained, pin-pointed control of the method of topology refactoring. However, most of the time you &lt;em&gt;just want to move those servers around&lt;/em&gt;. Which is why there&#39;s a new &#34;smart&#34; mode which support these two commands, which you should be happy using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;relocate&lt;/strong&gt;: move a single slave to another position&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;relocate-slaves&lt;/strong&gt;: move all/some slaves of some server to another position.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What makes these commands Smart? You can move slaves around from &lt;em&gt;anywhere&lt;/em&gt; to &lt;em&gt;anywhere&lt;/em&gt;. And &lt;em&gt;orchestrator&lt;/em&gt; figures out the bast execution path. If possible, it uses GTID. Not possible? Is Pseudo-GTID available? Great, using Pseudo-GTID. Oh, are there binlog servers involved? Really simple, use them. None of the above? &lt;em&gt;Orchestrator&lt;/em&gt; will use &#34;standard&#34; binlog file:pos math (with limitations). &lt;em&gt;Orchestrator&lt;/em&gt; will even figure out if multiple steps are necessary and will combine any of the above.&lt;/p&gt;
&lt;p&gt;So you don&#39;t have to remember all the possible ways and options. The visual cheatsheet now boils down to these two:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-cheatsheet-visualized-relocate.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7357&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-relocate.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-relocate&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-cheatsheet-visualized-relocate-slaves.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7350&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-relocate-slaves.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-relocate-slaves&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s take a slightly deeper look&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;relocate&lt;/h3&gt;
&lt;p&gt;Moves a single slave &lt;strong&gt;X&lt;/strong&gt; from any point to replicate another some server &lt;strong&gt;Z&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As usual, &lt;em&gt;orchestrator&lt;/em&gt; first confirms that &lt;strong&gt;X&lt;/strong&gt; &lt;em&gt;can&lt;/em&gt; replicate from &lt;strong&gt;Z&lt;/strong&gt; (&lt;strong&gt;Z&lt;/strong&gt; has &lt;strong&gt;log-slave-updates&lt;/strong&gt; or is a binlog server; binlog format compatible, etc.)&lt;/li&gt;
&lt;li&gt;With GTID/Pseudo-GTID, move from any point to any point&lt;/li&gt;
&lt;li&gt;With binlog servers, move around the binlog server environment (at this point you are not using binlog servers, so ignore)&lt;/li&gt;
&lt;li&gt;With normal replication, requires an &#34;atomic&#34; operation: either move the slave one level up, or make it replicate from a sibling.&lt;/li&gt;
&lt;li&gt;You can &lt;em&gt;relocate&lt;/em&gt; the same master, effectively repointing the slave back to its existing position. This serves to re-resolve master hostname; to reset relay logs; to verify slave is aligned with master.&lt;/li&gt;
&lt;li&gt;Or combination of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;relocate-slaves&lt;/h3&gt;
&lt;p&gt;Moves multiple slaves of server &lt;strong&gt;X&lt;/strong&gt; to replicate from some other server &lt;strong&gt;W&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;By default moves all slaves of &lt;strong&gt;X&lt;/strong&gt;, where possible&lt;/li&gt;
&lt;li&gt;Each slave verified to be able to replicate from &lt;strong&gt;W&lt;/strong&gt;. Those that can&#39;t are left behind.&lt;/li&gt;
&lt;li&gt;Can filter using regular expression via &lt;strong&gt;--pattern=some?[reg]ex&lt;/strong&gt; on slave hostnames&lt;/li&gt;
&lt;li&gt;Can relocate under same master, effectively repointing all slaves (see above explanation)&lt;/li&gt;
&lt;li&gt;Can relocate below one of the very slaves of X. If Y is in itself a slave of X and you&#39;re executing:&lt;br /&gt;
&lt;strong&gt;orchestrator -c relocate-slaves -i X -d Y&lt;/strong&gt;&lt;br /&gt;
then &lt;strong&gt;Y&lt;/strong&gt; is excluded from the list of relocated slaves. This effectively means &#34;make &lt;strong&gt;Y&lt;/strong&gt; local master of its current siblings&#34;. Very cool stuff.&lt;/li&gt;
&lt;li&gt;When binlog servers involved, simple math-less repointing takes place&lt;/li&gt;
&lt;li&gt;When GTID involved, let MySQL/MariaDB (both supported) do the math on a per-server basis&lt;/li&gt;
&lt;li&gt;When Pseudo-GTID involved, &lt;em&gt;greatly&lt;/em&gt; optimize by dividing into &lt;a href=&#34;https://en.wikipedia.org/wiki/Equivalence_class&#34;&gt;equivalence classes&lt;/a&gt; and only doing the math on a representative of each class.&lt;/li&gt;
&lt;li&gt;Or combination of the above&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What about the other commands?&lt;/h3&gt;
&lt;p&gt;The above covers such commands as &lt;strong&gt;move-up&lt;/strong&gt;, &lt;strong&gt;move-below&lt;/strong&gt;, &lt;strong&gt;repoint&lt;/strong&gt;, &lt;strong&gt;repoint-slaves&lt;/strong&gt;, &lt;strong&gt;match-below&lt;/strong&gt;, &lt;strong&gt;multi-match-slaves&lt;/strong&gt;, &lt;strong&gt;regroup-slaves&lt;/strong&gt; and more. It does not cover &lt;strong&gt;enslave-master&lt;/strong&gt; and &lt;strong&gt;make-co-master&lt;/strong&gt; which are a bit different.&lt;/p&gt;
&lt;p&gt;My guess is you can pass &lt;strong&gt;98%&lt;/strong&gt; of your operations with &lt;strong&gt;relocate &lt;/strong&gt;and &lt;strong&gt;relocate-slaves&lt;/strong&gt;. Otherwise just run &lt;em&gt;orchestrator&lt;/em&gt; with no arguments nor options to get a full-blown breakdown of available commands.&lt;/p&gt;
&lt;h3&gt;GUI drag-n-drop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;relocate-slaves&lt;/strong&gt; is achieved by dragging the slaves of an instance on top of a new master, as follows:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-before.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7372&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-before.png&#34; alt=&#34;orchestrator-relocate-slaves-before&#34; width=&#34;994&#34; height=&#34;369&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-hover.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7373&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-hover.png&#34; alt=&#34;orchestrator-relocate-slaves-hover&#34; width=&#34;996&#34; height=&#34;339&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-drag1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7377&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-drag1.png&#34; alt=&#34;orchestrator-relocate-slaves-drag&#34; width=&#34;980&#34; height=&#34;363&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/08/orchestrator-relocate-slaves-after.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7375&#34; src=&#34;/blog/blog/assets/orchestrator-relocate-slaves-after.png&#34; alt=&#34;orchestrator-relocate-slaves-after&#34; width=&#34;993&#34; height=&#34;345&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Find latest &lt;em&gt;orchestrator&lt;/em&gt; release at &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;https://github.com/outbrain/orchestrator/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.4.340: GTID, binlog servers, Smart Mode, failovers and lots of goodies</title>
      <link>/blog/2015/09/01/orchestrator-1-4-340-gtid-binlog-servers-smart-mode-failovers-and-lots-of-goodies/</link>
      <pubDate>Tue, 01 Sep 2015 12:10:15 +0000</pubDate>
      
      <guid>/blog/2015/09/01/orchestrator-1-4-340-gtid-binlog-servers-smart-mode-failovers-and-lots-of-goodies/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;&lt;strong&gt;Orchestrator&lt;/strong&gt; 1.4.340 is released&lt;/a&gt;. Not quite competing with the MySQL latest changelog, and as I haven&#39;t blogged about &lt;em&gt;orchestrator&lt;/em&gt; featureset in a while, this is a quick listing of &lt;em&gt;orchestrator&lt;/em&gt; features available since my last publication:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Supports &lt;strong&gt;GTID&lt;/strong&gt; (Oracle &amp;amp; MariaDB)
&lt;ul&gt;
&lt;li&gt;GTID still not being used in automated recovery -- in progress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable-gtid&lt;/strong&gt;, &lt;strong&gt;disable-gtid&lt;/strong&gt;, &lt;strong&gt;skip-query&lt;/strong&gt; for GTID commands&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Supports &lt;strong&gt;binlog servers&lt;/strong&gt; (MaxScale)
&lt;ul&gt;
&lt;li&gt;Discovery &amp;amp; operations on binlog servers&lt;/li&gt;
&lt;li&gt;Understanding slave repositioning in a binlog-server architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart mode&lt;/strong&gt;: relocate &amp;amp; relocate-below commands (or Web/GUI drag-n-drop) let &lt;em&gt;orchestrator&lt;/em&gt; figure out the best way of slave repositioning. &lt;em&gt;Orchestrator&lt;/em&gt; picks from GTID, Pseudo GTID, binlog servers, binlog file:pos math (and more) options, or combinations of the above. Fine grained commands still there, but mostly you won&#39;t need them.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Crash recoveries&lt;/strong&gt; (did you know &lt;em&gt;orchestrator&lt;/em&gt; does that?):
&lt;ul&gt;
&lt;li&gt;For intermediate master recovery: improved logic in picking the best recovery plan (prefer in-DC, prefer promoting local slave, supporting binlog server topologies, ...)&lt;/li&gt;
&lt;li&gt;For master recovery: even better slave promotion; supports &lt;em&gt;candidate slaves &lt;/em&gt;(prefer promoting such slaves); supports binlog server shared topologies&lt;/li&gt;
&lt;li&gt;Better auditing and logging of recovery cases&lt;/li&gt;
&lt;li&gt;Better analysis of crash scenarios, also in the event of lost VIPs, hanging connections; emergent checks in crash suspected scenarios&lt;/li&gt;
&lt;li&gt;recover-lite: do all topology-only recovery steps, without invoking external processes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better browser support&lt;/strong&gt;: used to only work on Firefox and Chrome (and the latter has had issues), the Web UI should now work well on all browsers, at the cost of reduced &lt;strong&gt;d3&lt;/strong&gt; animation. More work still in progress.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Faster&lt;/strong&gt;, more parallel, less blocking operations on all counts; removed a lots of serialized code; less locks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web enhancements&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;More verbose drag-n-drop (operation hint; color hints)&lt;/li&gt;
&lt;li&gt;Drag-n-drop for &lt;em&gt;slaves-of-a-server&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Replication/crash analysis dashboard&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pools&lt;/strong&gt;: &lt;em&gt;orchestrator&lt;/em&gt; can be &lt;em&gt;told&lt;/em&gt; about instance-to-pool association (&lt;strong&gt;submit-pool-instances&lt;/strong&gt; command)
&lt;ul&gt;
&lt;li&gt;And can then present pool status (web)&lt;/li&gt;
&lt;li&gt;Or pool hints within topologies (web)&lt;/li&gt;
&lt;li&gt;Or queried for all pools (&lt;strong&gt;cluster-pool-instances&lt;/strong&gt; command)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other:
&lt;ul&gt;
&lt;li&gt;Supports MySQL &lt;strong&gt;5.7&lt;/strong&gt; (tested with &lt;strong&gt;5.7.8&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Configurable graphite path for metrics&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--noop&lt;/strong&gt; flag; does all the work except for actually changing master on slaves. Shows intentions.&lt;/li&gt;
&lt;li&gt;Web (or cli &lt;strong&gt;which-cluster-osc-slaves&lt;/strong&gt; command) provide list of control slaves to use in &lt;strong&gt;pt-osc&lt;/strong&gt; operation&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hostname-unresolve&lt;/strong&gt;: force &lt;em&gt;orchestrator&lt;/em&gt; to unresolve a fqdn into VIP/CNAME/... when issuing a CHANGE MASTER TO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3rd party contributions (hey, thanks!) include:
&lt;ul&gt;
&lt;li&gt;More &amp;amp; better SSL support&lt;/li&gt;
&lt;li&gt;Vagrant templates&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For developers:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Orchestrator&lt;/em&gt; now go-gettable. Just &lt;strong&gt;go get github.com/outbrain/orchestrator&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Improved build script; supports more architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Also consider these manuals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual&#34;&gt;The Orchestrator Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-deployment&#34;&gt;Orchestrator deployment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-first-steps&#34;&gt;Orchestrator first steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-for-developers&#34;&gt;Orchestrator for developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; is free and open source (Apache 2.0 License).&lt;/p&gt;
&lt;p&gt;I&#39;ll be &lt;a href=&#34;https://www.percona.com/live/europe-amsterdam-2015/sessions/managing-and-visualizing-your-replication-topologies-orchestrator&#34;&gt;speaking about orchestrator in PerconaLive Amsterdam&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>On SHOW BINLOG/RELAYLOG EVENTS</title>
      <link>/blog/2015/08/04/on-show-binlogrelaylog-events/</link>
      <pubDate>Tue, 04 Aug 2015 11:38:13 +0000</pubDate>
      
      <guid>/blog/2015/08/04/on-show-binlogrelaylog-events/</guid>
      <description>&lt;p&gt;Some notes after working with &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/en/show-binlog-events.html&#34;&gt;SHOW BINLOG EVENTS&lt;/a&gt; and &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/en/show-relaylog-events.html&#34;&gt;SHOW RELAYLOG EVENTS&lt;/a&gt; statements; there are a few gotchas and some interesting facts. My reflections also follow.&lt;/p&gt;
&lt;p&gt;I&#39;m calling these commands from &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt; when working with &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;Pseudo-GTID&lt;/a&gt; (which I do &lt;em&gt;alot&lt;/em&gt;). I prefer to work with agent-free design, where a single, remote service can do everything: examine replication status, scan binary logs for information, and recover broken topologies via gluing together servers that were not previously directly associated.&lt;/p&gt;
&lt;p&gt;Alas, documentation is short on these commands, and some stuff I learned the hard way.&lt;/p&gt;
&lt;p&gt;Basically, &lt;strong&gt;SHOW BINLOG/RELAYLOG EVENTS&lt;/strong&gt; commands are a poor man&#39;s replacement to &lt;strong&gt;mysqlbinlog&lt;/strong&gt;, only you can issue them on MySQL protocol, and you do not have to have the binary/relay log files locally on your host.&lt;/p&gt;
&lt;h3&gt;Fun fact&lt;/h3&gt;
&lt;p&gt;The binary logs are called so because they are compressed. You are familiar with the binlog position you see on &lt;strong&gt;SHOW MASTER STATUS&lt;/strong&gt; or &lt;strong&gt;SHOW SLAVE STATUS&lt;/strong&gt;. You are familiar with the binlog position as you see it when you execute &lt;strong&gt;&#34;mysqlbinlog mybinlog.001234&#34;&lt;/strong&gt;. The position of a new entry equals to the file size of the binary log at that time. If:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$ ls -l master/data/mysql-bin.015901
-rw-rw---- 1 user user 401408 Jul 18 02:44 master/data/mysql-bin.015901&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then the next entry will be at position &lt;strong&gt;401408&lt;/strong&gt;, as this is the file size in bytes.&lt;/p&gt;
&lt;p&gt;And so when MySQL writes an entry to the binary log, it (of course) knows the entry&#39;s position in the binary log, but then also immediately knows the position of the next entry.&lt;/p&gt;
&lt;p&gt;We&#39;ll revisit this fact later.&lt;/p&gt;
&lt;h3&gt;Output of SHOW BINLOG/RELAYLOG EVENTS&lt;/h3&gt;
&lt;p&gt;The output of both statement depends on the &lt;strong&gt;binlog_format&lt;/strong&gt;. In Statement Based Replication it may look like:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$gt; SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; LIMIT 40,20;
+------------------+------+------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type | Server_id | End_log_pos | Info                                                                                                                |
+------------------+------+------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------+
| mysql-bin.015903 | 3650 | Gtid       |         1 |        3698 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:790000&#39;                                              |
| mysql-bin.015903 | 3698 | Query      |         1 |        3785 | BEGIN                                                                                                               |
| mysql-bin.015903 | 3785 | User var   |         1 |        3832 | @`id`=7                                                                                                             |
| mysql-bin.015903 | 3832 | Query      |         1 |        3969 | use `test`; replace into test.t (id, i, t) values (@id, @id, now())                                                 |
| mysql-bin.015903 | 3969 | Xid        |         1 |        4000 | COMMIT /* xid=967 */                                                                                                |
| mysql-bin.015903 | 4000 | Gtid       |         1 |        4048 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:790001&#39;                                              |
| mysql-bin.015903 | 4048 | Query      |         1 |        4135 | BEGIN                                                                                                               |
| mysql-bin.015903 | 4135 | User var   |         1 |        4182 | @`id`=9                                                                                                             |
| mysql-bin.015903 | 4182 | Query      |         1 |        4319 | use `test`; replace into test.t (id, i, t) values (@id, @id, now())                                                 |
| mysql-bin.015903 | 4319 | Xid        |         1 |        4350 | COMMIT /* xid=969 */                                                                                                |
| mysql-bin.015903 | 4350 | Gtid       |         1 |        4398 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:790002&#39;                                              |
| mysql-bin.015903 | 4398 | Query      |         1 |        4576 | use `meta`; drop view if exists `meta`.`_pseudo_gtid_hint__asc(55B50F9C:00000000000000D4:C96BF9F7)` |
| mysql-bin.015903 | 4576 | Gtid       |         1 |        4624 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:790003&#39;                                              |
| mysql-bin.015903 | 4624 | Query      |         1 |        4711 | BEGIN                                                                                                               |
| mysql-bin.015903 | 4711 | User var   |         1 |        4758 | @`id`=6                                                                                                             |
| mysql-bin.015903 | 4758 | Query      |         1 |        4895 | use `test`; replace into test.t (id, i, t) values (@id, @id, now())                                                 |
| mysql-bin.015903 | 4895 | Xid        |         1 |        4926 | COMMIT /* xid=971 */                                                                                                |
| mysql-bin.015903 | 4926 | Gtid       |         1 |        4974 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:790004&#39;                                              |
| mysql-bin.015903 | 4974 | Query      |         1 |        5077 | BEGIN                                                                                                               |
| mysql-bin.015903 | 5077 | User var   |         1 |        5133 | @`hostname`=_utf8 0x736E6F6163682D616D7339 COLLATE utf8_general_ci                                                  |
+------------------+------+------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first thing to note is that there&#39;s far less data in this output as compared to &lt;strong&gt;mysqlbinlog&lt;/strong&gt;&#39;s. For example, you can&#39;t see the TIMESTAMP at which the queries were issued. You can&#39;t see additional metadata like RAND() seed. Thus far it is documented.&lt;/p&gt;
&lt;p&gt;You do know the binlog file name, position, end-position (which is the position of the next entry), originating &lt;strong&gt;server_id&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;However with Row Based Replication things are even less informative:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;$gt; SHOW BINLOG EVENTS IN &#39;mysql-bin.015902&#39; LIMIT 20,20;
+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                   |
+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
| mysql-bin.015902 | 1365 | Query       |         1 |        1453 | BEGIN                                                                  |
| mysql-bin.015902 | 1453 | Table_map   |         1 |        1535 | table_id: 71 (meta.pseudo_gtid_status)                                 |
| mysql-bin.015902 | 1535 | Update_rows |         1 |        1829 | table_id: 71 flags: STMT_END_F                                         |
| mysql-bin.015902 | 1829 | Xid         |         1 |        1860 | COMMIT /* xid=26 */                                                    |
| mysql-bin.015902 | 1860 | Gtid        |         1 |        1908 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:789767&#39; |
| mysql-bin.015902 | 1908 | Query       |         1 |        1988 | BEGIN                                                                  |
| mysql-bin.015902 | 1988 | Table_map   |         1 |        2035 | table_id: 70 (test.t)                                                  |
| mysql-bin.015902 | 2035 | Update_rows |         1 |        2129 | table_id: 70 flags: STMT_END_F                                         |
| mysql-bin.015902 | 2129 | Xid         |         1 |        2160 | COMMIT /* xid=29 */                                                    |
| mysql-bin.015902 | 2160 | Gtid        |         1 |        2208 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:789768&#39; |
| mysql-bin.015902 | 2208 | Query       |         1 |        2288 | BEGIN                                                                  |
| mysql-bin.015902 | 2288 | Table_map   |         1 |        2335 | table_id: 70 (test.t)                                                  |
| mysql-bin.015902 | 2335 | Update_rows |         1 |        2429 | table_id: 70 flags: STMT_END_F                                         |
| mysql-bin.015902 | 2429 | Xid         |         1 |        2460 | COMMIT /* xid=32 */                                                    |
| mysql-bin.015902 | 2460 | Gtid        |         1 |        2508 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:789769&#39; |
| mysql-bin.015902 | 2508 | Query       |         1 |        2588 | BEGIN                                                                  |
| mysql-bin.015902 | 2588 | Table_map   |         1 |        2635 | table_id: 70 (test.t)                                                  |
| mysql-bin.015902 | 2635 | Update_rows |         1 |        2729 | table_id: 70 flags: STMT_END_F                                         |
| mysql-bin.015902 | 2729 | Xid         |         1 |        2760 | COMMIT /* xid=34 */                                                    |
| mysql-bin.015902 | 2760 | Gtid        |         1 |        2808 | SET @@SESSION.GTID_NEXT= &#39;230ea8ea-81e3-11e4-972a-e25ec4bd140a:789770&#39; |
+------------------+------+-------------+-----------+-------------+------------------------------------------------------------------------+
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;What&#39;s this? We don&#39;t get the statement anymore. I mean, sure, this is RBR, but there&#39;s no more info! All we knows is there was an &lt;strong&gt;Update_rows&lt;/strong&gt; on test.t; that also only after we&#39;ve crossed two different entries, one mapping a test.t to &lt;strong&gt;70&lt;/strong&gt;, the other telling us an &lt;strong&gt;UPDATE&lt;/strong&gt; operation was made on &lt;strong&gt;70&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This is the reason &lt;a href=&#34;http://code.openark.org/blog/mysql/pseudo-gtid-row-based-replication&#34;&gt;why Pseudo GTID injection is made via DDL&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With RBR we also get some excessive information. The &lt;strong&gt;table_id&lt;/strong&gt; mentioned above is true for this server; but on a slave the table would have a different id. The SHOW output would look different. Likewise, the commit number as in &lt;strong&gt;&#34;COMMIT /* xid=32 */&#34;&lt;/strong&gt; changes from server to server. There are also other entries which may look different; character encoding changes shape. Really weird stuff.&lt;/p&gt;
&lt;p&gt;The output of &lt;strong&gt;SHOW RELAYLOG EVENTS&lt;/strong&gt; is very similar, except for the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Obviously we&#39;re parsing and outputting relay logs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pos&lt;/strong&gt; column relates to the position in the relay log where the entry starts (makes sense)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;End_log_pos&lt;/strong&gt; column relates to the next binlog position &lt;em&gt;of the master&#39;s binary log&lt;/em&gt; that correlates to this query. Read that again. There is no telling what the end-log-pos is for the relay log entry. We&#39;ll revisit that shortly.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Locking issues&lt;/h3&gt;
&lt;p&gt;Unfortunately, issuing a &lt;strong&gt;SHOW BINLOG EVENTS&lt;/strong&gt; &lt;a href=&#34;https://bugs.mysql.com/bug.php?id=76618&#34;&gt;completely locks down the binary logs&lt;/a&gt; on the server.&lt;/p&gt;
&lt;p&gt;Yes. This means you cannot write to the binary logs while issuing the &lt;strong&gt;SHOW&lt;/strong&gt; statement. And that means you cannot write, everything piles up and your server is under complete lock down.&lt;/p&gt;
&lt;p&gt;Before you throw your hands up in the air and move on to read something that can cheer you up, note that things are not completely bad. We are able at &lt;strong&gt;Booking.com&lt;/strong&gt; to scan &lt;strong&gt;24&lt;/strong&gt; hours worth of binary logs (i.e. dozens of hundreds of binary logs) on business-critical MySQL masters without making an impact. How?&lt;/p&gt;
&lt;h3&gt;SHOW...LIMIT offset, row_count vs SHOW...FROM pos LIMIT row_count&lt;/h3&gt;
&lt;p&gt;Of course the solution is to do many small steps instead of few giant steps. Reading all of a binary log&#39;s entries is suicidal to your application &amp;amp; database. The &lt;strong&gt;SHOW BINLOG/RELAYLOG EVENTS&lt;/strong&gt; statements support a &lt;strong&gt;LIMIT&lt;/strong&gt; clause.&lt;/p&gt;
&lt;p&gt;As per previous example, you may:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; LIMIT 40,20;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;This skips &lt;strong&gt;40&lt;/strong&gt; entries (&lt;strong&gt;offset&lt;/strong&gt;), then reads &lt;strong&gt;20&lt;/strong&gt; &lt;strong&gt;(row_count&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;However much like non-indexed table scan, to skip the first &lt;strong&gt;40&lt;/strong&gt; entries you must nonetheless iterate them. Since we don&#39;t know exactly where in the binlog the &lt;strong&gt;41st&lt;/strong&gt; entry begins, we need to unpack the binary log from start and find it out the full-scan way.&lt;/p&gt;
&lt;p&gt;Don&#39;t iterate a binary log&#39;s entries via &lt;strong&gt;LIMIT 0,1000&lt;/strong&gt;; &lt;strong&gt;LIMIT 1000,1000&lt;/strong&gt;; &lt;strong&gt;LIMIT 2000,1000&lt;/strong&gt;; ... This is O(n²)&lt;/p&gt;
&lt;p&gt;In contrast, you may:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; &lt;strong&gt;FROM&lt;/strong&gt; 3650 LIMIT 20;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;Remember that an entry&#39;s position is the binlog file size at the time before the entry was written? To execute the above MySQL &lt;em&gt;merely &lt;strong&gt;seeks&lt;/strong&gt;&lt;/em&gt; the binlog file 3650 bytes ahead. No scan required.&lt;/p&gt;
&lt;p&gt;You must provide with a valid position value. If I just guess my way:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&amp;gt; SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; FROM 3651 LIMIT 20;
ERROR 1220 (HY000): Error when executing command SHOW BINLOG EVENTS: Wrong offset or I/O error&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;And so you must have prior knowledge about positions. This is fine if you&#39;re scanning a binary log: you simply read the &lt;strong&gt;End_log_pos&lt;/strong&gt; of the last entry you&#39;ve just read and memorize it. Thus, to scan a binary log, you can:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&amp;gt; SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; LIMIT 20;

&amp;gt; SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; FROM 1499 LIMIT 20;

&amp;gt; SHOW BINLOG EVENTS IN &#39;mysql-bin.015903&#39; FROM 3651 LIMIT 20;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;But it&#39;s more difficult to do this for relay logs: remember that the &lt;strong&gt;End_log_pos&lt;/strong&gt; in &lt;strong&gt;SHOW RELAYLOG EVENTS&lt;/strong&gt; relates to the next position in the &lt;em&gt;master&#39;s binary log&lt;/em&gt;. So you need to resort to an off-by-one or something. However the good news is that reading relay logs &lt;em&gt;does not&lt;/em&gt; block writes on your server.&lt;/p&gt;
&lt;h3&gt;Locking thoughts&lt;/h3&gt;
&lt;p&gt;As per my comments in the bug report, I don&#39;t see why &lt;strong&gt;SHOW BINLOG EVENTS&lt;/strong&gt; should always lock writes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If we&#39;re scanning an old binary log (not the one being written to) then obviously we should not be blocking writes.&lt;/li&gt;
&lt;li&gt;If we&#39;re scanning the current binlog, but are known to end with a statement that is already written (i.e. not trying to scan past the current writing position) then we should not be blocking writes.&lt;/li&gt;
&lt;li&gt;OK to block writes when trying to read past current position.&lt;/li&gt;
&lt;li&gt;OK to block on a &lt;strong&gt;FLUSH MASTER LOGS&lt;/strong&gt;, &lt;strong&gt;PURGE MASTER LOGS&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Why is the output so limited?&lt;/h3&gt;
&lt;p&gt;I&#39;m actually unsure why the output of these commands is so limited as compared to the &lt;strong&gt;mysqlbinlog&lt;/strong&gt; output. A replicating slave talks to the master over MySQL protocol; the slave &lt;em&gt;does get&lt;/em&gt; all the data right. It &lt;em&gt;does get&lt;/em&gt; event metadata (timestamp, random seed, session variable). It &lt;em&gt;does get&lt;/em&gt; complete statement/row data. What I&#39;m saying is that this functionality is already built in; it could be very easily added to the &lt;strong&gt;SHOW&lt;/strong&gt; commands.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pseudo GTID, ASCENDING</title>
      <link>/blog/2015/07/29/pseudo-gtid-ascending/</link>
      <pubDate>Wed, 29 Jul 2015 12:59:50 +0000</pubDate>
      
      <guid>/blog/2015/07/29/pseudo-gtid-ascending/</guid>
      <description>&lt;p&gt;Pseudo GTID is a technique where we inject Globally Unique entries into MySQL, gaining GTID abilities without using GTID. It is supported by &lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;&lt;/strong&gt; and described in more detail &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;http://code.openark.org/blog/tag/pseudo-gtid&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual#pseudo-gtid&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Quick recap: we can join two slaves to replicate from one another even if they never were in parent-child relationship, based on our uniquely identifiable entries which can be found in the slaves&#39; binary logs or relay logs. Having Pseudo-GTID injected and controlled by us allows us to optimize failovers into quick operations, especially where a large number of server is involved.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ascending Pseudo-GTID&lt;/strong&gt; further speeds up this process for delayed/lagging slaves.&lt;/p&gt;
&lt;h3&gt;Recap, visualized&lt;/h3&gt;
&lt;p&gt;(but do look at the &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;presentation&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/pseudo-gtid-quick1.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7303&#34; src=&#34;/blog/blog/assets/pseudo-gtid-quick1.png&#34; alt=&#34;pseudo-gtid-quick&#34; width=&#34;636&#34; height=&#34;366&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find last pseudo GTID in slave’s binary log (or last applied one in relay log)&lt;/li&gt;
&lt;li&gt;Search for exact match on new master’s binary logs&lt;/li&gt;
&lt;li&gt;Fast forward both through successive identical statements until end of slave’s applied entries is reached&lt;/li&gt;
&lt;li&gt;Point slave into cursor position on master&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;What happens if the slave we wish to reconnect is lagging? Or perhaps it is a delayed replica, set to run &lt;strong&gt;24&lt;/strong&gt; hours behind its master?&lt;/p&gt;
&lt;p&gt;The naive approach would expand bullet &lt;strong&gt;#2&lt;/strong&gt; into:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search for exact match on master’s last binary logs&lt;/li&gt;
&lt;li&gt;Unfound? Move on to previous (older) binary log on master&lt;/li&gt;
&lt;li&gt;Repeat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last Pseudo-GTID executed by the slave was issued by the master over &lt;strong&gt;24&lt;/strong&gt; hours ago. Suppose the master generates one binary log per hour. This means we would need to full-scan &lt;strong&gt;24&lt;/strong&gt; binary logs of the master where the entry will not be found; to only be matched in the &lt;strong&gt;25th&lt;/strong&gt; binary log (it&#39;s an off-by-one problem, don&#39;t hold the exact number against me).&lt;/p&gt;
&lt;h3&gt;Ascending Pseudo GTID&lt;/h3&gt;
&lt;p&gt;Since we control the generation of Pseudo-GTID, and since we control the search for Pseudo-GTID, we are free to choose the form of Pseudo-GTID entries. We recently switched into using Ascending Pseudo-GTID entries, and this works like a charm. Consider these Pseudo-GTID entries:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364E3:0000000000056EE2:6DD57B85&lt;/strong&gt;`
drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364E8:0000000000056EEC:ACF03802&lt;/strong&gt;`
drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364ED:0000000000056EF8:06279C24&lt;/strong&gt;`
drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364F2:0000000000056F02:19D785E4&lt;/strong&gt;`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above entries are ascending in lexical order. The above is generated using a UTC timestamp, along with other watchdog/random values. For a moment let&#39;s trust that our generation is indeed always ascending. How does that help us?&lt;/p&gt;
&lt;p&gt;Suppose the last entry found in the slave is&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B364E3:0000000000056EE2:6DD57B85&lt;/strong&gt;`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;And this is what we&#39;re to search on the master&#39;s binary logs. Starting with the optimistic hope that the entry is in the master&#39;s last binary log, we start reading. By nature of binary logs we have to scan them sequentially from start to end. As we read the binary log entries, we soon meet the first Pseudo-GTID injection, and it reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;drop view if exists `meta`.`&lt;strong&gt;_pseudo_gtid_hint__asc:55B730E6:0000000000058F02:19D785E4&lt;/strong&gt;`&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;At this stage we know we can completely skip scanning the rest of the binary log. Our entry will not be there: this entry is larger than the one we&#39;re looking for, and they&#39;ll only get larger as we get along in the binary log. It is therefore safe to ignore the rest of this file and move on to the next-older binary log on the master, to repeat our search there.&lt;/p&gt;
&lt;p&gt;Binary logs where the entry cannot be in are only briefly examined: &lt;em&gt;orchestrator&lt;/em&gt; will probably read no more than first &lt;strong&gt;1,000&lt;/strong&gt; entries or so (can&#39;t give you a number, it&#39;s your workload) before giving up on the binary log.&lt;/p&gt;
&lt;p&gt;On every topology chain we have &lt;strong&gt;2&lt;/strong&gt; delayed replica slaves, to help us out in the case we make a grave mistake of DELETing the wrong data. These slaves would take, on some chains, &lt;strong&gt;5-6&lt;/strong&gt; minutes to reconnect to a new master using Pseudo-GTID, since it required scanning many many GBs of binary logs. This is no longer the case; we&#39;ve reduced scan time for such servers to about &lt;strong&gt;25s&lt;/strong&gt; at worst, and much quicker on average. There can still be dozens of binary logs to open, but all but one are given up very quickly. I should stress that those &lt;strong&gt;25s&lt;/strong&gt; are nonblocking for other slaves which are mote up to date than the delayed replicas.&lt;/p&gt;
&lt;h3&gt;Can there be a mistake?&lt;/h3&gt;
&lt;p&gt;Notice that the above algorithm does not require each and every entry to be ascending; it just compares the first entry in each binlog to determine whether our target entry is there or not. This means if we&#39;ve messed up our Ascending order and injected some out-of-order entries, we can still get away with it -- as long as those entries are not the first ones in the binary log, nor are they the last entries executed by the slave.&lt;/p&gt;
&lt;p&gt;But why be so negative? We&#39;re using UTC timestamp as the major sorting order, and inject Pseudo-GTID every &lt;strong&gt;5&lt;/strong&gt; seconds; even with leap second we&#39;re comfortable.&lt;/p&gt;
&lt;p&gt;On my TODO is to also include a &#34;Plan B&#34; full-scan search: if the Ascending algorithm fails, we can still opt for the full scan option. So there would be no risk at all.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;We inject Pseudo-GTID via event-scheduler. These are the good parts of the event definition:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;create event if not exists
  create_pseudo_gtid_event
  on schedule every 5 second starts current_timestamp
  on completion preserve
  enable
  do
    begin
      set @connection_id := connection_id();
      set @now := now();
      set @rand := floor(rand()*(1 &amp;lt;&amp;lt; 32));
      &lt;strong&gt;set @pseudo_gtid_hint := concat_ws(&#39;:&#39;, lpad(hex(unix_timestamp(@now)), 8, &#39;0&#39;), lpad(hex(@connection_id), 16, &#39;0&#39;), lpad(hex(@rand), 8, &#39;0&#39;));&lt;/strong&gt;
&lt;strong&gt;
      set @_create_statement := concat(&#39;drop &#39;, &#39;view if exists `meta`.`_pseudo_gtid_&#39;, &#39;hint__asc:&#39;, @pseudo_gtid_hint, &#39;`&#39;);&lt;/strong&gt;
      PREPARE st FROM @_create_statement;
      EXECUTE st;
      DEALLOCATE PREPARE st;
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;We accompany this by the following &lt;em&gt;orchestrator&lt;/em&gt; configuration:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt; &#34;PseudoGTIDPattern&#34;: &#34;drop view if exists .*?`_pseudo_gtid_hint__&#34;,
 &#34;PseudoGTIDMonotonicHint&#34;: &#34;asc:&#34;,&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&#34;PseudoGTIDMonotonicHint&#34;&lt;/strong&gt; notes a string; if that string (&lt;strong&gt;&#34;asc:&#34;&lt;/strong&gt;) is found in the slave&#39;s Pseudo-GTID entry, then the entry is assumed to have been injected as part of ascending entries, and the optimization kicks in.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual#pseudo-gtid&#34;&gt;The Manual&lt;/a&gt; has more on this.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>What makes a MySQL server failure/recovery case?</title>
      <link>/blog/2015/07/25/what-makes-a-mysql-server-failurerecovery-case/</link>
      <pubDate>Sat, 25 Jul 2015 09:00:03 +0000</pubDate>
      
      <guid>/blog/2015/07/25/what-makes-a-mysql-server-failurerecovery-case/</guid>
      <description>&lt;p&gt;Or: How do you reach the conclusion your MySQL master/intermediate-master is dead and must be recovered?&lt;/p&gt;
&lt;p&gt;This is an attempt at making a holistic diagnosis of our replication topologies. The aim is to cover obvious and not-so-obvious crash scenarios, and to be able to act accordingly and heal the topology.&lt;/p&gt;
&lt;p&gt;At &lt;strong&gt;Booking.com&lt;/strong&gt; we are dealing with very large amounts of MySQL servers. We have many topologies, and many servers in each topology. &lt;a href=&#34;https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management&#34;&gt;See past numbers&lt;/a&gt; to get a feel for it. At these numbers failures happen frequently. Typically we would see normal slaves failing, but occasionally -- and far more frequently than we would like to be paged for -- an intermediate master or a master would crash. But our current (and ever in transition) setup also include SANs, DNS records, VIPs, any of which can fail and bring down our topologies.&lt;/p&gt;
&lt;p&gt;Tackling issues of monitoring, disaster analysis and recovery processes, I feel safe to claim the following statements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The fact your monitoring tool cannot access your database does not mean your database has failed.&lt;/li&gt;
&lt;li&gt;The fact your monitoring tool can access your database does not mean your database is available.&lt;/li&gt;
&lt;li&gt;The fact your database master is unwell does not mean you should fail over.&lt;/li&gt;
&lt;li&gt;The fact your database master is alive and well does not mean you should not fail over.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bummer. Let&#39;s review a simplified topology with a few failure scenarios. Some of these scenarios you will find familiar. Some others may be caused by setups you&#39;re not using. I would love to say &lt;em&gt;I&#39;ve seen it all&lt;/em&gt; but the more I see the more I know how strange things can become.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;We will consider the simplified case of a master with three replicas: we have &lt;strong&gt;M&lt;/strong&gt; as master, &lt;strong&gt;A&lt;/strong&gt;, &lt;strong&gt;B&lt;/strong&gt;, &lt;strong&gt;C&lt;/strong&gt; as slaves.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7280&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures.png&#34; alt=&#34;mysql-topologies-failures&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;A common monitoring scheme is to monitor each machine&#39;s IP, availability of MySQL port (&lt;strong&gt;3306&lt;/strong&gt;) and responsiveness to some simple query (e.g. &lt;strong&gt;&#34;SELECT 1&#34;&lt;/strong&gt;). Some of these checks may run local to the machine, others remote.&lt;/p&gt;
&lt;p&gt;Now consider your monitoring tool fails to connect to your master.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-1.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7281&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-1.png&#34; alt=&#34;mysql-topologies-failures (1)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;I&#39;ve marked the slaves with question marks as the common monitoring schema does not associate the master&#39;s monitoring result to the slaves&#39;.  Can you safely conclude your master is dead? Are your feeling comfortable with initiating a failover process? How about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Temporary network partitioning; it just so happens that your monitoring tool cannot access the master, though everyone else can.&lt;/li&gt;
&lt;li&gt;DNS/VIP/name cache/name resolving issue. Sometimes similar to the above; does you monitoring tool host think the master&#39;s IP is what it really is? Has something just changed? Some cache expired? Some cache is stale?&lt;/li&gt;
&lt;li&gt;MySQL connection rejection. This could be due to a serious &#34;Too many connections&#34; problem on the master, or due to accidental network noise.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now consider the following case: a first tier slave is failing to connect to the master:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-2.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7282&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-2.png&#34; alt=&#34;mysql-topologies-failures (2)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;The slave&#39;s IO thread is broken; do we have a problem here? Is the slave failing to connect because the master is dead, or because the slave itself suffers from a network partitioning glitch?&lt;/p&gt;
&lt;h3&gt;A holistic diagnosis&lt;/h3&gt;
&lt;p&gt;In the holistic approach we couple the master&#39;s monitoring with that of its direct slaves. Before I continue to describe some logic, the previous statement is something we must reflect upon.&lt;/p&gt;
&lt;p&gt;We should associate the master&#39;s state with that of its direct slaves. Hence we must know which are its direct slaves. We might have slaves D, E, F, G replicating from B, C. They are not in our story. But slaves come and go. Get provisioned and de-provisioned. They get repointed elsewhere. Our monitoring needs to be aware of the &lt;em&gt;state&lt;/em&gt; of our replication topology.&lt;/p&gt;
&lt;p&gt;My preferred tool for the job is &lt;a href=&#34;https://github.com/outbrain/orchestrator/&#34;&gt;orchestrator&lt;/a&gt;, since I author it. It is not a standard monitoring tool and does not serve metrics; but it observes your topologies and records them. And notes changes. And acts as a higher level failure detection mechanism which incorporates the logic described below.&lt;/p&gt;
&lt;p&gt;We continue our discussion under the assumption we are able to reliably claim we know our replication topology. Let&#39;s revisit our scenarios from above and then add some.&lt;/p&gt;
&lt;p&gt;We will further only require MySQL client protocol connection to our database servers.&lt;/p&gt;
&lt;h3&gt;Dead master&lt;/h3&gt;
&lt;p&gt;A &#34;real&#34; dead master is perhaps the clearest failure. MySQL has crashed (signal 11); or the kernel panicked; or the disks failed; or power went off. The server is &lt;em&gt;really not serving&lt;/em&gt;. This is observed as:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-3.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7284&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-3.png&#34; alt=&#34;mysql-topologies-failures (3)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;In the holistic approach, we observe that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We cannot reach the master (our MySQL client connection fails).&lt;/li&gt;
&lt;li&gt;But we are able to connect to the slaves A, B, C&lt;/li&gt;
&lt;li&gt;And A, B, C &lt;em&gt;are all telling us&lt;/em&gt; they cannot connect to the master&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We have now cross referenced the death of the master with its three slaves. Funny thing is the MySQL server on the master may still be up and running. Perhaps the master is suffering from some weird network partitioning problem (when I say &#34;weird&#34;, I mean we have it; discussed further below). And &lt;em&gt;perhaps&lt;/em&gt; some application is actually still able to talk to the master!&lt;/p&gt;
&lt;p&gt;And yet our entire replication topology is broken. Replication is not there for beauty; it serves our application code. And it&#39;s turning stale. Even if by some chance things are still operating on the master, this still makes for a valid failover scenario.&lt;/p&gt;
&lt;h3&gt;Unreachable master&lt;/h3&gt;
&lt;p&gt;Compare the above with:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-4.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7285&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-4.png&#34; alt=&#34;mysql-topologies-failures (4)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Our monitoring scheme cannot reach our master. But it can reach the slaves, an they&#39;re all saying: &lt;em&gt;&#34;I&#39;m happy!&#34;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This gives us suspicion enough to avoid failing over. We may not actually have a problem: it&#39;s just &lt;em&gt;us&lt;/em&gt; that are unable to connect to the master.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Right?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There are still interesting use cases. Consider the problem of &lt;strong&gt;&#34;Too many connections&#34;&lt;/strong&gt; on the master. You are unable to connect; the application starts throwing errors; but the slaves are happy. They were there first. They started replicating at the dawn of time, long before there was an issue. Their persistent connections are good to go.&lt;/p&gt;
&lt;p&gt;Or the master may suffer a deadlock. A long, blocking &lt;strong&gt;ALTER TABLE&lt;/strong&gt;. An accidental &lt;strong&gt;FLUSH TABLES WITH READ LOCK&lt;/strong&gt;. Or whatever occasional bug we hit. Slaves are still connected; but new connections are hanging; and your monitoring query is unable to process.&lt;/p&gt;
&lt;p&gt;And still our holistic approach can find that out: as we are able to connect to our slaves, we are also able to ask them: well what have your relay logs have to say about this? Are we progressing in replication position? Do we actually find application content in the slaves&#39; relay logs? We can do all this via MySQL protocol (&lt;strong&gt;&#34;SHOW SLAVE STATUS&#34;&lt;/strong&gt;, &lt;strong&gt;&#34;SHOW RELAYLOG EVENTS&#34;&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;Understanding the topology gives you greater insight into your failure case; you have increasing leevels of confidentiality in your analysis. Strike that: in your &lt;em&gt;automated&lt;/em&gt; analysis.&lt;/p&gt;
&lt;h3&gt;Dead master and slaves&lt;/h3&gt;
&lt;p&gt;They&#39;re all &lt;em&gt;gone&lt;/em&gt;!&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-5.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7287&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-5.png&#34; alt=&#34;mysql-topologies-failures (5)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;You cannot reach the master &lt;em&gt;and&lt;/em&gt; you cannot reach any of its slaves. Once you are able to associate your master and slaves you can conclude you either have a complete DC power failure problem (or is this cross DC?) or you are having a network partitioning problem. Your application may or may not be affected -- but at least you know where to start. Compare with:&lt;/p&gt;
&lt;h3&gt;Failed DC&lt;/h3&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-6.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7289&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-6.png&#34; alt=&#34;mysql-topologies-failures (6)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;I&#39;m stretching it now, because when a DC fails all the red lights start flashing. Nonetheless, if M, A, B are all in one DC and C is on another, you have yet another diagnosis.&lt;/p&gt;
&lt;h3&gt;Dead master and some slaves&lt;/h3&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-7.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7290&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-7.png&#34; alt=&#34;mysql-topologies-failures (7)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Things start getting complicated when you&#39;re unable to get an authorized answer from everyone. What happens if the master is dead as well as one of its slaves? We previously expected all slaves to say &#34;we cannot replicate&#34;. For us, master being unreachable, some slaves being dead and all other complaining on IO thread is good enough indication that the master is dead.&lt;/p&gt;
&lt;h3&gt;All first tier slaves not replicating&lt;/h3&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/mysql-topologies-failures-9.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7293&#34; src=&#34;/blog/blog/assets/mysql-topologies-failures-9.png&#34; alt=&#34;mysql-topologies-failures (9)&#34; width=&#34;192&#34; height=&#34;108&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Not a failover case, but certainly needs to ring the bells. All master&#39;s direct slaves are failing replication on some SQL error or are just stopped. Our topology is turning stale.&lt;/p&gt;
&lt;h3&gt;Intermediate masters&lt;/h3&gt;
&lt;p&gt;With intermediate master the situation is not all that different. In the below:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/07/Untitled-presentation.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7294&#34; src=&#34;/blog/blog/assets/Untitled-presentation.png&#34; alt=&#34;Untitled presentation&#34; width=&#34;480&#34; height=&#34;270&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;The servers &lt;strong&gt;E&lt;/strong&gt;, &lt;strong&gt;F&lt;/strong&gt;, &lt;strong&gt;G&lt;/strong&gt; replicating from &lt;strong&gt;C&lt;/strong&gt; provide us with the holistic view on &lt;strong&gt;C&lt;/strong&gt;. &lt;strong&gt;D&lt;/strong&gt; provides the holistic view on &lt;strong&gt;A&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Reducing noise&lt;/h3&gt;
&lt;p&gt;Intermediate master failover is a much simpler operation than master failover. Changing masters require name resolve changes (of some sort), whereas moving slaves around the topology affects no one.&lt;/p&gt;
&lt;p&gt;This implies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We don&#39;t mind over-reacting on failing over intermediate masters&lt;/li&gt;
&lt;li&gt;We pay with more noise&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sure, we don&#39;t mind failing over &lt;strong&gt;D&lt;/strong&gt; elsewhere, but as &lt;strong&gt;D&lt;/strong&gt; is the only slave of &lt;strong&gt;A&lt;/strong&gt;, it&#39;s enough that &lt;strong&gt;D&lt;/strong&gt; hiccups that we might get an alert (&#34;all&#34; intermediate master&#39;s slaves are not replicating). To that effect &lt;em&gt;orchestrator&lt;/em&gt; treats single slave scenarios differently than multiple slaves scenarios.&lt;/p&gt;
&lt;h3&gt;Not so fun setups and failures&lt;/h3&gt;
&lt;p&gt;At Booking.com we are in transition between setups. We have some legacy configuration, we have a roadmap, two ongoing solutions, some experimental setups, and/or all of the above combined. Sorry.&lt;/p&gt;
&lt;p&gt;Some of our masters are on SAN. We are moving away from this; for those masters on SANs we have cold standbys in an active-passive mode; so master failure -&amp;gt; unmount SAN -&amp;gt; mount SAN on cold standby -&amp;gt; start MySQL on cold standby -&amp;gt; start recovery -&amp;gt; watch some TV -&amp;gt; go shopping -&amp;gt; end recovery.&lt;/p&gt;
&lt;p&gt;Only SANs fail, too. When the master fails, switching over to the cold standby is pointless if the origin of the problem is the SAN. And given that some &lt;em&gt;other&lt;/em&gt; masters share the same SAN... whoa. As I said we&#39;re moving away from this setup for Pseudo GTID and then for Binlog Servers.&lt;/p&gt;
&lt;p&gt;The SAN setup also implied using VIPs for some servers. The slaves reference the SAN master via VIP, and when the cold standby start up it assumes the VIP, and the slaves know nothing about this. Same setup goes for DC masters. What happens when the VIP goes down? MySQL is running happily, but slaves are unable to connect. Does that make for a failover scenario? For intermediate masters we&#39;re pushing it to be so, failing over to a normal local-disk based server; this improves out confidence in non-SAN setups (which we have plenty of, anyhow).&lt;/p&gt;
&lt;h3&gt;Double checking&lt;/h3&gt;
&lt;p&gt;You sample your server once every X seconds. But in a failover scenario you want to make sure your data is up to date. When &lt;em&gt;orchestrator&lt;/em&gt; suspects a dead master (i.e. cannot reach the master) it immediately contacts its direct slaves and checks their status.&lt;/p&gt;
&lt;p&gt;Likewise, when &lt;em&gt;orchestrator&lt;/em&gt; sees a first tier slave with broken IO thread, it immediately contacts the master to check if everything is fine.&lt;/p&gt;
&lt;p&gt;For intermediate masters &lt;em&gt;orchestrator&lt;/em&gt; is not so concerned and does not issue emergency checks.&lt;/p&gt;
&lt;h3&gt;How to fail over&lt;/h3&gt;
&lt;p&gt;Different story. Some other time. But failing over makes for complex decisions, based on who the replicating slaves are; with/out log-slave-updates; with-out GTID; with/out Pseudo-GTID; are binlog servers available; which slaves are available in which data centers. Or you may be using Galera (we&#39;re not) which answers most of the above.&lt;/p&gt;
&lt;p&gt;Anyway we use &lt;em&gt;orchestrator&lt;/em&gt; for that; it knows our topologies, knows how they should look like, understands how to heal them, knows MySQL replication rules, and invokes external processes to do the stuff it doesn&#39;t understand.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orchestrator visual cheatsheet</title>
      <link>/blog/2015/06/05/orchestrator-visual-cheatsheet/</link>
      <pubDate>Fri, 05 Jun 2015 14:19:34 +0000</pubDate>
      
      <guid>/blog/2015/06/05/orchestrator-visual-cheatsheet/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt;&lt;/strong&gt; is growing. Supporting automatic detection of topologies, simple refactoring of topology trees, complex refactoring via Pseudo-GTID, failure detection and automated discovery, it is becoming larger and larger by the day.&lt;/p&gt;
&lt;p&gt;One of the problems with growign projects is hwo to properly document them. Orchestrator enjoys &lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual&#34;&gt;a comprehensive manual&lt;/a&gt;, but as these get more and more detailed, it is becoming difficult to get oriented and pointed in the right direction. I&#39;ve done my best to advise the simple use cases throughout the manual.&lt;/p&gt;
&lt;p&gt;One thing that is difficult to put into words is topologies. Explaining &#34;failover of an intermediate master S1 that has S2,...,Sn slaves onto a sibling of S1 provided that...&#34; is too verbose. So here&#39;s a quick visual cheatsheet for (current) topology refactoring commands. Refactoring commands are a mere subset of overall orchestrator commands, but they&#39;re great to play with and perfect for visualization.&lt;/p&gt;
&lt;p&gt;The &#34;move&#34; and related commands use normal replication commands (STOP SLAVE; CHANGE MASTER TO; START SLAVE UNTIL;&#34;...).&lt;/p&gt;
&lt;p&gt;The &#34;match&#34; and related commands utilize Pseudo-GTID and use more elaborate MySQL commands (SHOW BINLOG EVENTS, SHOW RELAYLOG EVENTS).&lt;/p&gt;
&lt;p&gt;So without further ado, here&#39;s what each command does (and do run &#34;orchestrator&#34; from the command line to get a man-like explanation of everything, or just &lt;a href=&#34;https://github.com/outbrain/orchestrator/wiki/Orchestrator-Manual#executing-via-command-line&#34;&gt;go to the manual&lt;/a&gt;).&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-7.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7251&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-7.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-7&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-8.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7252&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-8.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-8&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-9.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7253&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-9.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-9&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-10.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7254&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-10.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-10&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-11.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7255&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-11.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-11&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-12.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7256&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-12.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-12&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-13.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7257&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-13.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-13&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-1.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7245&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-1.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-1&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-2.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7246&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-2.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-2&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-3.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7247&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-3.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-3&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-4.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7248&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-4.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-4&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-5.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7249&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-5.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-5&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-6.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7250&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-6.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-6&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-14.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7258&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-14.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-14&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-15.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7259&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-15.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-15&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-16.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7260&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-16.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-16&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-17.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7261&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-17.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-17&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/06/orchestrator-cheatsheet-visualized-18.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7262&#34; src=&#34;/blog/blog/assets/orchestrator-cheatsheet-visualized-18.png&#34; alt=&#34;orchestrator-cheatsheet-visualized-18&#34; width=&#34;720&#34; height=&#34;405&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Speaking at Percona Live: Pseudo GTID and Easy Replication Topology Management</title>
      <link>/blog/2015/03/31/speaking-at-percona-live-pseudo-gtid-and-easy-replication-topology-management/</link>
      <pubDate>Tue, 31 Mar 2015 17:42:21 +0000</pubDate>
      
      <guid>/blog/2015/03/31/speaking-at-percona-live-pseudo-gtid-and-easy-replication-topology-management/</guid>
      <description>&lt;p&gt;In two weeks time I will be presenting &lt;a href=&#34;https://www.percona.com/live/mysql-conference-2015/sessions/pseudo-gtid-and-easy-replication-management&#34;&gt;Pseudo GTID and Easy Replication Topology Management&lt;/a&gt; at Percona Live. From the time I submitted the proposal a LOT has been developed, experimented, deployed and used with both &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; and with &lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;orchestrator&lt;/a&gt;. In my talk I will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Suggest that you skip the &#34;to GTID or not to GTID&#34; question and go for the lightweight Pseudo GTID&lt;/li&gt;
&lt;li&gt;Show how Pseudo GTID is used in production to recover from various replication failures and server crashes&lt;/li&gt;
&lt;li&gt;Do an outrageous demonstration&lt;/li&gt;
&lt;li&gt;Tell you about 50,000 successful experiments and tests done in production&lt;/li&gt;
&lt;li&gt;Show off orchestrator and its support for Pseudo GTID, including automated crash analysis and recovery mechanism.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will further show how the orchestrator tooling makes for a less restrictive, more performant, less locking, non-intrusive, trusted and lightweight replication topology management solution.&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2015/03/orchestrator-topology-simple.png&#34;&gt;&lt;img class=&#34;wp-image-7206 size-full&#34; src=&#34;/blog/blog/assets/orchestrator-topology-simple.png&#34; alt=&#34;orchestrator-topology-simple&#34; width=&#34;1010&#34; height=&#34;286&#34; /&gt;&lt;/a&gt; An anonymized topology&lt;/blockquote&gt;
&lt;p&gt;Please come by my talk! &lt;/p&gt;
&lt;p&gt;Slides: &lt;/p&gt;
&lt;p&gt;[speakerdeck https://speakerdeck.com/shlominoach/pseudo-gtid-and-easy-mysql-replication-topology-management]&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Speaking at FOSDEM: Pseudo GTID and easy replication management</title>
      <link>/blog/2015/01/29/speaking-at-fosdem-pseudo-gtid-and-easy-replication-management/</link>
      <pubDate>Thu, 29 Jan 2015 21:06:10 +0000</pubDate>
      
      <guid>/blog/2015/01/29/speaking-at-fosdem-pseudo-gtid-and-easy-replication-management/</guid>
      <description>&lt;p&gt;This coming Sunday I&#39;ll be presenting &lt;a href=&#34;https://fosdem.org/2015/schedule/event/pseudo_gtid/&#34;&gt;Pseudo GTID and easy replication management&lt;/a&gt; at FOSDEM, Brussels.&lt;/p&gt;
&lt;p&gt;There&#39;s been a lot of development on &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; these last few weeks. In this talk I&#39;ll show you how you can use Pseudo GTID instead of &#34;normal&#34; GTID to easily repoint your slaves, recover from intermediate master failure, promote slaves to masters as well as emply crash safe replication without crash safe replication.&lt;/p&gt;
&lt;p&gt;Moreover, I will show how you can achieve all the above with &lt;em&gt;less constraints&lt;/em&gt; than GTID, and for bulk operations -- with &lt;em&gt;less overhead&lt;/em&gt; and in &lt;em&gt;shorter time&lt;/em&gt;. You will also see that Pseudo GTID is a non intrusive solution which does not require you to change anything in your topologies.&lt;/p&gt;
&lt;p&gt;Moral: I&#39;ll try and convince you to &lt;em&gt;drop your plans for using GTID&lt;/em&gt; in favor of &lt;em&gt;Pseudo GTID&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We will be employing Pseudo GTID as the basis for high availability and failover at Booking.com on many topologies, and as a safety mechanism in other topologies where we will employ &lt;a href=&#34;http://blog.booking.com/mysql_slave_scaling_and_more.html&#34;&gt;Binlog servers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;http://www.slideshare.net/shlominoach/pseudo-gtid-easy-replication-topology-management-fosdem&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reading RBR binary logs with pt-query-digest</title>
      <link>/blog/2015/01/26/reading-rbr-binary-logs-with-pt-query-digest/</link>
      <pubDate>Mon, 26 Jan 2015 17:50:46 +0000</pubDate>
      
      <guid>/blog/2015/01/26/reading-rbr-binary-logs-with-pt-query-digest/</guid>
      <description>&lt;p&gt;For purposes of auditing anything that goes on our servers we&#39;re looking to parse the binary logs of all servers (masters), as with &#34;&lt;a href=&#34;http://code.openark.org/blog/mysql/anemomaster-dml-visibility-your-must-do-for-tomorrow&#34;&gt;Anemomaster&lt;/a&gt;&#34;. With Row Based Replication this is problematic since &lt;strong&gt;pt-query-digest&lt;/strong&gt; &lt;a href=&#34;https://bugs.launchpad.net/percona-toolkit/+bug/1377887&#34;&gt;does not support parsing RBR binary logs&lt;/a&gt; (true for &lt;strong&gt;2.2.12&lt;/strong&gt;, latest at this time).&lt;/p&gt;
&lt;p&gt;I&#39;ve written a simple script that translates RBR logs to SBR-like logs, with a little bit of cheating. My interest is that &lt;strong&gt;pt-query-digest&lt;/strong&gt; is able to capture and count the queries, nothing else. By doing some minimal text manipulation on the binary log I&#39;m able to now feed it to &lt;strong&gt;pt-query-digest&lt;/strong&gt; which seems to be happy.&lt;/p&gt;
&lt;p&gt;The script of course does not parse the binary log directly; furthermore, it requires the binary log to be extracted via:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;mysqlbinlog --verbose --base64-output=DECODE-ROWS your-mysql-binlog-filemame.000001&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The above adds the interpretation of the RBR entires in the form of (unconventional) statements, commented, and strips out the cryptic RBR text. All that is left is to do a little manipulation on entry headers and uncomment the interpreted queries.&lt;/p&gt;
&lt;p&gt;The script can be found in &lt;a href=&#34;https://gist.github.com/shlomi-noach/cc243fd690403e7617e3&#34;&gt;my gist repositories&lt;/a&gt;. Current version is as follows:&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[code lang=&#34;python&#34;]&lt;br /&gt;
#!/usr/bin/python&lt;br /&gt;
#&lt;br /&gt;
# Convert a Row-Based-Replication binary log to Statement-Based-Replication format, cheating a little.&lt;br /&gt;
# This script exists since Percona Toolkit&#39;s pt-query-digest cannot digest RBR format. The script&lt;br /&gt;
# generates enough for it to work with.&lt;br /&gt;
# Expecting standard input&lt;br /&gt;
# Expected input is the output of &amp;quot;mysqlbinlog --verbose --base64-output=DECODE-ROWS &amp;lt;binlog_file_name&amp;gt;&amp;quot;&lt;br /&gt;
# For example:&lt;br /&gt;
# $ mysqlbinlog --verbose --base64-output=DECODE-ROWS mysql-bin.000006 | python binlog-rbr-to-sbr.py | pt-query-digest --type=binlog --order-by Query_time:cnt --group-by fingerprint&lt;br /&gt;
#&lt;/p&gt;
&lt;p&gt;import fileinput&lt;/p&gt;
&lt;p&gt;def convert_rbr_to_pseudo_sbr():&lt;br /&gt;
    inside_rbr_statement = False&lt;br /&gt;
    for line in fileinput.input():&lt;br /&gt;
        line = line.strip()&lt;br /&gt;
        if line.startswith(&amp;quot;#&amp;quot;) and &amp;quot;end_log_pos&amp;quot; in line:&lt;br /&gt;
            for rbr_token in [&amp;quot;Update_rows:&amp;quot;, &amp;quot;Write_rows:&amp;quot;, &amp;quot;Delete_rows:&amp;quot;, &amp;quot;Rows_query:&amp;quot;, &amp;quot;Table_map:&amp;quot;,]:&lt;br /&gt;
                if rbr_token in line:&lt;br /&gt;
                    line = &amp;quot;%s%s&amp;quot; % (line.split(rbr_token)[0], &amp;quot;Query\tthread_id=1\texec_time=0\terror_code=0&amp;quot;)&lt;br /&gt;
        if line.startswith(&amp;quot;### &amp;quot;):&lt;br /&gt;
            inside_rbr_statement = True&lt;br /&gt;
            # The &amp;quot;### &amp;quot; commented rows are the pseudo-statement interpreted by mysqlbinlog&#39;s &amp;quot;--verbose&amp;quot;,&lt;br /&gt;
            # and which we will feed into pt-query-digest&lt;br /&gt;
            line = line[4:]&lt;br /&gt;
        else:&lt;br /&gt;
            if inside_rbr_statement:&lt;br /&gt;
                print(&amp;quot;/*!*/;&amp;quot;)&lt;br /&gt;
            inside_rbr_statement = False&lt;br /&gt;
        print(line) &lt;/p&gt;
&lt;p&gt;convert_rbr_to_pseudo_sbr()&lt;br /&gt;
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Orchestrator 1.2.9 GA released</title>
      <link>/blog/2014/12/18/orchestrator-1-2-9-ga-released/</link>
      <pubDate>Thu, 18 Dec 2014 18:24:59 +0000</pubDate>
      
      <guid>/blog/2014/12/18/orchestrator-1-2-9-ga-released/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt; &lt;strong&gt;1.2.9 GA&lt;/strong&gt; &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases/tag/v1.2.9&#34;&gt;has been released&lt;/a&gt;. Noteworthy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Added &#34;&lt;strong&gt;ReadOnly&lt;/strong&gt;&#34; (true/false) configuration param. You can have orchestrator completely read-only&lt;/li&gt;
&lt;li&gt;Added &lt;strong&gt;&#34;AuthenticationMethod&#34;: &#34;multi&#34;&lt;/strong&gt;: works like BasicAuth (your normal HTTP user+password) only it also accepts the special user called &lt;strong&gt;&#34;readonly&#34;&lt;/strong&gt;, which, surprise, can only view and not modify&lt;/li&gt;
&lt;li&gt;Centralized/serialized most backend database writes (with hundreds/thousands monitored servers it was possible or probable that high concurrency led to too-many-connections openned on the backend database).&lt;/li&gt;
&lt;li&gt;Fixed evil evil bug that would skip some checks if binary logs were not enabled&lt;/li&gt;
&lt;li&gt;Better hostname resolve (now also asking MySQL server to resolve hostname; resolving is cached)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pseudo-GTID&lt;/strong&gt; (read &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;http://code.openark.org/blog/mysql/orchestrator-1-2-1-beta-pseudo-gtid-support-reconnect-slaves-even-after-master-failure&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topologies-with-pseudo-gtid-a-visual-tour&#34;&gt;here&lt;/a&gt;) support now considered stable (apart from being tested it has already been put to practice multiple times in production at &lt;strong&gt;Outbrain&lt;/strong&gt;, in different planned and unplanned crash scenarios)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I continue developing &lt;em&gt;orchestrator&lt;/em&gt; as free and open source at my new employer, &lt;a href=&#34;http://www.booking.com&#34;&gt;Booking.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Semi-automatic slave/master promotion via Pseudo GTID</title>
      <link>/blog/2014/11/10/semi-automatic-slavemaster-promotion-via-pseudo-gtid/</link>
      <pubDate>Mon, 10 Nov 2014 07:56:58 +0000</pubDate>
      
      <guid>/blog/2014/11/10/semi-automatic-slavemaster-promotion-via-pseudo-gtid/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/outbrain/orchestrator&#34;&gt;Orchestrator&lt;/a&gt; release &lt;a href=&#34;https://github.com/outbrain/orchestrator/releases&#34;&gt;1.2.7-beta&lt;/a&gt; now supports semi-automatic slave promotion to master upon master death, via &lt;a href=&#34;code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-make-master-highlighted.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7150&#34; src=&#34;/blog/blog/assets/orchestrator-make-master-highlighted.png&#34; alt=&#34;orchestrator-make-master-highlighted&#34; width=&#34;809&#34; height=&#34;363&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;When the master is dead, &lt;em&gt;orchestrator&lt;/em&gt; automatically picks the most up-to-date slaves and marks them as &lt;strong&gt;&#34;Master candidates&#34;&lt;/strong&gt;. It allows a &lt;strong&gt;/api/make-master&lt;/strong&gt; call on such a slave (S), in which case it uses &lt;a href=&#34;http://code.openark.org/blog/mysql/refactoring-replication-topology-with-pseudo-gtid&#34;&gt;Pseudo GTID&lt;/a&gt; to enslave its siblings, and set S as &lt;strong&gt;read-only = 0&lt;/strong&gt;. All we need to do is click the &lt;strong&gt;&#34;Make master&#34;&lt;/strong&gt; button.&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-make-master-confirm1.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-7145&#34; src=&#34;/blog/blog/assets/orchestrator-make-master-confirm1.png&#34; alt=&#34;orchestrator-make-master-confirm&#34; width=&#34;946&#34; height=&#34;367&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, &lt;strong&gt;&#34;OK&#34;&lt;/strong&gt;. A moment later:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/10/orchestrator-make-master-refactored1.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7146&#34; src=&#34;/blog/blog/assets/orchestrator-make-master-refactored1-1024x256.png&#34; alt=&#34;orchestrator-make-master-refactored&#34; width=&#34;1024&#34; height=&#34;256&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;See how the two slaves &lt;strong&gt;22988&lt;/strong&gt;, &lt;strong&gt;22989&lt;/strong&gt; are happily replicating from &lt;strong&gt;22990&lt;/strong&gt;. Turning them into &lt;strong&gt;22990&lt;/strong&gt;&#39;s slave was possible even though their shared master was dead and were stopped at different replication positions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;22990&lt;/strong&gt; is now writeable, and its on you to disconnect from its old master and to direct your application into this newly promoted instance.&lt;/p&gt;
&lt;h4&gt;Local master promotion&lt;/h4&gt;
&lt;p&gt;Likewise, a semi-automated solution for the corruption of a local master is in place. Consider the following, where &lt;strong&gt;22989&lt;/strong&gt; is dead/inaccessible. &lt;strong&gt;22988&lt;/strong&gt; and &lt;strong&gt;22990&lt;/strong&gt; are stuck in replication:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/11/orchestrator-make-local-master.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7164&#34; src=&#34;/blog/blog/assets/orchestrator-make-local-master-1024x263.png&#34; alt=&#34;orchestrator-make-local-master&#34; width=&#34;1024&#34; height=&#34;263&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Orchestrator&lt;/em&gt; detects this situation and picks the most up-to-date slave, marking it as candidate for promotion. Click &lt;strong&gt;&#34;Make lock master&#34;&lt;/strong&gt; to get:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/11/orchestrator-make-local-master-confirm.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7165&#34; src=&#34;/blog/blog/assets/orchestrator-make-local-master-confirm-1024x257.png&#34; alt=&#34;orchestrator-make-local-master-confirm&#34; width=&#34;1024&#34; height=&#34;257&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;Sure, OK:&lt;/p&gt;
&lt;blockquote&gt;&lt;a href=&#34;http://code.openark.org/blog/wp-content/uploads/2014/11/orchestrator-make-local-master-refactored.png&#34;&gt;&lt;img class=&#34;alignnone size-large wp-image-7166&#34; src=&#34;/blog/blog/assets/orchestrator-make-local-master-refactored-1024x276.png&#34; alt=&#34;orchestrator-make-local-master-refactored&#34; width=&#34;1024&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;And now &lt;strong&gt;22990&lt;/strong&gt; takes over instead of &lt;strong&gt;22989&lt;/strong&gt;, enslaving &lt;strong&gt;22988&lt;/strong&gt;, both running happily ever after.&lt;/p&gt;
&lt;h4&gt; Automation&lt;/h4&gt;
&lt;p&gt;The above buttons are just convenience methods. You don&#39;t strictly need visualization/GUI for that. Everything is supported by the API, and can be used by a fully automated monitoring system. More to come in &lt;em&gt;orchestrator&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>